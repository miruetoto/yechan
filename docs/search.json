[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "신록예찬's Blog",
    "section": "",
    "text": "About this blog\nThis blog was created for my personal research, study and lecture preparation. Therefore, the contents of the blog can be thought of as my practice notes. As a result, sometimes the content of a post may be left unstructured or unfinished. The blog is named after my favorite essay ‘신록예찬’, which is also a nickname I use informally. You can check the written article in the sidebar on the left. It is a great honor for me if these posts can help others to learn and research.\n\nSome links that help me\n\nstudysresearchesfirst batchsecond batchthird batchlectures notes\n\n\n\nasdf\n\n\n\n\nebt: https://miruetoto.github.io/ebt-guide/\n\n\n\n\npaperswithcode: https://paperswithcode.com/\n플루토: https://cotangent.dev/how-to-publish-pluto-jl-notebooks-online-interactively/\n연구비: http://scieng.net/now/1047\n\n\n\n\nmatplotlib: https://matplotlib.org/stable/gallery/index.html\njupyterlab: https://jupyterlab.readthedocs.io/en/stable/index.html\npandas: https://pandas.pydata.org/docs/user_guide/index.html#user-guide\njulia: https://docs.julialang.org/en/v1/\nkeras: https://keras.io/examples/\njulia plots: https://docs.juliaplots.org/stable/\npytorch lightning: https://www.pytorchlightning.ai/\nplotly: https://plotly.com/graphing-libraries/\nquarto: https://quarto.org/\nAutoGluon: https://auto.gluon.ai/stable/index.html\n\n\n\n\nlatex: https://editor.codecogs.com/\ntable: https://www.tablesgenerator.com/\npytorch lightning (codes in book): https://github.com/PacktPublishing/Deep-Learning-with-PyTorch-Lightning\nPyG: https://github.com/rusty1s/pytorch_geometric\nrayshader: https://www.rayshader.com/reference/plot_gg.html\nSouth Korea (map): https://github.com/southkorea\nregexp: https://zvon.org/comp/m/regexp.html\nrpy2: https://rpy2.github.io/doc/v3.1.x/html/index.html\npywave: https://pywavelets.readthedocs.io/en/latest/ref/wavelets.html\nPyGSP: https://pygsp.readthedocs.io/en/stable/#\nlatex (neural networks): https://tikz.net/neural_networks/\nplotly overview: https://plotly.com/python/plotly-express/\nfastai (official): https://docs.fast.ai/\nfastai (lecture): https://course.fast.ai/#\nfastai (github codes): https://github.com/fastai/fastai/tree/master/dev_nbs/course\nGML (codes in book): https://github.com/PacktPublishing/Graph-Machine-Learning\nGMLKOR (codes in book): https://github.com/AcornPublishing/graph-ml\nmathNET https://gtribello.github.io/mathNET/index.html\n\n\n\n\nhttp://personal.psu.edu/drh20/asymp/fall2006/lectures/\nhttps://web.ma.utexas.edu/users/gordanz/lecture_notes_page.html\n\n\n\n\n\n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nDec 31, 2024\n\n\n(업무) 성과입력\n\n\n신록예찬 \n\n\n\n\nDec 31, 2024\n\n\n(업무) qrcode – 학교이메일접근하기\n\n\n신록예찬 \n\n\n\n\nJan 26, 2024\n\n\n(공부) 조건부확률, 조건부기대값\n\n\n신록예찬 \n\n\n\n\nJan 16, 2024\n\n\n(메모) R package 만들기\n\n\n신록예찬 \n\n\n\n\nOct 26, 2023\n\n\n(공부) Julia – Vector\n\n\n신록예찬 \n\n\n\n\nOct 25, 2023\n\n\n(공부) Julia – 문자와 문자열\n\n\n신록예찬 \n\n\n\n\nSep 24, 2023\n\n\n(코드) ggraph\n\n\n신록예찬 \n\n\n\n\nJul 4, 2023\n\n\n(공부) 토폴로지\n\n\n신록예찬 \n\n\n\n\nJan 20, 2023\n\n\n(공부) 추정\n\n\n신록예찬 \n\n\n\n\nDec 23, 2022\n\n\n(리뷰) EbayesThresh: R Programs for Empirical Bayes Thresholding\n\n\n신록예찬 \n\n\n\n\nApr 26, 2019\n\n\n(공부) 퓨리에변환\n\n\n신록예찬 \n\n\n\n\nJan 10, 2000\n\n\n(메모) DGX station 설정\n\n\n신록예찬 \n\n\n\n\nJan 9, 2000\n\n\n(메모) docker\n\n\n신록예찬 \n\n\n\n\nJan 8, 2000\n\n\n(메모) 주피터랩, 설정 및 몇가지 팁\n\n\n신록예찬 \n\n\n\n\nJan 7, 2000\n\n\n(메모) 줄리아 설치 및 실행\n\n\n신록예찬 \n\n\n\n\nJan 6, 2000\n\n\n(메모) 깃 익히기\n\n\n신록예찬 \n\n\n\n\nJan 5, 2000\n\n\n(메모) vi 익히기\n\n\n신록예찬 \n\n\n\n\nJan 4, 2000\n\n\n(메모) 우분투 익히기\n\n\n신록예찬 \n\n\n\n\nJan 4, 2000\n\n\n(메모) tmux\n\n\n신록예찬 \n\n\n\n\nJan 2, 2000\n\n\n(메모) 우분투 포맷 및 개발용 서버 셋팅2\n\n\n신록예찬 \n\n\n\n\nJan 1, 2000\n\n\n(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)\n\n\n신록예찬 \n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2000-01-06-(메모) 깃 익히기.html",
    "href": "posts/2000-01-06-(메모) 깃 익히기.html",
    "title": "(메모) 깃 익히기",
    "section": "",
    "text": "github repository \\(\\to\\) code \\(\\to\\) clone tab, ssh를 복사 (git@github.com:miruetoto/yechan.git처럼 생김)\n터미널에서 아래를 입력\ngit clone git@github.com:miruetoto/yechan.git 01_yechan"
  },
  {
    "objectID": "posts/2000-01-06-(메모) 깃 익히기.html#clone",
    "href": "posts/2000-01-06-(메모) 깃 익히기.html#clone",
    "title": "(메모) 깃 익히기",
    "section": "",
    "text": "github repository \\(\\to\\) code \\(\\to\\) clone tab, ssh를 복사 (git@github.com:miruetoto/yechan.git처럼 생김)\n터미널에서 아래를 입력\ngit clone git@github.com:miruetoto/yechan.git 01_yechan"
  },
  {
    "objectID": "posts/2000-01-06-(메모) 깃 익히기.html#pull",
    "href": "posts/2000-01-06-(메모) 깃 익히기.html#pull",
    "title": "(메모) 깃 익히기",
    "section": "2 pull",
    "text": "2 pull\n- 깃이 설치된 가장 상위폴더(Documents/Github/miruetoto.github.io)에 가서 아래를 입력한다.\ngit pull"
  },
  {
    "objectID": "posts/2000-01-06-(메모) 깃 익히기.html#branch",
    "href": "posts/2000-01-06-(메모) 깃 익히기.html#branch",
    "title": "(메모) 깃 익히기",
    "section": "3 branch",
    "text": "3 branch\n- 서버에 이미 guebin이라는 브랜치가 있다면 아래와 같이 동기화 시킨다.\ngit chechout guebin\ngit push -u origin guebin\n여기에서 git push -u origin guebin을 안해도 동기화가 잘될때도 있는데 아닐때도 있다."
  },
  {
    "objectID": "posts/2000-01-06-(메모) 깃 익히기.html#remote",
    "href": "posts/2000-01-06-(메모) 깃 익히기.html#remote",
    "title": "(메모) 깃 익히기",
    "section": "4 remote",
    "text": "4 remote\n- 깃이 설치된 가장 상위폴더(Documents/Github/miruetoto.github.io)에 가서 아래를 입력하면 깃허브의 url 주소를 확인할 수 있다.\n(base) lgcgb2@lgcgb2:~/Documents/GitHub/miruetoto.github.io$ git remote -v\norigin https://github.com/miruetoto/miruetoto.github.io.git (fetch)\norigin https://github.com/miruetoto/miruetoto.github.io.git (push)\nupstream https://github.com/daattali/beautiful-jekyll.git (fetch)\nupstream https://github.com/daattali/beautiful-jekyll.git (push)"
  },
  {
    "objectID": "posts/2000-01-06-(메모) 깃 익히기.html#config",
    "href": "posts/2000-01-06-(메모) 깃 익히기.html#config",
    "title": "(메모) 깃 익히기",
    "section": "5 config",
    "text": "5 config\n- 설정보기\ngit config —list \n- 설정삭제\ngit config --unset user.name\ngit config --unser user.email\n- 전역설정삭제\ngit config --unset --global user.name\ngit config --unset --global user.email\n- 중복값 설정삭제\ngit config --unset-all user.name\ngit config --unset-all user.email\n- 중복값 전역으로 설정삭제\ngit config --unset-all --global user.name\ngit config --unset-all --global user.email\n- 비번안치고 푸쉬하는법?\ngit config credential.helper store\n입력이후에 git push"
  },
  {
    "objectID": "posts/2000-01-06-(메모) 깃 익히기.html#git-token",
    "href": "posts/2000-01-06-(메모) 깃 익히기.html#git-token",
    "title": "(메모) 깃 익히기",
    "section": "6 git token",
    "text": "6 git token\nhttps://github.com/settings/tokens 에서 확인가능"
  },
  {
    "objectID": "posts/2000-01-10-(메모) DGX staion.html",
    "href": "posts/2000-01-10-(메모) DGX staion.html",
    "title": "(메모) DGX station 설정",
    "section": "",
    "text": "- root 획득\nsudo -i \n- 모든 GPU enable\nnvidia-smi -mig 1 \nsudo systemctl stop nvidia-mig-manager.service\nsudo systemctl disable nvidia-mig-manager.service\nreboot\n- 모든 특정 GPU만 enable\n#nvidia-smi -i {GPUdev-ID} -mig 1\nnvidia-smi -i 0 -mig 1 \nsudo systemctl stop nvidia-mig-manager.service\nsudo systemctl disable nvidia-mig-manager.service\nreboot \n- GPU가 MIG 모드로 되면 아래와 같이 GPU-Util 에 N/A로 표시된다. 아래는 0,1,2,4 에 대응하는 GPU가 MIG모드로 설정된 상태임\n\n\n\n\n- 용어정리\n\nGPU: 말 그대로 GPU\nGI: GPU INSTANCE, 하나의 GPU에 여러개의 GPU INSTANCE가 존재할 수 있음.\nCI: COMPUTE INSTANCE, 하나의 GPU INSTANCE에 여러개의 COMPUTE INSTANCE를 만들 수 있음.\n\n- 상황확인\nnvidia-smi \n\n- GPU의 해석\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 470.141.03   Driver Version: 470.141.03   CUDA Version: 11.4     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  NVIDIA A100-SXM...  On   | 00000000:01:00.0 Off |                   On |\n| N/A   37C    P0    53W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   1  NVIDIA A100-SXM...  On   | 00000000:47:00.0 Off |                   On |\n| N/A   38C    P0    52W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   2  NVIDIA A100-SXM...  On   | 00000000:81:00.0 Off |                   On |\n| N/A   37C    P0    54W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   3  NVIDIA DGX Display  On   | 00000000:C1:00.0 Off |                  N/A |\n| 36%   39C    P8    N/A /  50W |      1MiB /  3911MiB |      0%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n|   4  NVIDIA A100-SXM...  On   | 00000000:C2:00.0 Off |                   On |\n| N/A   37C    P0    55W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n총 4개의 GPU가 있으며 아이디는 0,1,2,4 임을 알 수 있다.\n- GPUdev-ID, GI-ID, CI-ID, MIGdev-ID 확인\n+-----------------------------------------------------------------------------+\n| MIG devices:                                                                |\n+------------------+----------------------+-----------+-----------------------+\n| GPU  GI  CI  MIG |         Memory-Usage |        Vol|         Shared        |\n|      ID  ID  Dev |           BAR1-Usage | SM     Unc| CE  ENC  DEC  OFA  JPG|\n|                  |                      |        ECC|                       |\n|==================+======================+===========+=======================|\n|  1    0   0   0  |      0MiB / 81251MiB | 98      0 |  7   0    5    1    1 |\n|                  |      1MiB / 13107... |           |                       |\n+------------------+----------------------+-----------+-----------------------+\n|  2    0   0   0  |      0MiB / 81251MiB | 98      0 |  7   0    5    1    1 |\n|                  |      1MiB / 13107... |           |                       |\n+------------------+----------------------+-----------+-----------------------+\n아래와 같은 상황을 유추할 수 있다.\n\n\n\nGPUdev ID\nGI ID\nCI ID\nMIGdev ID\n\n\n\n\n1\n0 (80G)\n0 (98SM)\n0\n\n\n2\n0 (80G)\n0 (98SM)\n0\n\n\n\n- 생성가능한 gi 확인\n\n- 생성가능한 ci 확인\n\n\n\nNote: GPU 1,2 에만 GI가 존재하므로, 목록에는 GPU 1,2 만 보임\n\n\n\n\n\n- GPUdev = 4 에서 생성가능한 GI 조회\n#nvidia-smi mig -i {GPUdev-ID} -lgip\nnvidia-smi mig -i 4 -lgip\n\n- 아래에 해당하는 GI를 2개 생성하고 싶다고 하자. (GPU-INSTANCE-PROFILE-ID=9 임을 유의)\n+-----------------------------------------------------------------------------+\n| GPU instance profiles:                                                      |\n| GPU   Name             ID    Instances   Memory     P2P    SM    DEC   ENC  |\n|                              Free/Total   GiB              CE    JPEG  OFA  |\n|=============================================================================|\n|   4  MIG 3g.40gb        9     0/2        39.50      No     42     2     0   |\n|                                                             3     0     0   |\n+-----------------------------------------------------------------------------+\n#nvidia-smi mig -i {GPUdev-ID} -cgi {GPU-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -cgi 9 \nnvidia-smi mig -i 4 -cgi 9 \n\n\n\nNote: 2개까지는 잘 ㅁ나들어지고 그 이후에는 리소스 부족으로 에러가 발생한다.\n\n\n\n2개까지는 잘 만들어지고 그 이후에는 리소스부족으로 에러발생\n\n- 만들어진 GI 확인\n\n\n\nNote: 1,2번 GPU에 각각 GI가 1개씩 있고 4번 GPU에 GI가 2개 있다.\n\n\n- 생성가능한 CI 확인\nnvidia-smi mig -lcip\n\n\n\nNote: {GPU ID: GPU INSTANCE ID} 의 조합에서 {1:0}, {2:0}, {4:1}, {4:2} 에 해당하는 GI에서 생성가능한 CI들이 각각 출력된다. 4번 GPU의 GI들은 40기가가 한계이므로 생성가능 CI목록이 상대적으로 제한적임을 캐치하라\n\n\n\n\n\n- GPUdev=4 에서 생성가능한 CI 조회\n#nvidia-smi mig -i {GPU ID} -lcip\nnvidia-smi mig -i 4 -lcip\n\n\n\nNote: 각 GPU-인스턴스(GI)에서는 3개 계산-인스턴스(CI)를 만들수 있음. 만약에 Profile ID = 0 으로 만든다면 14의 계산능력을 가진 CI를 3개까지 만들수 있음, 만약 Profile ID = 2* 로 만든다면 42개의 계산능력을 가진 CI를 1개만 만들 수 있음\n\n\n- {GPUdev-ID:GI-ID} = {4:1} 에서 COMPUTE-INSTANCE-PROFILE-ID=0 에 해당하는 CI를 3개 생성\n#nvidia-smi mig -i {GPUdev-ID} -gi {GI-ID} -cci {COMPUTE-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -gi 1 -cci 0\n\n\n\nNote: 자원부족으로 3개까지 밖에 못만든다..\n\n\n- {GPUdev-ID:GI-ID}={4:2} 에서 COMPUTE-INSTANCE-PROFILE-ID=2 에 해당하는 CI를 1개 생성\n#nvidia-smi mig -i {GPUdev-ID} -gi {GI-ID} -cci {COMPUTE-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -gi 2 -cci 2 \n\n\n\nNote: 자원이 부족해서 1개밖에 못 만든다.\n\n\n- 현재 상황\n\n\n\n\nGPUdev ID\nGI ID\nCI ID\nMIGdev ID\n\n\n\n\n1\n0 (80G)\n0 (98SM)\n0\n\n\n2\n0 (80G)\n0 (98SM)\n0\n\n\n4\n1 (80G)\n0 (14SM)\n0\n\n\n4\n1 (80G)\n1 (14SM)\n1\n\n\n4\n1 (80G)\n2 (14SM)\n2\n\n\n4\n2 (80G)\n0 (42SM)\n3\n\n\n\n\n\n\nnvidia-smi mig -i 0 -cgi 0   \nnvidia-smi mig -i 1 -cgi 0   \nnvidia-smi mig -i 2 -cgi 0   \nnvidia-smi mig -i 4 -cgi 0   \nnvidia-smi mig -i 0 -gi 0 -cci 4\nnvidia-smi mig -i 1 -gi 0 -cci 4\nnvidia-smi mig -i 2 -gi 0 -cci 4\nnvidia-smi mig -i 4 -gi 0 -cci 4"
  },
  {
    "objectID": "posts/2000-01-10-(메모) DGX staion.html#mig",
    "href": "posts/2000-01-10-(메모) DGX staion.html#mig",
    "title": "(메모) DGX station 설정",
    "section": "",
    "text": "- root 획득\nsudo -i \n- 모든 GPU enable\nnvidia-smi -mig 1 \nsudo systemctl stop nvidia-mig-manager.service\nsudo systemctl disable nvidia-mig-manager.service\nreboot\n- 모든 특정 GPU만 enable\n#nvidia-smi -i {GPUdev-ID} -mig 1\nnvidia-smi -i 0 -mig 1 \nsudo systemctl stop nvidia-mig-manager.service\nsudo systemctl disable nvidia-mig-manager.service\nreboot \n- GPU가 MIG 모드로 되면 아래와 같이 GPU-Util 에 N/A로 표시된다. 아래는 0,1,2,4 에 대응하는 GPU가 MIG모드로 설정된 상태임\n\n\n\n\n- 용어정리\n\nGPU: 말 그대로 GPU\nGI: GPU INSTANCE, 하나의 GPU에 여러개의 GPU INSTANCE가 존재할 수 있음.\nCI: COMPUTE INSTANCE, 하나의 GPU INSTANCE에 여러개의 COMPUTE INSTANCE를 만들 수 있음.\n\n- 상황확인\nnvidia-smi \n\n- GPU의 해석\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 470.141.03   Driver Version: 470.141.03   CUDA Version: 11.4     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  NVIDIA A100-SXM...  On   | 00000000:01:00.0 Off |                   On |\n| N/A   37C    P0    53W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   1  NVIDIA A100-SXM...  On   | 00000000:47:00.0 Off |                   On |\n| N/A   38C    P0    52W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   2  NVIDIA A100-SXM...  On   | 00000000:81:00.0 Off |                   On |\n| N/A   37C    P0    54W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n|   3  NVIDIA DGX Display  On   | 00000000:C1:00.0 Off |                  N/A |\n| 36%   39C    P8    N/A /  50W |      1MiB /  3911MiB |      0%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n|   4  NVIDIA A100-SXM...  On   | 00000000:C2:00.0 Off |                   On |\n| N/A   37C    P0    55W / 275W |      0MiB / 81251MiB |     N/A      Default |\n|                               |                      |              Enabled |\n+-------------------------------+----------------------+----------------------+\n총 4개의 GPU가 있으며 아이디는 0,1,2,4 임을 알 수 있다.\n- GPUdev-ID, GI-ID, CI-ID, MIGdev-ID 확인\n+-----------------------------------------------------------------------------+\n| MIG devices:                                                                |\n+------------------+----------------------+-----------+-----------------------+\n| GPU  GI  CI  MIG |         Memory-Usage |        Vol|         Shared        |\n|      ID  ID  Dev |           BAR1-Usage | SM     Unc| CE  ENC  DEC  OFA  JPG|\n|                  |                      |        ECC|                       |\n|==================+======================+===========+=======================|\n|  1    0   0   0  |      0MiB / 81251MiB | 98      0 |  7   0    5    1    1 |\n|                  |      1MiB / 13107... |           |                       |\n+------------------+----------------------+-----------+-----------------------+\n|  2    0   0   0  |      0MiB / 81251MiB | 98      0 |  7   0    5    1    1 |\n|                  |      1MiB / 13107... |           |                       |\n+------------------+----------------------+-----------+-----------------------+\n아래와 같은 상황을 유추할 수 있다.\n\n\n\nGPUdev ID\nGI ID\nCI ID\nMIGdev ID\n\n\n\n\n1\n0 (80G)\n0 (98SM)\n0\n\n\n2\n0 (80G)\n0 (98SM)\n0\n\n\n\n- 생성가능한 gi 확인\n\n- 생성가능한 ci 확인\n\n\n\nNote: GPU 1,2 에만 GI가 존재하므로, 목록에는 GPU 1,2 만 보임\n\n\n\n\n\n- GPUdev = 4 에서 생성가능한 GI 조회\n#nvidia-smi mig -i {GPUdev-ID} -lgip\nnvidia-smi mig -i 4 -lgip\n\n- 아래에 해당하는 GI를 2개 생성하고 싶다고 하자. (GPU-INSTANCE-PROFILE-ID=9 임을 유의)\n+-----------------------------------------------------------------------------+\n| GPU instance profiles:                                                      |\n| GPU   Name             ID    Instances   Memory     P2P    SM    DEC   ENC  |\n|                              Free/Total   GiB              CE    JPEG  OFA  |\n|=============================================================================|\n|   4  MIG 3g.40gb        9     0/2        39.50      No     42     2     0   |\n|                                                             3     0     0   |\n+-----------------------------------------------------------------------------+\n#nvidia-smi mig -i {GPUdev-ID} -cgi {GPU-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -cgi 9 \nnvidia-smi mig -i 4 -cgi 9 \n\n\n\nNote: 2개까지는 잘 ㅁ나들어지고 그 이후에는 리소스 부족으로 에러가 발생한다.\n\n\n\n2개까지는 잘 만들어지고 그 이후에는 리소스부족으로 에러발생\n\n- 만들어진 GI 확인\n\n\n\nNote: 1,2번 GPU에 각각 GI가 1개씩 있고 4번 GPU에 GI가 2개 있다.\n\n\n- 생성가능한 CI 확인\nnvidia-smi mig -lcip\n\n\n\nNote: {GPU ID: GPU INSTANCE ID} 의 조합에서 {1:0}, {2:0}, {4:1}, {4:2} 에 해당하는 GI에서 생성가능한 CI들이 각각 출력된다. 4번 GPU의 GI들은 40기가가 한계이므로 생성가능 CI목록이 상대적으로 제한적임을 캐치하라\n\n\n\n\n\n- GPUdev=4 에서 생성가능한 CI 조회\n#nvidia-smi mig -i {GPU ID} -lcip\nnvidia-smi mig -i 4 -lcip\n\n\n\nNote: 각 GPU-인스턴스(GI)에서는 3개 계산-인스턴스(CI)를 만들수 있음. 만약에 Profile ID = 0 으로 만든다면 14의 계산능력을 가진 CI를 3개까지 만들수 있음, 만약 Profile ID = 2* 로 만든다면 42개의 계산능력을 가진 CI를 1개만 만들 수 있음\n\n\n- {GPUdev-ID:GI-ID} = {4:1} 에서 COMPUTE-INSTANCE-PROFILE-ID=0 에 해당하는 CI를 3개 생성\n#nvidia-smi mig -i {GPUdev-ID} -gi {GI-ID} -cci {COMPUTE-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -gi 1 -cci 0\n\n\n\nNote: 자원부족으로 3개까지 밖에 못만든다..\n\n\n- {GPUdev-ID:GI-ID}={4:2} 에서 COMPUTE-INSTANCE-PROFILE-ID=2 에 해당하는 CI를 1개 생성\n#nvidia-smi mig -i {GPUdev-ID} -gi {GI-ID} -cci {COMPUTE-INSTANCE-PROFILE-ID}\nnvidia-smi mig -i 4 -gi 2 -cci 2 \n\n\n\nNote: 자원이 부족해서 1개밖에 못 만든다.\n\n\n- 현재 상황\n\n\n\n\nGPUdev ID\nGI ID\nCI ID\nMIGdev ID\n\n\n\n\n1\n0 (80G)\n0 (98SM)\n0\n\n\n2\n0 (80G)\n0 (98SM)\n0\n\n\n4\n1 (80G)\n0 (14SM)\n0\n\n\n4\n1 (80G)\n1 (14SM)\n1\n\n\n4\n1 (80G)\n2 (14SM)\n2\n\n\n4\n2 (80G)\n0 (42SM)\n3\n\n\n\n\n\n\nnvidia-smi mig -i 0 -cgi 0   \nnvidia-smi mig -i 1 -cgi 0   \nnvidia-smi mig -i 2 -cgi 0   \nnvidia-smi mig -i 4 -cgi 0   \nnvidia-smi mig -i 0 -gi 0 -cci 4\nnvidia-smi mig -i 1 -gi 0 -cci 4\nnvidia-smi mig -i 2 -gi 0 -cci 4\nnvidia-smi mig -i 4 -gi 0 -cci 4"
  },
  {
    "objectID": "posts/2000-01-10-(메모) DGX staion.html#docker",
    "href": "posts/2000-01-10-(메모) DGX staion.html#docker",
    "title": "(메모) DGX station 설정",
    "section": "2 DOCKER",
    "text": "2 DOCKER\n\n2.1 컨테이너 생성\n- 아래와 같은 방식으로 컨테이너 생성\n# nvidia-docker run --gpus '\"device={GPUdev-ID}:{MIGdev-ID}\"' -ti --rm -d -t -p {HOST-PORT}:{CONTAINER-PORT} {DOCKER-IMAGE-NAME} /bin/bash\nnvidia-docker run --gpus '\"device=1:0\"' -ti --rm -d -t -p 7749:7749  -p 1307:1307 ubuntu /bin/bash\nnvidia-docker run --gpus '\"device=2:0\"' -ti -d -t -p 4653:4653  -p 1212:1212 -p 1213:1213 -p 1214:1214 ubuntu /bin/bash\n\n-ti: 컨테이너를 대화형(interactive) 모드로 실행. 이 모드에서 컨테이너와 상호작용할 수 있음.\n--rm: 컨테이너가 종료되면 자동으로 컨테이너를 삭제. 이 옵션을 사용하면 컨테이너를 실행한 후 자동으로 정리.\n-d: 컨테이너를 백그라운드(background) 모드로 실행. 이 옵션을 사용하면 컨테이너가 백그라운드에서 실행되며 터미널이 차지되지 않음.\n-t: 컨테이너에 tty (터미널)를 할당. 이것은 대화형 모드와 함께 사용.\n/bin/bash: 컨테이너가 시작될 때 실행할 명령어. 이 경우, Bash 셸을 실행.\n\n\n\n2.2 컨테이너 실행\ndocker exec -ti {CONTAINER-ID} bash\n\n여기에서 {CONTAINER-ID}는 docker ps 혹은 docker ps -a로 확인한다.\n\n\n\n2.3 요약\nnvidia-docker run --gpus '\"device=2:0\"' -ti -d -t -p ????:???? -p ????:???? -p ????:???? -p ????:???? -p ????:???? --name cgb ubuntu /bin/bash\ndocker exec -ti cgb bash"
  },
  {
    "objectID": "posts/2000-01-10-(메모) DGX staion.html#ubuntu",
    "href": "posts/2000-01-10-(메모) DGX staion.html#ubuntu",
    "title": "(메모) DGX station 설정",
    "section": "3 UBUNTU",
    "text": "3 UBUNTU\n\n3.1 passwd\n- 아래를 실행하여 비밀번호를 바꿀것\npasswd root\n\n\n3.2 update & 쓸만한 패키지 설치\n- update\napt update \napt install gcc\napt install build-essential\n- 쓸만한 패키지 설치\napt install vim # vim \napt install openssh-server # ssh \napt install git # git \napt install tmux\n- 요약\napt update && apt install -y gcc build-essential vim openssh-server git tmux\n\n\n3.3 ssh 설정\n- /etc/ssh/sshd_config 열기\n# apt install openssh-server\nvi /etc/ssh/sshd_config \n- /etc/ssh/sshd_config 파일내용 맨아래 아래를 추가\n\n...\n...\nPort {My-SSH-Port}\nPermitRootLogin yes\nPasswordAuthentication yes\n- 아래를 실행\nservice ssh restart\n\n\n3.4 anaconda\n- 다운로드: https://www.anaconda.com/download\n- (아나콘다 설치) 아나콘다를 다운받은 폴더로 가서 아래와 같이 실행한다.\nbash Anaconda3-2019.03-Linux-x86_64.sh\n대충 bash Ana 정도까지만 치고 tab을 누르면 알아서 완성된다.\n\n\n3.5 vscode\n- 아래를 이용하여 설치\ncurl -Lk 'https://code.visualstudio.com/sha/download?build=stable&os=cli-alpine-x64' --output vscode_cli.tar.gz\ntar -xf vscode_cli.tar.gz\n- 아래를 이용하여 초기 설정 (깃헙아이디로 인증)\n./code tunnel \n- 초기설정 이후 아래를 이용하여 백그라운드에서 실행\nnohup ./code tunnel &gt; /dev/null 2&gt;&1 &\n\n\n3.6 Jupyter\n- 설정파일 생성\njupyter notebook --generate-config\n- 패스워드 설정\njupyter notebook password\n## 패스워드 치고\n## 확인해야함\n- 설정파일을 열고\nvi /home/cgb2/.jupyter/jupyter_notebook_config.py\n아래의 내용을 수정한다.\nc.??????App.ip = '0.0.0.0'\nc.??????App.port = 1307\nc.??????App.allow_origin = '*'\nc.??????App.allow_remote_access = True\nc.??????App.allow_root = True\n- 주피터 실행할때 아래로 실행\nnohup jupyter lab --ip=\"0.0.0.0\" --port={MY-PORT} --no-browser --allow-root &gt; /dev/null 2&gt;&1 &"
  },
  {
    "objectID": "posts/2000-01-05-(메모) vi 익히기.html",
    "href": "posts/2000-01-05-(메모) vi 익히기.html",
    "title": "(메모) vi 익히기",
    "section": "",
    "text": "예제: vi를 이용하여 파일 만들고 asdf 입력 후 저장 및 종료를 수행하여 보자.\n\n\nstep1step2step3step4step5\n\n\n- 파일생성\nvim test230803.txt \n\n\n\n- 편집모드로 전환: i를 누른다.\n\n아래에 -- INSERT -- 라고 표현되어 있으면 편집모드라는 의미\n\n\n\n\n- asdf 입력\n\n\n\n- 편집모드 종료, 노말모드 진입:esc 입력\n\n아래에 -- INSERT -- 라는 표현이 사라져있음. 이 상황에서 명령어 입력가능.\n\n\n\n\n- 저장(w)+종료(q): : 입력하여 명령모드로 진입. w+ q + Enter 입력\n\n\n\n\n\n\n\n\n예제: vi 에서 좌우로 커서를 이동해보자.\n\n\nstep1step2step3\n\n\n- 생성된 파일로 들어가기\nvim test230803.txt \n\n\n\n- l을 세번눌러서 오른쪽으로 3칸 이동\n\nl이 아니라 실수로 ㅣ를 누르면 동작하지 않음.\n대충 화살표 눌러도 동작함\n\n\n\n\n- h을 세번눌러서 왼쪽으로 3칸 이동\n\nh가 아니라 실수로 ㅗ를 누르면 동작하지 않음.\n대충 화살표 눌러도 동작함\n\n\n\n\n\n\n\n\n\n예제: vi에서 새로운라인을 추가하고 asdf2입력하여 보자.\n\n\nstep1step2step3\n\n\n- 준비작업: 명령모드에서 다음라인을 만들고 싶은 라인에 커서를 위치\n\n\n\n- o를 누른다: 편집모드로 전환 + 새로운 라인이 추가의 효과\n\n\n\n- asdf2입력\n\n\n\n\n\n\n\n\n예제: vi에서 j,k를 이용하여 커서를 이동하여 보자. (풀이는 생략)\n\n\n\n\n\n예제: vi에서 home/end 와 같은 방식으로 커서를 이동해보자\n\n\nstep1step2step3\n\n\n- 준비작업: 명령모드에서 home/end를 사용할 line으로 커서를 이동시킴\n\n\n\n- 라인의 맨 마지막으로 가고싶다면? $를 입력한다.\n\n\n\n- 다시 라인의 맨 처음으로 가고싶다면? 숫자 0을 입력한다.\n\n\n\n\n\n\n\n\n예제: vi에서 하나의 줄을 복사하고 아래로 붙여넣기 해보자.\n\n\nstep1step2step3\n\n\n- 복사하고싶은 라인으로 이동 + yy 입력\n\n\n\n- 아래로 붙여넣을 라인으로 이동\n\n\n\n- p 입력\n\n\n\n\n\n\n\n\n예제: vi에서 w와 b를 이용하여 단어단위로 커서를 이동시켜보자. (풀이생략)\n\n\n\n\n\n예제: vi에서 원하는 단어는 찾아보자.\n\n\nstep1step2step3step4\n\n\n- /asdf2 입력\n\n\n\n- Enter 입력\n\n\n\n- n 입력하여 다음단어로 이동\n\n\n\n- shift+n 입력하여 이전단어로 이동 (?로 검색할 경우 n와 shift+n의 역할이 뒤바뀜)"
  },
  {
    "objectID": "posts/2000-01-05-(메모) vi 익히기.html#기본익히기",
    "href": "posts/2000-01-05-(메모) vi 익히기.html#기본익히기",
    "title": "(메모) vi 익히기",
    "section": "",
    "text": "예제: vi를 이용하여 파일 만들고 asdf 입력 후 저장 및 종료를 수행하여 보자.\n\n\nstep1step2step3step4step5\n\n\n- 파일생성\nvim test230803.txt \n\n\n\n- 편집모드로 전환: i를 누른다.\n\n아래에 -- INSERT -- 라고 표현되어 있으면 편집모드라는 의미\n\n\n\n\n- asdf 입력\n\n\n\n- 편집모드 종료, 노말모드 진입:esc 입력\n\n아래에 -- INSERT -- 라는 표현이 사라져있음. 이 상황에서 명령어 입력가능.\n\n\n\n\n- 저장(w)+종료(q): : 입력하여 명령모드로 진입. w+ q + Enter 입력\n\n\n\n\n\n\n\n\n예제: vi 에서 좌우로 커서를 이동해보자.\n\n\nstep1step2step3\n\n\n- 생성된 파일로 들어가기\nvim test230803.txt \n\n\n\n- l을 세번눌러서 오른쪽으로 3칸 이동\n\nl이 아니라 실수로 ㅣ를 누르면 동작하지 않음.\n대충 화살표 눌러도 동작함\n\n\n\n\n- h을 세번눌러서 왼쪽으로 3칸 이동\n\nh가 아니라 실수로 ㅗ를 누르면 동작하지 않음.\n대충 화살표 눌러도 동작함\n\n\n\n\n\n\n\n\n\n예제: vi에서 새로운라인을 추가하고 asdf2입력하여 보자.\n\n\nstep1step2step3\n\n\n- 준비작업: 명령모드에서 다음라인을 만들고 싶은 라인에 커서를 위치\n\n\n\n- o를 누른다: 편집모드로 전환 + 새로운 라인이 추가의 효과\n\n\n\n- asdf2입력\n\n\n\n\n\n\n\n\n예제: vi에서 j,k를 이용하여 커서를 이동하여 보자. (풀이는 생략)\n\n\n\n\n\n예제: vi에서 home/end 와 같은 방식으로 커서를 이동해보자\n\n\nstep1step2step3\n\n\n- 준비작업: 명령모드에서 home/end를 사용할 line으로 커서를 이동시킴\n\n\n\n- 라인의 맨 마지막으로 가고싶다면? $를 입력한다.\n\n\n\n- 다시 라인의 맨 처음으로 가고싶다면? 숫자 0을 입력한다.\n\n\n\n\n\n\n\n\n예제: vi에서 하나의 줄을 복사하고 아래로 붙여넣기 해보자.\n\n\nstep1step2step3\n\n\n- 복사하고싶은 라인으로 이동 + yy 입력\n\n\n\n- 아래로 붙여넣을 라인으로 이동\n\n\n\n- p 입력\n\n\n\n\n\n\n\n\n예제: vi에서 w와 b를 이용하여 단어단위로 커서를 이동시켜보자. (풀이생략)\n\n\n\n\n\n예제: vi에서 원하는 단어는 찾아보자.\n\n\nstep1step2step3step4\n\n\n- /asdf2 입력\n\n\n\n- Enter 입력\n\n\n\n- n 입력하여 다음단어로 이동\n\n\n\n- shift+n 입력하여 이전단어로 이동 (?로 검색할 경우 n와 shift+n의 역할이 뒤바뀜)"
  },
  {
    "objectID": "posts/2000-01-05-(메모) vi 익히기.html#모드",
    "href": "posts/2000-01-05-(메모) vi 익히기.html#모드",
    "title": "(메모) vi 익히기",
    "section": "2 모드",
    "text": "2 모드\n\n2.1 esc: normal 모드\n- 기능1: 되돌리기, 되돌리기를 되돌리기\n- 기능2: 커서이동 (기본) – 방향키, 쉬프트+방향키, home/end, pageup/pagedown 으로 대체가능\n\nk,j,h,l: 상,하,좌,우\nw,b: 다음 단어의 시작으로 이동, 이전 단어의 시작으로 이동\n0 (숫자 0), $: 줄의 맨 앞, 맨 끝으로 이동\ncontrol + d, control + u: 반페이지씩 page down, page up\n{, }: 문단 시작, 끝으로 이동\n\n- 기능3: 커서이동 (고급)\n\n%: 현재 괄호의 짝으로 이동\ne: 현재단어의 끝으로 이동\ngg: 파일의 첫 줄로 이동\nG: 파일의 마지막 줄로 이동\n\n- 기능4: 다른모드로 진입하기 위한 중간허브\n\nv,V: 선택모드, 줄단위선택모드로 변환\ni, I, a, A: 커서앞, 줄맨앞, 커서뒤, 줄맨뒤에서 삽입모드로 전환\nr, R: 한글자 수정후 복귀, 수정모드로 진입\n\n- 기능5: 들여쓰기, 내어쓰기\n\n&gt; + Enter, &lt; + Enter: 들여쓰기, 내어쓰기\n\n\n\n2.2 i: 삽입모드\n\n\n2.3 d: 삭제모드\n\n\n2.4 :: 명령모드\n\n\n2.5 /: 검색모드\n\n\n2.6 v: 비주얼모드(선택모드)\n\n\n2.7 R: 수정모드"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html",
    "title": "(공부) Julia – Vector",
    "section": "",
    "text": "- Python의 리스트와 비슷하기도 하고, numpy array와 비슷하기도 함"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html#느낌",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html#느낌",
    "title": "(공부) Julia – Vector",
    "section": "",
    "text": "- Python의 리스트와 비슷하기도 하고, numpy array와 비슷하기도 함"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html#선언과-자료형",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html#선언과-자료형",
    "title": "(공부) Julia – Vector",
    "section": "2 선언과 자료형",
    "text": "2 선언과 자료형\n- 예시1\n\na = [1,2,3]\na\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\ntypeof(a)\n\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\n- 예시2\n\na = [1,2,'a',\"abc\"] \na\n\n4-element Vector{Any}:\n 1\n 2\n  'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n  \"abc\"\n\n\n\ntypeof(a)\n\n\nVector{Any} (alias for Array{Any, 1})\n\n\n\n- 예시3 – col-vector처럼 선언가능\n\na= [ 1\n     2\n     3 ] \n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n- 예시4 – 비어있는 벡터 선언\n\na = []\n\nAny[]"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html#특수한-벡터-선언",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html#특수한-벡터-선언",
    "title": "(공부) Julia – Vector",
    "section": "3 특수한 벡터 선언",
    "text": "3 특수한 벡터 선언\n- 예시1: ones, zeros\n\nones(3)\n\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\n\n\nzeros(3)\n\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\n\n- 예시2: fill\n\nfill(1.0,3)\n\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\n\n- 예시3\n\nArray(1:3)\n#Array(range(1,3))\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\ncollect(1:3)\n#collect(range(1,3))\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n- 예시4\n\nArray(range(1,10,length=3))\n\n3-element Vector{Float64}:\n  1.0\n  5.5\n 10.0\n\n\n\ncollect(range(1,10,length=3))\n\n3-element Vector{Float64}:\n  1.0\n  5.5\n 10.0"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html#연산",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html#연산",
    "title": "(공부) Julia – Vector",
    "section": "4 연산",
    "text": "4 연산\n\n4.1 더하기\n- 예시1 – 길이가 같은 벡터의 합\n\na = [1,2] \nb = [-1,-2]\na + b\n\n2-element Vector{Int64}:\n 0\n 0\n\n\n\n# 사실아래도 가능\na .+ b\n\n2-element Vector{Int64}:\n 0\n 0\n\n\n- 예시2 – 벡터+스칼라 (실패)\n\na = [1,2]\na + 1 # 브로드캐스팅 실패\n\n\nMethodError: no method matching +(::Vector{Int64}, ::Int64)\nFor element-wise addition, use broadcasting with dot syntax: array .+ scalar\n\nClosest candidates are:\n  +(::Any, ::Any, ::Any, ::Any...)\n   @ Base operators.jl:578\n  +(::T, ::T) where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}\n   @ Base int.jl:87\n  +(::Base.TwicePrecision, ::Number)\n   @ Base twiceprecision.jl:290\n  ...\n\n\n\n\n- 예시3 – 벡터+스칼라 (성공)\n\na = [1,2]\na .+ 1 \n\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n4.2 곱셉\n- 예시1 – 벡터*스칼라 (성공)\n\na = [1,2]\na*2\n\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n# 사실 아래도 가능\na .* 2\n\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n# 사실 아래도 가능\n2a\n\n2-element Vector{Int64}:\n 2\n 4\n\n\n- 예시2 – 하다마르곱\n\na = [1,2]\nb = [2,3] \na .* b \n\n2-element Vector{Int64}:\n 2\n 6\n\n\n- 예시3 – 예시2를 응용\n\na = [1,'a']\nb = [3,'b']\na .* b\n\n2-element Vector{Any}:\n 3\n  \"ab\"\n\n\n\n\n4.3 제곱연산\n- 예시1\n\na = [1,2]\na .^ 2\n\n2-element Vector{Int64}:\n 1\n 4\n\n\n- 예시2\n\na = [\"a\", \"bb\"] \na .^ 2 \n\n2-element Vector{String}:\n \"aa\"\n \"bbbb\"\n\n\n\n\n4.4 내적\n- 예시\n\nusing LinearAlgebra\n\n\n[1,2,3] ⋅ [1,2,3]\n\n14\n\n\n\ndot([1,2,3],[1,2,3])\n\n14\n\n\n\n[1,2,3]' * [1,2,3]\n\n14"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html#차원-길이-차원변경",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html#차원-길이-차원변경",
    "title": "(공부) Julia – Vector",
    "section": "5 차원, 길이, 차원변경",
    "text": "5 차원, 길이, 차원변경\n- 예시1\n\na = 1:4\na\n\n1:4\n\n\n\nndims(a)\n\n1\n\n\n\nlength(a)\n\n4\n\n\n- 예시2\n\na = 1:4\n\n1:4\n\n\n\na = reshape(a,(2,2))\na\n\n2×2 reshape(::UnitRange{Int64}, 2, 2) with eltype Int64:\n 1  3\n 2  4\n\n\n\nndims(a)\n\n2\n\n\n\nlength(a)\n\n4"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html#조건에-맞는-원소-출력",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html#조건에-맞는-원소-출력",
    "title": "(공부) Julia – Vector",
    "section": "6 조건에 맞는 원소 출력",
    "text": "6 조건에 맞는 원소 출력\n- 예시1\n\na = collect(10:5:30)\na\n\n5-element Vector{Int64}:\n 10\n 15\n 20\n 25\n 30\n\n\n\na[a .&lt; 20]\n\n2-element Vector{Int64}:\n 10\n 15\n\n\n\n@. a[a &lt; 20] # 이게 편할지도\n\n2-element Vector{Int64}:\n 10\n 15\n\n\n- 예시2\n\na = [1,2,3,4,5]\nb = [5,4,3,2,1] \n@. a[a &lt; b]\n\n2-element Vector{Int64}:\n 1\n 2"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html#원소의-추가",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html#원소의-추가",
    "title": "(공부) Julia – Vector",
    "section": "7 원소의 추가",
    "text": "7 원소의 추가\n\n7.1 append!\n- 예시\n\na = [1,2,3]\nb = [4] \nappend!(a,b)\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\na,b\n\n([1, 2, 3, 4], [4])\n\n\n\nappend!는 numpy에서 concat 느낌\n\n\n\n7.2 push!\n- 예시\n\na = [1,2,3]\npush!(a,4)\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\npush!는 list에서 append 느낌"
  },
  {
    "objectID": "posts/2023-10-26-(공부) Julia -- Vector.html#결합",
    "href": "posts/2023-10-26-(공부) Julia -- Vector.html#결합",
    "title": "(공부) Julia – Vector",
    "section": "8 결합",
    "text": "8 결합\n\n8.1 cat\n\nnp.concat, np.stack 등이 합쳐진 형태\n\n- 예시1\n\na = [1,2,3]\nb = [4] \n\n1-element Vector{Int64}:\n 4\n\n\n\ncat(a,b,dims=1) # np.concat 과 비슷\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n- 예시2\n\na = [1,2,3]\nb = -a\n\n3-element Vector{Int64}:\n -1\n -2\n -3\n\n\n\ncat(a,b,dims=2) \n\n3×2 Matrix{Int64}:\n 1  -1\n 2  -2\n 3  -3\n\n\n\ncat(a,b,dims=1)\n\n6-element Vector{Int64}:\n  1\n  2\n  3\n -1\n -2\n -3\n\n\n- 예시3\n\na = [1 2 3\n     3 4 5]\nb = -a\n\n2×3 Matrix{Int64}:\n -1  -2  -3\n -3  -4  -5\n\n\n\ncat(a,b,dims=1)\n\n4×3 Matrix{Int64}:\n  1   2   3\n  3   4   5\n -1  -2  -3\n -3  -4  -5\n\n\n\ncat(a,b,dims=2)\n\n2×6 Matrix{Int64}:\n 1  2  3  -1  -2  -3\n 3  4  5  -3  -4  -5\n\n\n\ncat(a,b,dims=3)\n\n2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  2  3\n 3  4  5\n\n[:, :, 2] =\n -1  -2  -3\n -3  -4  -5\n\n\n- 예시4 – 아래도 가능\n\na = [1,2,3]\nb = 2 \ncat(a,b,dims=1)\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 2\n\n\n- 예시5 – 아래도 가능\n\na = reshape(1:4, (2,2))\nb = [3,4]\na,b\n\n([1 3; 2 4], [3, 4])\n\n\n\ncat(a,b,dims=2)\n\n2×3 Matrix{Int64}:\n 1  3  3\n 2  4  4\n\n\n\n\n8.2 []를 이용한 결합\n- 예시1\n\na = [1,2,3]\nb = -a\na,b\n\n([1, 2, 3], [-1, -2, -3])\n\n\n\n[a b]\n\n3×2 Matrix{Int64}:\n 1  -1\n 2  -2\n 3  -3\n\n\n\n[a\n b]\n\n6-element Vector{Int64}:\n  1\n  2\n  3\n -1\n -2\n -3\n\n\n- 예시2\n\na = [1,2,3] \nb = 4\n\n4\n\n\n\n[a \n b]\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n- 예시3\n\na = [1 2; 3 4]\nb = [0,0] \n\n2-element Vector{Int64}:\n 0\n 0\n\n\n\n[a b]\n\n2×3 Matrix{Int64}:\n 1  2  0\n 3  4  0"
  },
  {
    "objectID": "posts/2024-01-16-(메모) R package 만들기.html",
    "href": "posts/2024-01-16-(메모) R package 만들기.html",
    "title": "(메모) R package 만들기",
    "section": "",
    "text": "- devtools 설치\nconda install conda-forge::r-devtools"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "",
    "text": "- 우분투에서 여러가지 개발환경을 설정하는 방법을 포스팅 (시대가 너무 바뀌어서 새로정리)"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#about-this-doc",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#about-this-doc",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "",
    "text": "- 우분투에서 여러가지 개발환경을 설정하는 방법을 포스팅 (시대가 너무 바뀌어서 새로정리)"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#우분투설치",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#우분투설치",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "2 우분투설치",
    "text": "2 우분투설치\n- Nomal installation \\(\\to\\) Erase disk and install Ubuntu, Continue\n\nstep1step2step3"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#네트워크-설정",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#네트워크-설정",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "3 네트워크 설정",
    "text": "3 네트워크 설정\n- ?표시있는 아이콘 \\(\\to\\) Wired Connected \\(\\to\\) Wired Settings \\(\\to\\) Connection의 설정 \\(\\to\\) IPv4 \\(\\to\\) Manual \\(\\to\\) Address, Netmask, Gateway, DNS 설정 \\(\\to\\) 네트워크 토글"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#그래픽카드-드라이버설치",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#그래픽카드-드라이버설치",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "4 그래픽카드 드라이버설치",
    "text": "4 그래픽카드 드라이버설치\n- 전체적인 내용은 여기를 참고하자.\n- 준비작업\nsudo apt update \nsudo apt install gcc\nsudo apt install build-essential\n- 우선 gedit를 열고 아래를 복사해서 붙여넣는다.\nblacklist nouveau\noptions nouveau modeset=0\n파일이름을 blacklist-nouveau.conf로 home에 저장\n- 루트권한획득\nsudo -i\n아이디와 비밀번호를 입력하고 루트권한을 얻는다.\n- 아래를 입력한다.\nsudo cp /home/cgb2/blacklist-nouveau.conf /etc/modprobe.d\nsudo update-initramfs -u\nsudo reboot \n- 그래픽카드 다운로드: 드라이버 설치파일을 다운받는다. 앤비디아공식홈페이지에서 다운받자. OS를 리눅스 64-bit으로 선택하고 검색을 누르면 다운받아진다.\n- 그래픽키다 설치: 다운받은뒤에는 파일이 있는 폴더로 이동하여\nchmod +x NVIDIA-Linux-x86_64-410.78.run\n를 실행하자. 보통 NVI까지치고 적당히 탭을 누르면 알아서 뒷부분이 완성된다. 이 과정은 추후에 드라이버를 실행할수 있도록 권한을 풀어두는 것이다. 그리고 아래를 실행한다.\nsudo ./NVIDIA-Linux-x86_64-410.78.run\n그 다음 드라이버가 잘 설치되었는지 확인한다.\nnvidia-smi"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#ssh연결",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#ssh연결",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "5 ssh연결",
    "text": "5 ssh연결\n- 처음에 ssh를 연결하기위해서는 연결당하는 컴퓨터에 가서 아래를 실행해야 한다.\nsudo apt install openssh-server\n22번포트 우회하기\n- step1: /etc/ssh/sshd_config 파일을 연다.\nsudo vi /etc/ssh/sshd_config \n- step2: Port 22 라고 된 부분의 주석을 풀고 원하는 포트번호 설정\n...\n\n#Port 22\n#AddressFamily any\n#ListenAddress 0.0.0.0\n#ListenAddress ::\n\n...\n- step3: 수정내용을 적용\nsudo systemctl restart ssh.service\n- step4: 수정한 포트로 ssh접속"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#아나콘다",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#아나콘다",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "6 아나콘다",
    "text": "6 아나콘다\n- 다운로드: https://www.anaconda.com/download\n- (아나콘다 설치) 아나콘다를 다운받은 폴더로 가서 아래와 같이 실행한다.\nbash Anaconda3-2019.03-Linux-x86_64.sh\n대충 bash Ana 정도까지만 치고 tab을 누르면 알아서 완성된다."
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#원격제어",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#원격제어",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "7 원격제어",
    "text": "7 원격제어\n\n7.1 주피터 원격제어 설정\n- 설정파일 생성\njupyter notebook --generate-config\n- 패스워드 설정\njupyter notebook password\n## 패스워드 치고\n## 확인해야함\n- 설정파일을 열고\nvi /home/cgb2/.jupyter/jupyter_notebook_config.py\n아래의 내용을 수정한다.\nc.??????App.ip = '192.168.0.4'\nc.??????App.port = 1306\nc.??????App.allow_origin = '*'\nc.??????App.allow_remote_access = True\nc.??????App.allow_root = True\n\n\n7.2 vscode\n- ref: https://code.visualstudio.com/docs/remote/tunnels\n- 아래를 실행하면 된다.\ncurl -Lk 'https://code.visualstudio.com/sha/download?build=stable&os=cli-alpine-x64' --output vscode_cli.tar.gz\ntar -xf vscode_cli.tar.gz\n- 이후로는 ./code tunnel을 실행할것!\n- 백엔드에서 하려면\nnohup ./code tunnel &gt; /dev/null 2&gt;&1 &\n- 패키지설치"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#rstudio",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#rstudio",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "8 Rstudio",
    "text": "8 Rstudio\n- 가상환경만듦\n(base) conda create -n r \n(base) conda activate r \n(r) conda install -c conda-forge r-essentials\n- 아래를 이용하여 Rstudio를 설치 (base환경인지 r환경인지는 무의미)\nsudo apt remove rstudio-server # 이미 설치된 경우 이 명령을 통하여 삭제하고 설치할 것 \nsudo apt-get install gdebi-core\nwget https://download2.rstudio.org/server/jammy/amd64/rstudio-server-2024.04.2-764-amd64.deb # 우분투 22는 jammy!!!\nsudo gdebi rstudio-server-2024.04.2-764-amd64.deb\n- grst가 만든 rstudio-server-conda를 클론\ngit clone https://github.com/grst/rstudio-server-conda.git\n- 내용을 수정\n\n\n~/rstudio-server-conda/local/start_rstudio_server.sh\n\n\n아래쪽으로 쭉 가면...\n\n/usr/lib/rstudio-server/bin/rserver --server-daemonize=0 \\\n  --www-port=????? \\ ### &lt;--- 여기 수정!!!!!\n  --secure-cookie-key-file=$COOKIE_KEY_PATH \\\n  --server-pid-file=\"$CWD/rstudio-server.pid\" \\\n  --server-data-dir=\"$CWD/rstudio-server\" \\\n  --rsession-which-r=$(which R) \\\n  --rsession-ld-library-path=$CONDA_PREFIX/lib \\\n  --rsession-path=\"$CWD/rsession.sh\" \\\n  --server-user $USER \\\n  --database-config-file \"$CWD/database.conf\" \\\n  $REVOCATION_LIST_PAR\n\n- start_rstudio_server.sh를 실행"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#유용한-콘다-개발환경",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#유용한-콘다-개발환경",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "9 유용한 콘다 개발환경",
    "text": "9 유용한 콘다 개발환경\n\n9.1 R+Python 사용가능한 개발환경\n- 아래를 실행\n(base) conda create -n r \n(base) conda activate r\n(r) conda install -c conda-forge r-essentials\n(r) conda install -c conda-forge plotly\n(r) conda install -c conda-forge rpy2\n\nimport rpy2\n\n- 여기에서 conda install -c conda-forge r-essentials로 인하여 R, Python, Jupyter 가 모두 최신버전으로 설치된다.\n- 또한 R에는 이미 tidyverse, IRkernel 등의 패키지가 기본으로 깔려있다.\n- 커널연결\n콘다환경에서 R을 실행한다. Rstudio가 아니라 커맨드에서 R을 실행해야한다. 그리고 아래를 실행하면 주피터랩과 R환경이 연결된다.\nIRkernel::installspec()\n이제 주피터랩에서 R kernel을 사용할 수 있다.\n- R은 아래의 경로에 설치되어있다.\n\n- 실행파일은 bin 폴더에 있다.\n\n(base) 환경이지만 이곳의 실행파일에 직접 접근하여 실행할 수도 있다.\n\n- 설치한 패키지는 library 폴더에 있다. /// EPT도 보인다..\n\n\n\n9.2 torch\n- 아래를 실행\n(base) conda create -n torch\n(base) conda activate torch\n#---#\n(torch) conda install -c conda-forge notebook \n(torch) conda install -c conda-forge plotly \n#---torch--#\n(torch) conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n#---pyg---#\n#(torch) conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n(torch) conda install pyg -c pyg \n#---stgcn---#\n#(torch) conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n#(torch) conda install pyg -c pyg \n(torch) sudo apt install gcc\n(torch) sudo apt install build-essential\n(torch) pip install torch-geometric-temporal\n#---ctgan---#\n#(torch) conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n(torch) conda install -c pytorch -c conda-forge ctgan  \n#---gym---#\n#(torch) conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n(torch) pip install gymnasium \n#(torch) sudo apt install gcc\n#(torch) sudo apt install build-essential\n(torch) sudo apt-get install swig\n(torch) pip install gymnasium[box2d]\nrefs\n\nPyTorch: https://pytorch.org/get-started/locally/\nPyG: https://pytorch-geometric.readthedocs.io/en/latest/install/installation.html\nPyTorch Geometric Temporal1: https://pytorch-geometric-temporal.readthedocs.io/en/latest/notes/installation.html\nCTGAN: https://github.com/sdv-dev/CTGAN\nGymnasium: https://gymnasium.farama.org/index.html2"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#설치하면-좋은것들",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#설치하면-좋은것들",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "10 설치하면 좋은것들",
    "text": "10 설치하면 좋은것들\n- 데이터과학을 위한 패키지들\npip install plotnine\npip install seaborn\npip install opencv-python\npip install folium\npip install pandas_datareader\n- 아래를 설치하면 좋음\nsudo apt install mc"
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#appendix",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#appendix",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "11 Appendix",
    "text": "11 Appendix\n\n11.1 R 삭제하는 방법\n- R 삭제\nconda remove r-base -y \nsudo apt-get remove r-base-core \nsudo apt purge r-base* r-recommended r-cran-*\nsudo apt autoremove\n\n\n11.2 R 패키지 설치\n- 주피터등에서 직접설치\n- conda를 이용한 설치\nconda install -c r package-name\n\nhttps://docs.anaconda.com/free/anaconda/reference/packages/r-language-pkg-docs/\n\n\n\n11.3 우분투를 주컴퓨터로 사용할 경우 한글설정\n- 아래와 같이 커맨드에 친다.\nibus-setup\n이걸 치면 IBus Preferences 라는 창이 나오는데 여기에서 (1) Input Method 탭 클릭 (2) Add 버튼 클릭 (3) Korean 선택 (4) Hangul 선택을 한다.\n- 위의 단계에서 Korean이 안보이면 Language Support로 가서 한국어팩을 설치하고 리부팅 하면 된다. (보통 실행하자마자 알아서 설치되더라.. 설치가 안되면 Install / Remove Languages... 이라는 탭을 클릭해서 설치하자) 리부팅을 꼭 해야한다는 것에 주의하자.\n- 이제 Region & Language로 가서 설정하면 된다.\n\n\n11.4 sublime text and TeX\n- ‘Ubuntu Software’에 가서 ’sublime Text’를 치면 다운받을 수 있다. 다운받은뒤에 ’file’ -&gt; ’open folder’를 활용하여 깃허브의 로칼저장소를 열어두면 편리하다.\n- 아래를 실행하여 TeX을 깐다.\nsudo apt install texlive-full\n- 이제 sublime과 latex을 연결하여보자. 여기를 참고하자. (1) sublime을 키고 ‘컨트롤+쉬프트+p’를 눌러 ’Install Package Control’ 선택 (2) 다시 ‘컨트롤+쉬프트+p’ 를 눌러 ‘Package Control: Install Package’를 실행 (3) 그러면 바로 검색창이 나오는데 거기서 ’LaTeXTools’를 입력해서 실행 (4) 다시 ’컨트롤+쉬프트+p’를 누르고 ’LaTeXTools: Check system’ 선택. 모두 ’available’이 나오면 잘 설치된 것이다.\n- *.tex파일을 열고 ’컨트롤+b’를 누르자. 처음이면 어떤 메뉴들이 보일텐데 그냥 ’Latex’을 선택하자. 그러면 코딩결과가 pdf로 나온다.\n- (수식미리보기) ‘Perferences’ &gt; ‘Packages Setting’ &gt; ‘LaTeXTools’ &gt; ‘Settings-User’를 선택한다. ’93번째라인’에 ’preview_math_mode’를 “all”로 바꾼다. 그러면 수식들이 미리 출력된다. 그외에도 자유롭게 셋팅을 조정할 수 있다. 원래셋팅은 ’Perferences’ &gt; ‘Packages Setting’ &gt; ‘LaTeXTools’ &gt; ‘Settings-Defaults’ 에 있다.\n\n\n11.5 터미널 예쁘게 만들기\n- zsh 설치 + oh my zsh 설치\nsudo install zsh \nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n- 테마변경\n\n.zshrc 파일 열기\n\nnano ~/.zshrc \n\n아래의 내용 수정\n\n...\nZSH_THEME=\"agnoster\"\n...\n- 색상변경\n\n아래의 파일 열기\n\ncd ~/.oh-my-zsh/themes/\nnano agnoster.zsh-theme  \n\n내용수정\n\n...\nprompt_dir() {\n  prompt_segment 39d $CURRENT_FG '%~'\n}\n..."
  },
  {
    "objectID": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#footnotes",
    "href": "posts/2000-01-02-(메모) 우분투 포맷 및 개발용 서버 셋팅2.html#footnotes",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n이 패키지는 꼭 PyG 이후에 설치할것↩︎\n설치방법은 따로 없음..↩︎"
  },
  {
    "objectID": "posts/2025-01-03-(업무) qrcode.html",
    "href": "posts/2025-01-03-(업무) qrcode.html",
    "title": "(업무) qrcode – 학교이메일접근하기",
    "section": "",
    "text": "import cv2\nimport pyzbar.pyzbar as pyzbar\n\n# QR 코드 이미지 로드\nimg = cv2.imread('qrcode.png')\n\n# QR 코드 인식\ndecoded_objects = pyzbar.decode(img)\nfor obj in decoded_objects:\n    print(\"QR 코드 데이터:\", obj.data.decode(\"utf-8\"))\n\nQR 코드 데이터: otpauth://totp/guebin%40jbnu.ac.kr?secret=YPNHCXYNSJS7F6SJ&issuer=jbnu.ac.kr\nimport pyotp\n\n# Google Authenticator에 등록된 시크릿 키 (QR 코드에서 추출한 Base32 인코딩)\n# QR 코드에 포함된 시크릿 키를 사용해야 합니다.\nsecret_key = \"YPNHCXYNSJS7F6SJ\"  # 실제 Google Authenticator 시크릿 키 사용\ntotp = pyotp.TOTP(secret_key)\n\n# 현재 OTP 코드 생성\ncurrent_otp = totp.now()\nprint(f\"현재 Google Authenticator OTP 코드: {current_otp}\")\n\n현재 Google Authenticator OTP 코드: 390384"
  },
  {
    "objectID": "posts/2025-01-03-(업무) qrcode.html#imap",
    "href": "posts/2025-01-03-(업무) qrcode.html#imap",
    "title": "(업무) qrcode – 학교이메일접근하기",
    "section": "1 IMAP",
    "text": "1 IMAP\n\nimport imaplib\nimport pyotp\n\n# Google Authenticator 시크릿 키 (Base32 인코딩)\nsecret_key = \"YPNHCXYNSJS7F6SJ\"\ntotp = pyotp.TOTP(secret_key)\n\n# OTP 생성\ncurrent_otp = totp.now()\nprint(f\"현재 OTP 코드: {current_otp}\")\n\n# 사용자 계정 정보\nusername = \"guebin@jbnu.ac.kr\"\npassword = \"tlsrbdus12!@\"\n\n# 최종 비밀번호 = 비밀번호 + OTP (예제)\ncombined_password = f\"{password}{current_otp}\"\n\n# IMAP 서버 연결 및 로그인 시도\nimap_server = imaplib.IMAP4_SSL('imap.jbnu.ac.kr')\ntry:\n    imap_server.login(username, combined_password)\n    print(\"로그인 성공!\")\n    imap_server.select(\"INBOX\")\n    status, messages = imap_server.search(None, \"ALL\")\n    print(f\"총 메일 수: {len(messages[0].split())}\")\n    imap_server.logout()\nexcept imaplib.IMAP4.error:\n    print(\"로그인 실패! 비밀번호 또는 OTP가 올바르지 않습니다.\")\n\n현재 OTP 코드: 390384\n로그인 실패! 비밀번호 또는 OTP가 올바르지 않습니다."
  },
  {
    "objectID": "posts/2025-01-03-(업무) qrcode.html#smtp",
    "href": "posts/2025-01-03-(업무) qrcode.html#smtp",
    "title": "(업무) qrcode – 학교이메일접근하기",
    "section": "2 SMTP",
    "text": "2 SMTP\n\nimport smtplib\nfrom email.mime.text import MIMEText\nimport pyotp\n\n# Google Authenticator 시크릿 키 (Base32)\nsecret_key = \"YPNHCXYNSJS7F6SJ\"\ntotp = pyotp.TOTP(secret_key)\n\n# OTP 생성\ncurrent_otp = totp.now()\nprint(f\"현재 OTP 코드: {current_otp}\")\n\n# 사용자 계정 정보\nusername = \"guebin@jbnu.ac.kr\"\npassword = \"tlsrbdus12!@\"\n\n# 비밀번호 + OTP 조합\ncombined_password = f\"{password}{current_otp}\"\n\n# SMTP 서버 연결\nsmtp_server = smtplib.SMTP('smtp.jbnu.ac.kr', 587)\nsmtp_server.starttls()\n\ntry:\n    smtp_server.login(username, combined_password)\n    msg = MIMEText(\"Google Authenticator 기반 SMTP 테스트 메일입니다.\")\n    msg[\"Subject\"] = \"Google Authenticator Test\"\n    msg[\"From\"] = username\n    msg[\"To\"] = \"gbchoi0814@gmail.com\"\n    \n    smtp_server.sendmail(username, \"gbchoi0814@gmail.com\", msg.as_string())\n    print(\"메일 발송 성공!\")\n    smtp_server.quit()\nexcept smtplib.SMTPAuthenticationError:\n    print(\"로그인 실패! 비밀번호 또는 OTP가 올바르지 않습니다.\")\n\n현재 OTP 코드: 390384\n\n\nKeyboardInterrupt:"
  },
  {
    "objectID": "posts/2025-01-03-(업무) qrcode.html#selenium",
    "href": "posts/2025-01-03-(업무) qrcode.html#selenium",
    "title": "(업무) qrcode – 학교이메일접근하기",
    "section": "3 Selenium",
    "text": "3 Selenium\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport pyotp\nimport time\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n# Google Authenticator 시크릿 키\nsecret_key = \"YPNHCXYNSJS7F6SJ\"\ntotp = pyotp.TOTP(secret_key)\n\n# Chrome 옵션 설정\noptions = Options()\noptions.add_argument(\"--headless\")  \noptions.add_argument(\"--no-sandbox\")\noptions.add_argument(\"--disable-dev-shm-usage\")\n\n# WebDriver Manager를 통한 ChromeDriver 자동 설치\nservice = Service(ChromeDriverManager().install())\ndriver = webdriver.Chrome(service=service, options=options)\n\n# JBNU 메일 로그인 페이지로 이동\ndriver.get('https://mail.jbnu.ac.kr')\n\n# 명시적 대기 설정\nwait = WebDriverWait(driver, 10)\n\n# 사용자 이름 및 비밀번호 입력\nwait.until(EC.presence_of_element_located((By.ID, \"cid\"))).send_keys(\"guebin@jbnu.ac.kr\")\nwait.until(EC.presence_of_element_located((By.ID, \"cpw\"))).send_keys(\"tlsrbdus12!@\")\n\n# 로그인 버튼 클릭\ndriver.find_element(By.ID, \"btnlogin\").click()\n\n# 2단계 인증 코드 대기 및 입력\ntry:\n    wait.until(EC.presence_of_element_located((By.ID, \"otp_code1\")))\n    current_otp = totp.now()\n    print(f\"현재 OTP 코드: {current_otp}\")\n    \n    for idx, digit in enumerate(current_otp):\n        driver.find_element(By.ID, f\"otp_code{idx + 1}\").send_keys(digit)\n\n    driver.find_element(By.ID, \"loginBtn\").click()\n    print(\"OTP 입력 완료!\")\nexcept Exception as e:\n    print(\"OTP 필드가 감지되지 않았습니다. 아마도 2단계 인증이 비활성화된 것으로 보입니다.\")\n\n# 로그인 성공 여부 확인\ntime.sleep(5)\nif \"로그아웃\" in driver.page_source:\n    print(\"로그인 성공!\")\n\n    # 받은 편지함으로 이동\n    driver.get('https://mail.jbnu.ac.kr/webmail/lists?t=1735910040')  # 실제 받은 편지함 URL 확인 필요\n    wait.until(EC.presence_of_element_located((By.CLASS_NAME, \"mail_subject\")))\n\n    # 메일 제목 가져오기 (최대 5개)\n    mail_titles = driver.find_elements(By.CLASS_NAME, \"mail_subject\")[:5]  \n\n    print(\"\\n--- 최근 5개의 메일 제목 ---\")\n    for idx, title in enumerate(mail_titles):\n        print(f\"{idx + 1}. {title.text}\")\n\nelse:\n    print(\"로그인 실패!\")\n\n# 드라이버 종료\ndriver.quit()\n\n현재 OTP 코드: 500622\nOTP 입력 완료!\n로그인 성공!\n\n--- 최근 5개의 메일 제목 ---\n1. Recommendation Confirmation: Suin Kang\n2. The Graduate School - University of Washington : RecommendationSubmitted\n3. 2024학년도 글로컬30 연구역량강화 지원사업 신청기한 및 조기 신청 안내\n4. RE: [RE]인포커스) 자연과학대학 학과 홍보영상 제작 관련 미팅 일정 안내사항\n5. RE: [RE]추천서 작성 요청드립니다\n\n\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport pyotp\nimport time\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n# Google Authenticator 시크릿 키\nsecret_key = \"YPNHCXYNSJS7F6SJ\"\ntotp = pyotp.TOTP(secret_key)\n\n# Chrome 옵션 설정\noptions = Options()\noptions.add_argument(\"--headless\")  \noptions.add_argument(\"--no-sandbox\")\noptions.add_argument(\"--disable-dev-shm-usage\")\n\n# WebDriver Manager를 통한 ChromeDriver 자동 설치\nservice = Service(ChromeDriverManager().install())\ndriver = webdriver.Chrome(service=service, options=options)\n\n# JBNU 메일 로그인 페이지로 이동\ndriver.get('https://mail.jbnu.ac.kr')\n\n# 명시적 대기 설정\nwait = WebDriverWait(driver, 10)\n\n# 사용자 이름 및 비밀번호 입력\nwait.until(EC.presence_of_element_located((By.ID, \"cid\"))).send_keys(\"guebin@jbnu.ac.kr\")\nwait.until(EC.presence_of_element_located((By.ID, \"cpw\"))).send_keys(\"tlsrbdus12!@\")\n\n# 로그인 버튼 클릭\ndriver.find_element(By.ID, \"btnlogin\").click()\n\n# 2단계 인증 코드 대기 및 입력\ntry:\n    wait.until(EC.presence_of_element_located((By.ID, \"otp_code1\")))\n    current_otp = totp.now()\n    print(f\"현재 OTP 코드: {current_otp}\")\n    \n    for idx, digit in enumerate(current_otp):\n        driver.find_element(By.ID, f\"otp_code{idx + 1}\").send_keys(digit)\n\n    driver.find_element(By.ID, \"loginBtn\").click()\n    print(\"OTP 입력 완료!\")\nexcept Exception as e:\n    print(\"OTP 필드가 감지되지 않았습니다. 아마도 2단계 인증이 비활성화된 것으로 보입니다.\")\n\n\n# 로그인 성공 여부 확인\ntime.sleep(5)\nif \"로그아웃\" in driver.page_source:\n    print(\"로그인 성공!\")\n\n    # 읽지 않은 메일함으로 이동\n    driver.get('https://zm931.mailplug.com/webmail/lists#%7B%22s_fnum%22%3A%22all_mail%22%2C%22view%22%3A%22%22%2C%22list%22%3Atrue%2C%22type%22%3A%22%22%2C%22t%22%3A1735914218822%2C%22serchWord%22%3A%22%22%2C%22searchKind%22%3A%22all%22%2C%22sch_in_word%22%3A%22%22%2C%22ymd%22%3A%22%22%2C%22page%22%3A%22%22%2C%22sod%22%3A%22%22%2C%22sst%22%3A%22%22%2C%22mailrefresh%22%3A%22%22%2C%22mdl%22%3A%22lists%22%2C%22s_mread%22%3A%22N%22%7D')  # 실제 받은 편지함 URL 확인 필요\n    wait.until(EC.presence_of_element_located((By.CLASS_NAME, \"mail_subject\")))\n    print(\"받음편지함\")\n\n    # 안 읽은 메일 제목을 가져오기 (맨 아래 메일)\n    mail_titles = driver.find_elements(By.CLASS_NAME, \"mail_subject\")\n    if mail_titles:\n        print(f\"맨 아래 메일 제목: {mail_titles[-1].text}\")\n        # 가장 마지막 메일 클릭\n        mail_titles[-1].click()\n    else:\n        print(\"안 읽은 메일이 없습니다.\")\n    # 메일 전달 버튼 클릭\n    wait = WebDriverWait(driver, 10) \n    wait.until(EC.element_to_be_clickable((By.XPATH, \"//button[text()='전달']\"))).click()\n    \n    # 수신자 이메일 주소 입력 (여기서는 'gbchoi0814@gmail.com'으로 설정)\n    wait.until(EC.presence_of_element_located((By.ID, \"to\"))).send_keys(\"gbchoi0814@gmail.com\")\n    \n    # 전달 버튼 클릭\n    wait.until(EC.presence_of_element_located((By.ID, \"sendBtn\"))).click()\n    print(\"메일이 성공적으로 전달되었습니다!\")\nelse:\n    print(\"로그인 실패!\")\n\n현재 OTP 코드: 418195\nOTP 입력 완료!\n로그인 성공!\n받음편지함\n맨 아래 메일 제목: asdfasdf\n\n\nTimeoutException: Message: \nStacktrace:\n#0 0x60cce582c8fa &lt;unknown&gt;\n#1 0x60cce533dd20 &lt;unknown&gt;\n#2 0x60cce538ca66 &lt;unknown&gt;\n#3 0x60cce538cd01 &lt;unknown&gt;\n#4 0x60cce53d2184 &lt;unknown&gt;\n#5 0x60cce53b0b1d &lt;unknown&gt;\n#6 0x60cce53cf560 &lt;unknown&gt;\n#7 0x60cce53b0893 &lt;unknown&gt;\n#8 0x60cce537f30d &lt;unknown&gt;\n#9 0x60cce538032e &lt;unknown&gt;\n#10 0x60cce57f900b &lt;unknown&gt;\n#11 0x60cce57fcf97 &lt;unknown&gt;\n#12 0x60cce57e571c &lt;unknown&gt;\n#13 0x60cce57fdb17 &lt;unknown&gt;\n#14 0x60cce57ca6cf &lt;unknown&gt;\n#15 0x60cce581b6b8 &lt;unknown&gt;\n#16 0x60cce581b880 &lt;unknown&gt;\n#17 0x60cce582b776 &lt;unknown&gt;\n#18 0x79d38ee94ac3 &lt;unknown&gt;\n\n\n\nmail_titles[-1].text\n\nStaleElementReferenceException: Message: stale element reference: stale element not found in the current frame\n  (Session info: chrome=131.0.6778.204); For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors#stale-element-reference-exception\nStacktrace:\n#0 0x55a345d438fa &lt;unknown&gt;\n#1 0x55a345854d20 &lt;unknown&gt;\n#2 0x55a34585aae3 &lt;unknown&gt;\n#3 0x55a34585cfa8 &lt;unknown&gt;\n#4 0x55a34585d033 &lt;unknown&gt;\n#5 0x55a34589e232 &lt;unknown&gt;\n#6 0x55a3458c7af2 &lt;unknown&gt;\n#7 0x55a3458980a8 &lt;unknown&gt;\n#8 0x55a3458c7cbe &lt;unknown&gt;\n#9 0x55a3458e6560 &lt;unknown&gt;\n#10 0x55a3458c7893 &lt;unknown&gt;\n#11 0x55a34589630d &lt;unknown&gt;\n#12 0x55a34589732e &lt;unknown&gt;\n#13 0x55a345d1000b &lt;unknown&gt;\n#14 0x55a345d13f97 &lt;unknown&gt;\n#15 0x55a345cfc71c &lt;unknown&gt;\n#16 0x55a345d14b17 &lt;unknown&gt;\n#17 0x55a345ce16cf &lt;unknown&gt;\n#18 0x55a345d326b8 &lt;unknown&gt;\n#19 0x55a345d32880 &lt;unknown&gt;\n#20 0x55a345d42776 &lt;unknown&gt;\n#21 0x751588a94ac3 &lt;unknown&gt;"
  },
  {
    "objectID": "posts/2024-12-31-(업무) 성과입력.html",
    "href": "posts/2024-12-31-(업무) 성과입력.html",
    "title": "(업무) 성과입력",
    "section": "",
    "text": "https://ernd.nrf.re.kr\n\n로그인: tomato0814"
  },
  {
    "objectID": "posts/2024-12-31-(업무) 성과입력.html#접속",
    "href": "posts/2024-12-31-(업무) 성과입력.html#접속",
    "title": "(업무) 성과입력",
    "section": "",
    "text": "https://ernd.nrf.re.kr\n\n로그인: tomato0814"
  },
  {
    "objectID": "posts/2024-12-31-(업무) 성과입력.html#성과-ernd",
    "href": "posts/2024-12-31-(업무) 성과입력.html#성과-ernd",
    "title": "(업무) 성과입력",
    "section": "2 성과 ernd",
    "text": "2 성과 ernd\n\n\n오른쪽 아래 성과\n\n- 오래되어서 아이리스로 가라고함"
  },
  {
    "objectID": "posts/2024-12-31-(업무) 성과입력.html#아이리스",
    "href": "posts/2024-12-31-(업무) 성과입력.html#아이리스",
    "title": "(업무) 성과입력",
    "section": "3 아이리스",
    "text": "3 아이리스\n- 아이리스로 가라고 해서 아이리스로옴 // tomato0814\n- 과제조회.. – 지역우수가 여러개 있느데 이공학술연구기반구축으로.. 찾아야하는듯\n\n- 과제가 연구비지급탭에서는 검색되는데 성과입력에서는 검색되지 않음.. 문의가 필요해보임\n\n\n\n\n\n\nNote\n\n\n\n문의해봤는데, 연구개발과제번호에 번호를 직접입력하고 검색하면 잘 됨.\nRS-2023-?? 의 ?? 에 해당하는 연구과제를 입력하면 된다."
  },
  {
    "objectID": "posts/2000-01-09-(메모) docker.html",
    "href": "posts/2000-01-09-(메모) docker.html",
    "title": "(메모) docker",
    "section": "",
    "text": "- 우분투에서 설치\nref: https://docs.docker.com/engine/install/ubuntu/"
  },
  {
    "objectID": "posts/2000-01-09-(메모) docker.html#기본명령어",
    "href": "posts/2000-01-09-(메모) docker.html#기본명령어",
    "title": "(메모) docker",
    "section": "1 기본명령어",
    "text": "1 기본명령어\n- 기본명령들\n## 이미지 \ndocker images \ndocker image pull penguin \ndocker run {이미지이름}\ndocker image ls {이미지이름} # 특정 이미지의 버전을 명시하여 해당 이미지의 정보를 확인.\ndocker image history {이미지이름} # 특정 이미지의 레이어별 변경 내역을 확인.\n\n## 컨테이너\ndocker ps \ndocker ps -a \ndocker start {컨테이너이름or컨테이너ID}\ndocker stop {컨테이너이름or컨테이너ID}\ndocker rm {컨테이너이름or컨테이너ID} # 컨테이너가 중단된 상태에서 실행해야함\ndocker container inspect {컨테이너이름or컨테이너ID} # 특정 컨테이너의 자세한 정보를 확인.\ndocker logs {컨테이너이름or컨테이너ID} # 컨테이너의 로그를 확인.\ndocker container stats # 실행 중인 컨테이너의 실시간 리소스 사용량을 모니터링."
  },
  {
    "objectID": "posts/2000-01-09-(메모) docker.html#appendix",
    "href": "posts/2000-01-09-(메모) docker.html#appendix",
    "title": "(메모) docker",
    "section": "2 Appendix",
    "text": "2 Appendix\n- 기본적으로는 docker run {옵션들} {이미지이름} {내부명령}와 같은 포맷임\n- docker run -ti --rm r-base\n\n-ti: 이 옵션은 두 개의 플래그인 -t와 -i를 결합. –&gt; 터미널 쓸려면 필수임.\n\n-t (또는 --tty): 이 플래그는 유사 터미널을 할당하고 터미널 상호작용을 가능하게 함. 컨테이너 내부에서 터미널 환경을 사용할 수 있게 해줌.\n-i (또는 --interactive): 이 플래그는 컨테이너와 상호작용할 수 있도록 표준 입력(STDIN)을 열어줌. 컨테이너 내부에서 입력을 주고 받을 수 있게 해줌.\n\n–rm: 이 옵션은 컨테이너가 실행을 마칠 때 자동으로 컨테이너를 삭제.\n\n- docker run -ti --rm -v \"$PWD\":/home/docker -w /home/docker -u docker r-base R CMD check\n\n-ti: 이 옵션은 터미널 상호작용을 위한 옵션\n–rm: 컨테이너가 실행을 마칠 때 자동으로 컨테이너를 삭제.\n-v “$PWD”:/home/docker: 이 옵션은 호스트 시스템의 현재 작업 디렉토리를 컨테이너 내의 /home/docker 디렉토리와 공유 마운트. 이렇게 함으로써 호스트 시스템의 파일을 컨테이너 내부에서 사용할 수 있게 됨.\n-w /home/docker: 컨테이너가 실행될 작업 디렉토리를 /home/docker로 설정. 즉, 컨테이너가 실행될 때 기본 디렉토리가 /home/docker가 된다.\n-u docker: 이 옵션은 컨테이너 안에서 사용자를 변경하여 실행하는 것을 의미. docker라는 사용자로 컨테이너를 실행.\nr-base: Docker 이미지 이름.\nR CMD check: 실제로 실행되는 컨테이너 내부의 명령어. 이 경우 R 패키지를 체크하는 R 명령어 R CMD check가 실행.\n\n- run vs start\n\nrun: 이미지 -&gt; 컨테이너\nstart: 중단된 컨테이너 재시작"
  },
  {
    "objectID": "posts/2022-12-23-(리뷰) Ebayesthresh.html",
    "href": "posts/2022-12-23-(리뷰) Ebayesthresh.html",
    "title": "(리뷰) EbayesThresh: R Programs for Empirical Bayes Thresholding",
    "section": "",
    "text": "ref: https://www.jstatsoft.org/article/view/v012i08"
  },
  {
    "objectID": "posts/2022-12-23-(리뷰) Ebayesthresh.html#introduction",
    "href": "posts/2022-12-23-(리뷰) Ebayesthresh.html#introduction",
    "title": "(리뷰) EbayesThresh: R Programs for Empirical Bayes Thresholding",
    "section": "1 Introduction",
    "text": "1 Introduction\n\n1.1 Ebayesthresh로 무엇을 할 수 있는가?\n아래와 같은 상황을 가정하자.\n\\[X_i = \\mu_i +\\epsilon_i.\\]\n여기에서 아래를 가정한다.\n\n\\(\\epsilon_i \\overset{iid}{\\sim} N(0,1)\\)\neach \\(\\mu_i\\) is zero with probability \\((1−w)\\), while, with probability \\(w\\), \\(\\mu_i\\) is drawn from a symmetric heavy-tailed density \\(\\gamma\\).\n\n일반적으로 \\(w\\), 즉 \\(\\mu_i\\)가 0이 아닐 확률은 매우 작은값으로 설정된다. 따라서 위와 같은 구조로 \\(\\epsilon_i\\)와 \\(\\mu_i\\)를 생성하면 아래와 같이 된다.\n\n\\(\\epsilon_i\\): 절대값이 작은 신호들이 dense하게 있음.\n\\(\\mu_i\\): 절대값이 큰 신호들이 sparse하게 있음. (sparse한 이유는 \\(w\\)가 작으므로)\n\n따라서 \\(X_i\\)의 모양은 아래의 그림의 왼쪽과 같다.\n\n이 논문의 목표는 왼쪽의 그림 \\(X_i= \\mu_i +\\epsilon_i\\)로부터 오른쪽의 그림 \\(\\hat{\\mu}_i\\)을 구하는 것이다. 즉 작은 절대값의 노이즈 \\(\\epsilon_i\\)에서 큰 절대값의 신호 \\(\\mu_i\\)를 골라내는 일을 목표로 한다. 저자들은 이러한 작업을 “건초더미에서 바늘찾기”라는 말로 비유하였다. 이러한 “건초더미에서 바늘찾기”는 여러 분야에 응용될 수 있다. 구체적으로는 천문학, 이미지프로세싱, 데이터마이닝, 모형선택등에 사용될 수 있다고 한다. 언급한 분야에 대한 자세한 discussion은 Johnstone and Silverman (2004)에서 찾을 수 있다. 또한 “건초더미에서 바늘찾기”는 위에서 언급한 분야 이외에 퓨리에, 웨이블릿 혹은 다른 dictionaries에 의한 함수추정문제를 해결할 수 있다. 이는 퓨리에나 웨이블릿변환과 같은 multiscale trasnform이 원래 신호를 sparese한 구조로 바꾸기 때문이다. 즉 퓨리에변환 웨이블릿변환으로 underlying function을 추정할 수 있다는 의미이다. 우리는 이러한 접근법에 좀 더 초점을 맞추도록 하겠다.\n\n\n1.2 간단한 사용법\nR을 이용하여 Ebayesthresh를 사용하는 간단한 방법을 살펴보도록 하자. 논문에 표현된 그림1을 재현하여 보자.\n\nlibrary(EbayesThresh)\n\n\nset.seed(1)\nx &lt;- rnorm(1000) + sample(c( runif(25,-7,7), rep(0,975)))\nplot(x,type='l',lwd=0.2)\n\n\n\n\n\n\n\n\n위와 같은 자료 \\(X_i\\)를 관측하였다고 가정하자. 이 신호에는 “건초(\\(\\epsilon_i\\))”더미에 25개의 “바늘(\\(\\mu_i\\))”이 섞여있다. 여기에서 “바늘”만 골라내는 코드는 아래와 같이 작성할 수 있다.\n\nmuhat &lt;- ebayesthresh(x, sdev=1)\n\n결과를 시각화하면 아래와 같다.\n\nplot(x,type='l',lwd=0.2)\nlines(muhat,col=2,lwd=2)\n\n\n\n\n\n\n\n\n\n\n1.3 arguments\n일반적으로 ebayesthresh 함수를 사용하는 방법은 아래와 같다.\n\nmuhat &lt;- ebayesthresh(\n    x,\n    prior = \"laplace\", \n    a = 0.5, \n    bayesfac = FALSE, \n    sdev = NA, \n    verbose = FALSE, \n    threshrule = \"median\"\n)\n\nprior, a: \\(\\mu_i\\)의 density. 보통 \\(\\frac{1}{2}a \\exp(-a|u|)\\)라고 가정한다. parameter \\(a\\)는 Section 2.1에서 자시해 나옴.\nbayesfac, threshrule: Section 2.2, 2.3에 자세히 나온다.\nsdev: \\(\\epsilon_i\\)의 sd를 의미한다. 이 값을 알고 있다면 설정하면 되지만 보통은 이 값을 모른다고 가정한다. \\(\\epsilon_i\\)의 sd를 모르는 경우는 observed data로 부터 추정하는데 보통 \\({\\tt median}(|X_i|)\\)로 추정한다.\n\\(\\epsilon_i\\)의 sd를 \\({\\tt median}(|X_i|)\\)로 추정하는 motivation을 이해하는 것이 중요하다. 이는 sparse assumption of \\(\\mu_i\\)에서 시작한다. 신호 \\(\\mu_i\\)가 합리적인 수준에서 sparse하다면 median absolute value of \\(X_i\\)는 \\(\\mu_i\\)의 값들과 상관이 없을 것이다. 하지만 당연히 신호가 sparse하지 않다면 이러한 방식으로 sdev를 추정하는 것은 매우 조심스럽게 수행되어야 할 것이다.\n\nn &lt;- 1000\nx &lt;- rnorm(n) + sample(c(runif(25,-7,7), rep(0,n-25)))\nprint(sd(x))\nprint(median(abs(x)))\n\n[1] 1.117016\n[1] 0.6787613\n\n\n\n실제로는 잘 추론하지 못하는 것 같다?\n\n\n\n1.4 원리\n어떻게 \\(\\hat{\\mu}_i\\)를 추정할 수 있을까? 가장 간단한 방법은 thresholding이다.\n많은 실제예제에서 \\(\\mu_i\\)는 어떤 의미에서 (in some sense) sparse하다고 여길 수 있다. EbayesThresh 패키지는 이처럼 \\(\\mu_i\\)가 sparse하다는 구조 (혹은 가정)을 이용하여 \\(\\mu_i\\)를 적절하게 추정한다.\nSparsity를 이용하는 자연스러운 방법은 threshoding이다: 여기에서 threshold의 값 \\(t\\)를 너무 크게 잡으면 신호를 잡음으로 잘못 판단할 것이고 \\(t\\)의 값이 너무 작다면 잡음을 신호로 잘못 판단할 수 있다. 따라서 \\(t\\)의 선택은 이 양쪽 기준사이의 tradeoff가 있는데 EbayesThresh는 이러한 tradeoff를 자동으로 조정하는 효과가 있다.\n\n\\(\\mu_i\\)는 \\(w\\)의 확률로 0 이며 \\((1-w)\\)의 확률로 0이 아니다. \\(\\mu_i\\)가 0이 아닐경우에는 symmetric heavy-tailed density \\(\\gamma\\)에서 추출된다고 가정한다. 여기에서 prior에 대한 key parameter인 \\(w\\)는 데이터로부터 자동으로 추정된다. (marginal maximum likelihood 를 이용한다) 그리고 추정된 \\(w\\)는 Bayesian model로 다시 대입된다.\n\\(w\\)가 추정되면 Bayesian model은 thresholding procedure를 수행할 수 있다. 왜냐하면 \\(w\\)를 추정하면 \\(t(w)\\)를 선택한다는 말과 같은말이기 때문이다.\n\nargument"
  },
  {
    "objectID": "posts/2022-12-23-(리뷰) Ebayesthresh.html#description-of-the-method",
    "href": "posts/2022-12-23-(리뷰) Ebayesthresh.html#description-of-the-method",
    "title": "(리뷰) EbayesThresh: R Programs for Empirical Bayes Thresholding",
    "section": "2 Description of the method",
    "text": "2 Description of the method\n\n2.1 The Bayesian model\n\\[X_i \\sim N(\\mu_i,1)\\]\n\\(f_{\\text{prior}}(\\mu)=(1-w)\\delta_0(\\mu)+w \\gamma_a(\\mu), \\quad \\gamma_a(\\mu)=\\frac{1}{2}a\\exp(-a|\\mu|)\\)\n여기에서 \\(\\gamma_a(\\mu)\\)는 하나의 예시일 뿐이다. Ebayesthresh에 디폴트로 설정된 prior=\"laplace\"를 셋팅하면 \\(\\gamma_a(\\mu)\\)가 사용된다. \\(\\gamma\\)의 선택은 tail이 polynomial rates로 줄어드는 어떠한 분포를 사용해도 무방하다. 저자들은 quasi-Cauchy분포를 제안하였는데 이는 Johnstone and Sliverman이 만든 theoretical assumption을 만족하는 분포중 가장 꼬리가 두꺼운 분포이다.\n\n\n2.2 Thresholding rules\n모수 \\(\\mu\\)는 사전분포(prior distribution)를 가진다고 가정하고 \\(X \\sim N(\\mu,1)\\)이라고 가정하자. 이 경우 \\(X=x\\)가 given되었을 경우 \\(\\mu\\)의 사후분포(posterior distribution)를 구할 수 있다. (자세한 내용은 Section 6을 참고해야함) 사후분포의 중앙값을 \\(\\hat{\\mu}(x;w)\\)라고 하자. (사후분포의 중앙값이 \\(w\\)에 영향받는 이유는 사전분포가 \\(w\\)에 depend하기 때문이다. 여기에서 \\(w\\)는 marginal MLE로 적절히 추론한다고 가정한다)\n\\(X_i\\)는 독립이라고 가정한다. 여기에서 \\(X_i\\)가 독립이 아니라면 약간의 정보손실이 있을 수 있다. 하지만 \\(X_i\\) 사이에 너무 많은 dependency가 존재하는 경우가 아니라면 Ebayesthresh는 어느정도 합리적인 결과를 제공한다.\n만약에 bayesfac=TRUE를 사용하면 \\(\\mu\\)의 사후분포의 중앙값 대신에 Bayes factor threshold 를 쓸 수도 있다.\n\n\n2.3 Choosing the threshold\n\\(X_i\\)의 marginal density는\n\\((1-w)\\phi(x) +w(\\gamma \\star \\phi)(x)\\)\n\\(l(w) = \\sum_{i=1}^{n}\\log \\big\\{(1-w)\\phi(X_i)+wg(X_i) \\big\\}\\)\n와 같이 정의가능하다. 단, 여기에서 \\(g:= \\gamma\\star \\phi\\) 이다.\n이제 우리는 아래의 식을 풀면된다.\n\\[\\underset{w}{\\operatorname{argmax}} l(w)\\quad\\quad \\text{subject to}\\quad t(w) \\leq \\sqrt{2\\log n}\\]\n여기에서 \\(\\sqrt{2\\log n}\\)은 흔히 말하는 universal threshold 이다.\n만약에 \\(w\\)이외에 \\(a\\)도 추정해야 한다면 아래와 같이 추정할 수 있다.\n\\[\\underset{w}{\\operatorname{argmax}} l(w)\\quad\\quad \\text{subject to}\\quad t(w) \\leq \\sqrt{2\\log n}\\]"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "",
    "text": "options(repr.plot.width=10, repr.plot.height=3,repr.plot.res=300)"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#주피터에-r커널을-연결할-경우-그림크기-조정",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#주피터에-r커널을-연결할-경우-그림크기-조정",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "",
    "text": "options(repr.plot.width=10, repr.plot.height=3,repr.plot.res=300)"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#깃허브에서-.py파일-불러오기",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#깃허브에서-.py파일-불러오기",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "2 깃허브에서 *.py파일 불러오기",
    "text": "2 깃허브에서 *.py파일 불러오기\nimport requests\nexec(requests.get('http://miruetoto.github.io/my_code/datahandling.py').text)"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#rpy2-magic",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#rpy2-magic",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "3 rpy2 magic",
    "text": "3 rpy2 magic\nimport rpy2\n%load_ext rpy2.ipython"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#깃허브에서-.r파일-불러오기",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#깃허브에서-.r파일-불러오기",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "4 깃허브에서 *.R파일 불러오기",
    "text": "4 깃허브에서 *.R파일 불러오기\nimport rpy2\n%load_ext rpy2.ipython\n%R library(devtools)\n%R source_url(\"http://miruetoto.github.io/my_code/datahandling.r\")"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#matplotlib-그림크기조정",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#matplotlib-그림크기조정",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "5 matplotlib 그림크기조정",
    "text": "5 matplotlib 그림크기조정\nimport matplotlib as mpl \nimport matplotlib.pyplot as plt \nIpython_default=plt.rcParams.copy() # save initial value \nfrom matplotlib import cycler\nplt.rc('figure',dpi=150) # default value 4 figure.dpi is 72.0 \n# plt.rcParams.update(Ipython_default) # load initial value"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#깃랩관련-회사아니면-필요없음",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#깃랩관련-회사아니면-필요없음",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "6 깃랩관련 (회사아니면 필요없음)",
    "text": "6 깃랩관련 (회사아니면 필요없음)\n- load *.py from gitlab\nimport gitlab\ngl = gitlab.Gitlab('http://10.178.145.54:9000', private_token='RkZz465zdyyEChamLKy8')\ngl.auth()\nproject = gl.projects.get(2)\n\n# (1) load RF.py, RF_withGIT.py, RF_withR.py\nRF_py = project.files.get(file_path='modeling/RF.py', ref='fridge').decode()\nRF_GIT_py = project.files.get(file_path='utils/RF_withGIT.py', ref='fridge').decode()\nRF_R_py = project.files.get(file_path='utils/RF_withR.py', ref='fridge').decode()\nexec(str(RF_py, 'utf-8'))\nexec(str(RF_GIT_py, 'utf-8'))\nexec(str(RF_R_py, 'utf-8'))\n- load *.R in gitlab\nimport gitlab\ngl = gitlab.Gitlab('http://10.178.145.54:9000', private_token='RkZz465zdyyEChamLKy8')\ngl.auth()\nproject = gl.projects.get(2)\nRF_R_rcode = project.files.get(file_path='utils/RF_Rfunctions.r', ref='fridge').decode()\n# tricks for source('Rfunctions.r')\nfile1 = open(\"RF_Rfunctions.r\",\"w\") \nfile1.write(str(RF_R_rcode, 'utf-8'))\nfile1.close() \nro.r(\"source('RF_Rfunctions.r')\")\nimport os\nos.remove('RF_Rfunctions.r')"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#옵션으로-주피터-실행",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#옵션으로-주피터-실행",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "7 & 옵션으로 주피터 실행",
    "text": "7 & 옵션으로 주피터 실행\n- 서버에 접속한다.\nssh lgcgb@10.178.144.65\n아래와 같이 끝에 &을 붙이면 된다.\nconda activate py20190129\njupyter lab &\n실행하고 난뒤에는 엔터를 쳐서 빠져나온다. 이렇게 하면 서버자체에 모니터를 연결하고 커널창을 띄운것과 같은 효과를 준다. 즉 서버에 접속한 컴퓨터를 끄는것과 상관없이 서버에서는 항상 주피터가 열려 있게 된다."
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#옵션으로-실행한-주피터프로세스-죽이기",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#옵션으로-실행한-주피터프로세스-죽이기",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "8 & 옵션으로 실행한 주피터프로세스 죽이기",
    "text": "8 & 옵션으로 실행한 주피터프로세스 죽이기\n- 서버에 접속한다.\nssh lgcgb@10.178.144.65\n실행된 프로세스를 찾기위해 아래를 실행한다.\nps aux | grep jupyter-lab\n결과는 아래와 같이 나온다.\nlgcgb    26888  0.2  0.1 326760 86724 ?        Sl   10:14   0:12 /home/lgcgb/anaconda3/envs/py20190129/bin/python3.7 /home/lgcgb/anaconda3/envs/py20190129/bin/jupyter-lab\nlgcgb    27146  0.0  0.0  15720  1008 pts/3    S+   11:56   0:00 grep --color=auto jupyter-lab\n26888에 해당하는 것이 주피터를 띄운 커널이다. 이 번호를 기억했다가 프로세스를 아래와 같은 명령으로 죽인다.\nkill 26888"
  },
  {
    "objectID": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#패스워드-없이-주피터-실행",
    "href": "posts/2000-01-08-(메모) 주피터랩, 설정 및 몇가지 팁.html#패스워드-없이-주피터-실행",
    "title": "(메모) 주피터랩, 설정 및 몇가지 팁",
    "section": "9 패스워드 없이 주피터 실행",
    "text": "9 패스워드 없이 주피터 실행\n- 아래와 같이 하면 외부에서 접속할때 패스워드를 입력하지 않음.\njupyter notebook --ServerApp.token='' --ServerApp.password=''"
  },
  {
    "objectID": "posts/2023-01-20-(공부) 추정.html",
    "href": "posts/2023-01-20-(공부) 추정.html",
    "title": "(공부) 추정",
    "section": "",
    "text": "using Distributions, Plots"
  },
  {
    "objectID": "posts/2023-01-20-(공부) 추정.html#mme와-mle",
    "href": "posts/2023-01-20-(공부) 추정.html#mme와-mle",
    "title": "(공부) 추정",
    "section": "1 MME와 MLE",
    "text": "1 MME와 MLE\n데이터로부터 모수 혹은 모수의 함수를 추측하는 일을 추정이라고 한다. 교과서에서 가장 처음으로 배우는 것은 적률추정(MME)이다. 적률추정량은 구하기가 쉽고1 일치성을 가진다는 장점이 있는 반면 추정량이 유일하지 않다는 단점이 존재한다.\n보통 통계학과에서는 적률추정량보다 최대가능도 추정량(MLE)을 더 선호하게 된다. MLE는 일반적으로 MME보다 구하기 어렵다. 그래서 MLE를 구하는 여러가지 연습문제를 풀 필요성이 있다."
  },
  {
    "objectID": "posts/2023-01-20-(공부) 추정.html#hatthetamle의-일치성",
    "href": "posts/2023-01-20-(공부) 추정.html#hatthetamle의-일치성",
    "title": "(공부) 추정",
    "section": "2 \\(\\hat{\\theta}^{MLE}\\)의 일치성",
    "text": "2 \\(\\hat{\\theta}^{MLE}\\)의 일치성\nMME는 일치성을 가졌는데, MLE는 어떠할까? 일반적으로 MLE 역시 일치성을 가짐을 보일 수 있다. 이걸 증명하는게 좀 까다로운데 증명을 생략하고 직관만 얻어보자. 먼저 \\(X_1,\\dots,X_n\\)가 모수가 \\(\\theta_0\\)인 어떠한 분포의 iid random sample이라면 \\(X_1,\\dots,X_n\\)을 바탕으로 MLE를 아래와 같이 추정할 수 있다.\n\\[\\hat{\\theta}^{MLE}=\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}} l(\\theta)=\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}} \\sum_{i=1}^{n}\\log f(X_i;\\theta)\\]\n여기에서 \\(l(\\theta)\\)는 \\(\\theta\\)에 대한 로그가능도 함수라고 한다. 그런데 \\(l(\\theta)\\)를 최대화하는 일은 \\(\\frac{1}{n}l(\\theta)\\)를 최대화하는 일과 같으므로 \\(\\hat{\\theta}^{MLE}\\)는 아래와 같이 쓸 수 있다.\n\\[\\hat{\\theta}^{MLE}=\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}}\\frac{1}{n}l(\\theta)=\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}}\\frac{1}{n}\\sum_{i=1}^{n}\\log f(X_i; \\theta)\\]\n이제 \\(\\log f(X_i;\\theta)\\)자체를 하나의 확률변수 \\(Y_i\\)라고 생각하면 \\(\\frac{1}{n}\\sum_{i=1}^{n}\\log f(X_i;\\theta) = \\frac{1}{n}\\sum_{i=1}^{n} Y_i\\)의 꼴이므로 WLLN을 쓸 수 있다. 즉 아래를 보일 수 있다.\n\\[\\frac{1}{n}\\sum_{i=1}^{n}Y_i  \\overset{P_{\\theta_0}}{\\to} \\mathbb{E}(Y_1)\\]\n왠지 위의 식이 성립하니까 아래도 성립할 것 같다.\n\\[\\hat{\\theta}^{MLE}=\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}}\\frac{1}{n}\\sum_{i=1}^{n}Y_i \\overset{P_{\\theta_0}}{\\longrightarrow}\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}}\\mathbb{E}(Y_1)\\]\n마치 \\(\\text{argmax}\\)를 하나의 함수 \\(g\\)로 생각하면 \\(\\bar{Y} \\overset{P_{\\theta_0}}{\\to} E(Y_1)\\) 일때 \\(g\\big(\\bar{Y}\\big) \\overset{P_{\\theta_0}}{\\to} g\\big(E(Y_1)\\big)\\) 이 성립한다는 논리이다. 당연히 이러한 논리는 항상 성립하는 것이 아니고 “균등확률수렴성”이라는 강한 조건이 필요하다. 균등수렴성에 대한 자세한 내용은 생략하고 일단\n\\[\\hat{\\theta}^{MLE} \\overset{P_{\\theta_0}}{\\longrightarrow}\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}}\\mathbb{E}(Y_1)\\]\n와 같은 식이 성립한다고만 알고 있자.2 우리는 MLE의 일치성을 조사하고 싶으므로 결국 아래를 증명하면 된다.\n\\[\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}}\\mathbb{E}(Y_1) = \\underset{\\theta \\in \\Omega}{\\operatorname{argmax}}\\mathbb{E}\\big[\\log f(X_1,\\theta)\\big] = \\theta_{0}\\]\n결국 \\(\\underset{\\theta \\in \\Omega}{\\operatorname{argmax}}\\mathbb{E}\\big[\\log f(X_1,\\theta)\\big] = \\theta_0\\)임을 증명하면 되는데 이것은 (1) pdf가 모수 \\(\\theta\\)에 대하여 identifiable이고3 (2) pdf의 support가 \\(\\theta\\)에 depend하지 않는 경우 성립한다고 알려져 있다.\n\n사실 이러한 조건은 당연한게 identifiable이 아니라면 제대로된 pdf가 아니라는 의미이겠고 pdf의 support가 \\(\\theta\\)에 depend 한다면 \\(U[\\theta-1,\\theta+1]\\)과 같은 분포처럼 \\(\\theta\\)의 MLE가 유일하지 않을 수도 있다는 의미이므로 이러한 두 조건은 합리적으로 보임"
  },
  {
    "objectID": "posts/2023-01-20-(공부) 추정.html#hatthetamle의-점근분포",
    "href": "posts/2023-01-20-(공부) 추정.html#hatthetamle의-점근분포",
    "title": "(공부) 추정",
    "section": "3 \\(\\hat{\\theta}^{MLE}\\)의 점근분포",
    "text": "3 \\(\\hat{\\theta}^{MLE}\\)의 점근분포\n\\(\\frac{1}{n}\\dot{l}(\\hat{\\theta})\\)의 값을 테일러 정리에 의한 일차근사로 추정하면 아래와 같다.\n\\[\\frac{1}{n}\\dot{l}(\\hat{\\theta}) \\approx \\frac{1}{n}\\dot{l}(\\theta) + \\frac{1}{n}\\ddot{l}(\\theta)(\\hat{\\theta}-\\theta)\\]\n\n3.1 MLE의 일치성에 대한 구체적인 논의\n\\(X_1,\\dots,X_{10} \\overset{i.i.d.}{\\sim} Ber(\\theta)\\) 이라고 하자.\n\nx = rand(Bernoulli(0.3),10)\nx\n\n10-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 1\n 1\n 0\n 0\n 0\n 0\n\n\n여기에서 \\(\\theta\\)는 추정해야할 미지의 모수이지만 우리는 시뮬레이션의 편의상 \\(\\theta\\)의 참값을 \\(\\theta_0=\\frac{1}{3}\\)로 알고 있다고 하자. MLE를 논의함에 있어 핵심적인 역할을 하는 것은 \\(Y_1=\\log f(X_1;\\theta)\\)이다. 아래는 \\(Y_1\\)에 대한 몇가지 코멘트이다.\n(1) \\(Y_1\\)은 \\(X_1\\)와 \\(\\theta\\)의 함수이다.\n\n우선 \\(X_1\\)의 함수이므로 \\(Y_1\\)역시 확률변수이다. 따라서 \\(Y_1\\)에 대하여 평균등을 취할 수 있으며 LLN을 쓸 수 있다.\n\\(Y_1\\)은 \\(\\theta\\)에 대한 함수이므로 \\(\\theta\\)에 대하여 미분할 수 있다.\n\n(베르누이 예제)\n우리의 베르누이 예제에서 \\(Y_1\\)은 아래와 같이 계산된다.\n\\[Y_1 = \\log f(X_1;\\theta)= X_1 \\log \\theta + (1-X_1)\\log(1-\\theta)\\]\n보는 것 처럼 \\(Y_1\\)은 \\(X_1\\)와 \\(\\theta\\)의 함수임\n(2) \\(\\mathbb{E}_{\\theta_0}(Y_1)\\)은 \\(\\theta\\) 만의 함수이다. 적당한 조건4이 만족된다면 \\(\\mathbb{E}_{\\theta_0}(Y_1)\\)은 \\(\\theta_0\\) 에서 최대화 된다.\n(베르누이 예제)\n\\(\\mathbb{E}_{\\theta_0}(Y_1) = \\mathbb{E}_{\\theta_0}(X_1)\\log\\theta + (1-\\mathbb{E}_{\\theta_0}(X_1))\\log(1-\\theta) =  \\frac{1}{3} \\log\\theta + (1-\\frac{1}{3})\\log(1-\\theta)\\)\n\n일반적인 상황에서는 참모수를 모르지만 우리는 시뮬레이션을 \\(\\theta=1/3\\)에서 하였으므로 참모수 \\(\\theta_0=\\mathbb{E}_{\\theta_0}(X_1)=\\frac{1}{3}\\)을 알고 있다고 가정한다.\n\n\nplot(θ -&gt; (1/3)*log(θ) + (1-1/3)*log(1-θ)) \n\n\n\n\n\n\n\n\n보는것처럼 이 함수 \\(\\mathbb{E}_{\\theta_0}(Y_1)\\)은 \\(\\theta=\\theta_0=\\frac{1}{3}\\) 에서 최대값을 가진다.\n(3) \\(\\frac{\\partial}{\\partial \\theta}Y_1\\) 역시 \\(X_1\\)와 \\(\\theta\\)의 함수이다.\n\n따라서 \\(\\frac{\\partial}{\\partial \\theta}Y_1\\) 역시 확률변수이고 \\(\\frac{\\partial}{\\partial \\theta}Y_1\\)에 대하여 평균등을 취할 수 있으며 LLN을 쓸 수 있다.\n\n(베르누이 예제)\n\\(\\frac{\\partial}{\\partial\\theta}Y_1 = X_1\\frac{1}{\\theta} + (1-X_1)\\frac{-1}{1-\\theta}\\)\n(4) \\(\\mathbb{E}_{\\theta}[\\frac{\\partial}{\\partial \\theta}Y_1]=0\\) 이다.\n(베르누이 예제)\n\\(\\mathbb{E}_{\\theta}[\\frac{\\partial}{\\partial\\theta}Y_1] = \\theta\\frac{1}{\\theta} + (1-\\theta)\\frac{-1}{1-\\theta}=0\\)\n(5) \\(\\mathbb{V}_{\\theta}[\\frac{\\partial}{\\partial\\theta}Y_1]=\\mathbb{E}_{\\theta}[-\\frac{\\partial^2}{\\partial \\theta^2}Y_1]=I(\\theta)\\)\n(베르누이 예제)\n\\(\\mathbb{V}_{\\theta}\\big[\\frac{\\partial}{\\partial\\theta}Y_1\\big]=\\mathbb{E}_{\\theta}\\big[(\\frac{\\partial}{\\partial\\theta}Y_1)^2\\big]=\\mathbb{E}_{\\theta}\\big[-\\frac{\\partial^2}{\\partial\\theta^2}Y_1\\big]=\\frac{1}{\\theta(1-\\theta)}\\)\n\n두번째 등호는 \\(\\mathbb{E}_{\\theta}[\\frac{\\partial}{\\partial\\theta}Y_1]=0\\)을 이용하여 증명가능하다.\n언뜻 보면 \\(\\mathbb{V}_{\\theta}\\big[\\frac{\\partial}{\\partial\\theta}Y_1\\big]\\)를 계산하는 것이 \\(\\mathbb{E}_{\\theta}\\big[-\\frac{\\partial^2}{\\partial\\theta^2}Y_1\\big]\\)를 계산하는것보다 훨씬 쉬워보인다. 그런데 \\(X_1\\)와 \\(1-X_1\\)이 독립이 아니라서 \\(\\mathbb{V}(X+Y)=\\mathbb{V}(X)+\\mathbb{V}(V)+2\\text{Cov}(X,Y)\\)와 같이 공분산 term을 계산해야 하므로 계산이 까다롭다.\n\n\n베르누이에 대한 피셔정보량은 https://en.wikipedia.org/wiki/Fisher_information 에서 확인할 수 있음"
  },
  {
    "objectID": "posts/2023-01-20-(공부) 추정.html#footnotes",
    "href": "posts/2023-01-20-(공부) 추정.html#footnotes",
    "title": "(공부) 추정",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n거의 암산가능↩︎\n균등확률수렴성은 로그가능도함수가 strictly convex일 경우 성립한다는 것이 알려져 있음↩︎\nhttps://en.wikipedia.org/wiki/Identifiability↩︎\nidentifiable & common support↩︎"
  },
  {
    "objectID": "posts/2000-01-04-(메모) 우분투 익히기.html",
    "href": "posts/2000-01-04-(메모) 우분투 익히기.html",
    "title": "(메모) 우분투 익히기",
    "section": "",
    "text": "/root\n\n루트사용자의 홈 디렉토리\nsudo로도 들어갈 수 없음\n\n/etc\n\n리눅스 시스템 전반적인 환경설정 파일들을 모은 디렉터리임.\n이 디렉터리의 모든 파일은 텍스트형식임.\n/etc/password 사용자 계정정보\n\n/home\n\n사용자의 홈 디렉터리\n\n/mnt\n\n다른 파일 시스템이 파일 시스템에 연결되거나 마운트 되는 위치\n\n/media\n\nCD, USB 장치가 파일 시스템에 연결되거나 마운트되는 위치임\n\n/bin\n\n시스템 부팅과 실행에 필요한 바이너리(=윈도도의 실행파일=macOS의 애플리케이션)들을 포함\n\n/lib\n\n시스템 프로그램에서 사용하는 공유 라이브러리가 저장. 윈도우즈의 DLL과 비슷한 것.\n\n/usr\n\n사용자가 사용하는 모든 프로그램과 지원파일들 (Program files + 프로그램들의 설정값)\n/usr/bin 리눅스 배포판이 설치한 실행 프로그램들이 있다. (여기에 R이 깔린다!!)\n\nhp-align, hp-check, hp-config_usb-printer …\nX11\nvi\ngcc\nsu, sudo\nsar\nssh, ssh-agent, ssh-keygen, ….\nnvidia-smi\n\n/usr/lib 여기에는 /usr/bin에 있는 프로그램들을 위한 공유라이브러리가 저장된다. 여기에 R folder가 있다. (R패키지는 여기말고 다른데 깔림)\n/usr/local/bin 소스코드로 컴파일된 파일, 보통 비어있음\n/usr/local/lib/R/site-library R패키지가 설치되어있음, 예를들면 tidyverse"
  },
  {
    "objectID": "posts/2000-01-04-(메모) 우분투 익히기.html#기본디렉토리-설명",
    "href": "posts/2000-01-04-(메모) 우분투 익히기.html#기본디렉토리-설명",
    "title": "(메모) 우분투 익히기",
    "section": "",
    "text": "/root\n\n루트사용자의 홈 디렉토리\nsudo로도 들어갈 수 없음\n\n/etc\n\n리눅스 시스템 전반적인 환경설정 파일들을 모은 디렉터리임.\n이 디렉터리의 모든 파일은 텍스트형식임.\n/etc/password 사용자 계정정보\n\n/home\n\n사용자의 홈 디렉터리\n\n/mnt\n\n다른 파일 시스템이 파일 시스템에 연결되거나 마운트 되는 위치\n\n/media\n\nCD, USB 장치가 파일 시스템에 연결되거나 마운트되는 위치임\n\n/bin\n\n시스템 부팅과 실행에 필요한 바이너리(=윈도도의 실행파일=macOS의 애플리케이션)들을 포함\n\n/lib\n\n시스템 프로그램에서 사용하는 공유 라이브러리가 저장. 윈도우즈의 DLL과 비슷한 것.\n\n/usr\n\n사용자가 사용하는 모든 프로그램과 지원파일들 (Program files + 프로그램들의 설정값)\n/usr/bin 리눅스 배포판이 설치한 실행 프로그램들이 있다. (여기에 R이 깔린다!!)\n\nhp-align, hp-check, hp-config_usb-printer …\nX11\nvi\ngcc\nsu, sudo\nsar\nssh, ssh-agent, ssh-keygen, ….\nnvidia-smi\n\n/usr/lib 여기에는 /usr/bin에 있는 프로그램들을 위한 공유라이브러리가 저장된다. 여기에 R folder가 있다. (R패키지는 여기말고 다른데 깔림)\n/usr/local/bin 소스코드로 컴파일된 파일, 보통 비어있음\n/usr/local/lib/R/site-library R패키지가 설치되어있음, 예를들면 tidyverse"
  },
  {
    "objectID": "posts/2000-01-04-(메모) 우분투 익히기.html#기본명령어",
    "href": "posts/2000-01-04-(메모) 우분투 익히기.html#기본명령어",
    "title": "(메모) 우분투 익히기",
    "section": "2 기본명령어",
    "text": "2 기본명령어\n\n2.1 pwd, whoami\n- 현재위치확인\n(base) cgb2@cgb2-desktop:~$ pwd\n/home/cgb2\n- 유저확인\n### 예시1: 유저확인 \n(base) cgb2@cgb2-desktop:~$ whoami \ncgb2 \n\n### 예시2: 루트권한 획득이후 유저확인 \n(base) cgb2@cgb2-desktop:~$ sudo -i # 루트권한 획득\nroot@cgb2-desktop:~# whoami \nroot \n\n### 예시3: 일반유저로 전환후 유저확인\nroot@cgb2-desktop:~# su - cgb2 \n(base) cgb2@cgb2-desktop:~$ whoami\ncgb2\n\n\n2.2 cd, ls\n- 홈디렉토리로 이동 + 목록\n(base) cgb2@cgb2-desktop:~/Dropbox$ cd ~\n(base) cgb2@cgb2-desktop:~$ ls\nDesktop                 julia-1.8.5\nDocuments               julia-1.8.5-linux-x86_64.tar.gz\nDownloads               lm.txt\nDropbox                 nbdev_tst\nMusic                   quarto-1.0.37-linux-amd64.deb\nPictures                rstudio-server-2021.09.2-382-amd64.deb\nPublic                  scikit_learn_data\nR                       snap\nTemplates               test.txt\nVideos                  v3net\nanaconda3               v3net-linux-3.6.10.11.805.tar.Z\nblacklist-nouveau.conf  vscode_cli.tar.gz\ncode\n- 루트로 이동 + 목록\n(base) cgb2@cgb2-desktop:~/Dropbox$ cd /\n(base) cgb2@cgb2-desktop:/$ ls\nbin    dev   lib    libx32      media  proc  sbin  swapfile  usr\nboot   etc   lib32  log         mnt    root  snap  sys       var\ncdrom  home  lib64  lost+found  opt    run   srv   tmp\n- ls 자세하게\n(base) cgb2@cgb2-desktop:/$ ls -l\ntotal 2097256\nlrwxrwxrwx   1 root  root           7  2월 11  2022 bin -&gt; usr/bin\ndrwxr-xr-x   3 root  root        4096  7월 27 12:19 boot\ndrwxrwxr-x   2 root  root        4096  2월 11  2022 cdrom\ndrwxr-xr-x  19 root  root        4480  7월 28 12:19 dev\ndrwxr-xr-x 143 root  root       12288  7월 27 21:08 etc\ndrwxr-xr-x   6 root  root        4096  7월  7 11:14 home\nlrwxrwxrwx   1 root  root           7  2월 11  2022 lib -&gt; usr/lib\nlrwxrwxrwx   1 root  root           9  2월 11  2022 lib32 -&gt; usr/lib32\nlrwxrwxrwx   1 root  root           9  2월 11  2022 lib64 -&gt; usr/lib64\nlrwxrwxrwx   1 root  root          10  2월 11  2022 libx32 -&gt; usr/libx32\ndrwxr-x---   2 root  root        4096  2월 11  2022 log\ndrwx------   2 root  root       16384  2월 11  2022 lost+found\ndrwxr-xr-x   2 root  root        4096  8월 19  2021 media\ndrwxr-xr-x   2 root  root        4096  8월 19  2021 mnt\ndrwxr-xr-x   4 jaein saned       4096  7월 16 11:21 opt\ndr-xr-xr-x 418 root  root           0  7월 28 12:16 proc\ndrwx------   6 root  root        4096  7월 27 12:21 root\ndrwxr-xr-x  40 root  root        1220  8월  3 13:31 run\nlrwxrwxrwx   1 root  root           8  2월 11  2022 sbin -&gt; usr/sbin\ndrwxr-xr-x  14 root  root        4096  7월 16 11:10 snap\ndrwxr-xr-x   2 root  root        4096  8월 19  2021 srv\n-rw-------   1 root  root  2147483648  2월 11  2022 swapfile\ndr-xr-xr-x  13 root  root           0  7월 28 12:16 sys\ndrwxrwxrwt  19 root  root       20480  8월  3 13:29 tmp\ndrwxr-xr-x  14 root  root        4096  8월 19  2021 usr\ndrwxr-xr-x  15 root  root        4096  7월 30  2022 var\n\n\n2.3 -h, man\n- 도움말확인\n(base) cgb2@cgb2-desktop:~$ git --help\nusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]\n           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]\n           &lt;command&gt; [&lt;args&gt;]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone             Clone a repository into a new directory\n   init              Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add               Add file contents to the index\n   mv                Move or rename a file, a directory, or a symlink\n   restore           Restore working tree files\n   rm                Remove files from the working tree and from the index\n   sparse-checkout   Initialize and modify the sparse-checkout\n\nexamine the history and state (see also: git help revisions)\n   bisect            Use binary search to find the commit that introduced a bug\n   diff              Show changes between commits, commit and working tree, etc\n   grep              Print lines matching a pattern\n   log               Show commit logs\n   show              Show various types of objects\n   status            Show the working tree status\n\ngrow, mark and tweak your common history\n   branch            List, create, or delete branches\n   commit            Record changes to the repository\n   merge             Join two or more development histories together\n   rebase            Reapply commits on top of another base tip\n   reset             Reset current HEAD to the specified state\n   switch            Switch branches\n   tag               Create, list, delete or verify a tag object signed with GPG\n\ncollaborate (see also: git help workflows)\n   fetch             Download objects and refs from another repository\n   pull              Fetch from and integrate with another repository or a local branch\n   push              Update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. See 'git help &lt;command&gt;' or 'git help &lt;concept&gt;'\nto read about a specific subcommand or concept.\nSee 'git help git' for an overview of the system.\n- 메뉴얼 확인\n(base) cgb2@cgb2-desktop:~$ man git\n\n\n2.4 cp, mv, mkdir, rm\n- 카피\ncp file1 file2 # file1을 복사하여 file2를 새로 만듬. file2가 이미 있다면 file1의 내용을 덮어씀 \ncp -r dir1 dir2 # dir1의 모든파일을 복사하여 dir2로 이동한뒤 붙어넣음. dir2가 없다면 새로 만듬. 기존의 dir2에 있던 파일이 삭제되는건 아님 \n- 이동\nmv file1 file2 # file1을 이동하여 file2로 이름바꿈. file2가 이미 있다면 file1의 내용을 덮어씀 \nmv -r dir1 dir2 # dir1의 모든파일을 잘라내어 dir2로 이동. \n- 디렉토리 생성\nmkdir temp\nmkdir temp1, temp2, temp3 # 여러개를 만듬\n- 삭제\nrm file1 # file1삭제 \nrm -r file1 dir1 # file1삭제 dir1폴더삭제 \nrm -rf file1 dir1 # 위와 동일한데 file1이나 dir1이 존재하지 않더라고 rm이 실행\n- -v(verbose)를 쓰면 친절한 느낌이 든다.\n(base) cgb2@cgb2-desktop:~/Dropbox$ cp *.txt temppp -v\n'colab.txt' -&gt; 'temppp/colab.txt'\n\n\n2.5 scp\n- cgb2에 있는 lm.txt를 cgb5로 옮김. 포트는 cgb5에 대응하는 포트\ncgb2@cgb2-desktop:~$ scp -P 4653 lm.txt cgb5@210.117.173.185:~\n- cgb2에 있는 lm.txt를 맥으로 가져옴. 포트는 cgb2에 대응하는 포트\n\n\n\n2.6 find\n- Dropbox라는 이름이 포함된 폴더 찾기\nfind ~ -type d -name \"Dropbox\"\n\n여기에서 ~는 검색을 시작할 최상위 디렉토리를 쓴다.\n여기에서 -type d는 디렉토리라는 의미이다.\n\n- sy.tex이라는 파일찾기\nfind ~ -type f -name \"sy.tex\"\n\n여기에서 ~는 검색을 시작할 최상위 디렉토리를 쓴다.\n여기에서 -type d는 디렉토리라는 의미이다."
  },
  {
    "objectID": "posts/2000-01-04-(메모) 우분투 익히기.html#설치관련",
    "href": "posts/2000-01-04-(메모) 우분투 익히기.html#설치관련",
    "title": "(메모) 우분투 익히기",
    "section": "3 설치관련",
    "text": "3 설치관련\n\n3.1 wget\n- 인터넷에서 파일 다운로드\nwget https://download2.rstudio.org/server/bionic/amd64/rstudio-server-1.2.5033-amd64.deb\n\n\n3.2 gdebi, deb\n- deb파일을 gdebi로 설치하는 방법\nsudo gdebi rstudio-server-1.2.5033-amd64.deb\n- deb파일을 dpkg를 이용하여 설치하는 방법\ndpkg -i quarto-1.2.335-linux-amd64.deb # 설치\ndpkg -r quarto # 삭제 \n- gdebi, deb의 차이\n\ngdebi는 관련패키지를 모두 찾아서 설치 dpkg는 하나의 패키지만 설치. 즉 gdebi는 conda 느낌이고 dpkg는 pip 느낌\ngdebi는 별도의 삭제옵션을 지원하지 않음. 따라서 gdebi로 설치한 deb을 삭제하려면 머리아플수도?\n\n- gdebi로 설치한 패키지를 삭제하는 방법\n\n\n\n\n\n\nChat-GPT 답변\n\n\n\ngdebi로 패키지를 삭제하는 것은 아쉽게도 직접적으로 지원하지 않습니다. gdebi는 주로 패키지를 설치할 때 사용되는 도구이며, 패키지의 삭제에는 사용되지 않습니다. 패키지를 삭제하려면 다른 도구인 dpkg나 패키지 관리자 명령을 사용해야 합니다.\n패키지를 삭제하는 방법은 아래와 같습니다. 패키지를 삭제하기 전에 해당 패키지가 다른 의존하는 패키지에 영향을 주지 않는지 주의깊게 확인하시기 바랍니다.\ndpkg를 사용하여 패키지 삭제하기:\nsudo dpkg -r 패키지이름\n여기서 패키지이름은 삭제하려는 패키지의 이름입니다. 이 명령을 실행하면 해당 패키지가 삭제됩니다.\napt를 사용하여 패키지 삭제하기 (의존성 관리 포함):\nsudo apt remove 패키지이름\n위 명령은 apt를 통해 패키지를 삭제하며, 의존성을 포함하여 관련된 패키지들도 자동으로 처리합니다. 이 방법은 일반적으로 패키지 삭제에 더 효과적입니다.\n위의 방법 중 하나를 선택하여 패키지를 삭제할 수 있습니다. 패키지 삭제 시에는 주의하여 의존성 문제가 발생하지 않도록 해야 합니다.\n\n\n\n\n3.3 apt\nsudo apt update\nsudo apt list \nsudo apt install {openssh-server}  \nsudo apt remove {r-base-core}\nsudo apt purge {r-base* r-recommended r-cran-*}\nsudo apt autoremove\n- sudo apt-get과 sudo apt 차이? 별 차이 없는듯\n\nhttps://askubuntu.com/questions/445384/what-is-the-difference-between-apt-and-apt-get\n\n\nThey are very similar command line tools available in Trusty (14.04) and later. apt-get and apt-cache’s most commonly used commands are available in apt. apt-get may be considered as lower-level and “back-end”, and support other APT-based tools. apt is designed for end-users (human) and its output may be changed between versions.\n\n\n\n3.4 conda\nconda env list\nconda list \nconda install -c conda-forge jupyterlab \nconda install -c conda-forge r-devtools\nconda remove jupyterlab \nconda remove r-base\nconda update -n py38r40 scipy # conda update scipy\n\n\n3.5 pip\npip\npip list\npip list &gt; list.txt\npip freeze # 좀 더 자세히 나온다 \npip freeze &gt; list.txt \npip show matplotlib # 설치된패키지 정보가 나옴. 좋음.\npip install rpy2\npip install -r list.txt \npip install dash==1.13.3\npip install jupyterlab \"ipywidgets&gt;=7.5\"\npip install -U numpy\npip install --upgrade pip\npip install --upgrade tensorflow\npip uninstall matplotlib"
  },
  {
    "objectID": "posts/2000-01-04-(메모) 우분투 익히기.html#리소스-모니터링",
    "href": "posts/2000-01-04-(메모) 우분투 익히기.html#리소스-모니터링",
    "title": "(메모) 우분투 익히기",
    "section": "4 리소스 모니터링",
    "text": "4 리소스 모니터링\ndf # disk \nfree # memory \nnvidia-smi \nwatch -n 5 nvidia-smi -a --display=utilization\ntop\nsar -1 r"
  },
  {
    "objectID": "posts/2000-01-04-(메모) 우분투 익히기.html#appendix",
    "href": "posts/2000-01-04-(메모) 우분투 익히기.html#appendix",
    "title": "(메모) 우분투 익히기",
    "section": "5 Appendix",
    "text": "5 Appendix\n\n5.1 덜 중요한 명령어\n\n5.1.1 file\n- 뭐하는 파일인지 알고싶다면?\n(base) cgb2@cgb2-desktop:~/Dropbox/03_yechan3$ file 1_essays.qmd \n1_essays.qmd: ASCII text\n\n\n5.1.2 date, cal\n- 날짜\n(base) cgb2@cgb2-desktop:~$ date\n2023. 08. 03. (목) 16:10:38 KST\n- 달력\n(base) cgb2@cgb2-desktop:~$ cal\n      8월 2023         \n일 월 화 수 목 금 토  \n       1  2  3  4  5  \n 6  7  8  9 10 11 12  \n13 14 15 16 17 18 19  \n20 21 22 23 24 25 26  \n27 28 29 30 31"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "",
    "text": "- 우분투에서 여러가지 개발환경을 설정하는 방법을 포스팅 하겠다.\n- 이 포스트는 우분투를 메인OS(사무용+연구용)로 사용하고 싶은 사람, 우분투를 활용하여 개발용 서버를 구축하고 싶은 사람에게 모두 유용한다.\n- 이 포스트는 2080 이상의 GPU를 활용한 학습을 원하는 사람에게 유용하다.\n- 이 포스트는 R과 파이썬을 동시에 쓰는 사람에게 유용하다.\n- 이 포스트는 Rstudio, Jupyter Lab을 동시에 쓰는 사람에게 유용하다.\n- 매년 조금씩 셋팅방법이 다른것 같다.\n- 가장 최근에는 2023년 3월8일에 이 블로그 내용으로 셋팅해보았음."
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#about-this-doc",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#about-this-doc",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "",
    "text": "- 우분투에서 여러가지 개발환경을 설정하는 방법을 포스팅 하겠다.\n- 이 포스트는 우분투를 메인OS(사무용+연구용)로 사용하고 싶은 사람, 우분투를 활용하여 개발용 서버를 구축하고 싶은 사람에게 모두 유용한다.\n- 이 포스트는 2080 이상의 GPU를 활용한 학습을 원하는 사람에게 유용하다.\n- 이 포스트는 R과 파이썬을 동시에 쓰는 사람에게 유용하다.\n- 이 포스트는 Rstudio, Jupyter Lab을 동시에 쓰는 사람에게 유용하다.\n- 매년 조금씩 셋팅방법이 다른것 같다.\n- 가장 최근에는 2023년 3월8일에 이 블로그 내용으로 셋팅해보았음."
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#우분투설치",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#우분투설치",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "2 우분투설치",
    "text": "2 우분투설치\n- 22.04부터는 파티션 나누지 않고 그냥 설치해도 잘 되는것 같다."
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#네트워크-설정",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#네트워크-설정",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "3 네트워크 설정",
    "text": "3 네트워크 설정\n- ?표시있는 아이콘 \\(\\to\\) Wired Connected \\(\\to\\) Wired Settings \\(\\to\\) Connection의 설정 \\(\\to\\) IPv4 \\(\\to\\) Manual \\(\\to\\) Address, Netmask, Gateway, DNS 설정 \\(\\to\\) 네트워크 토글"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#한글설정-개발용-서버일-경우-생략-가능",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#한글설정-개발용-서버일-경우-생략-가능",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "4 한글설정 (개발용 서버일 경우 생략 가능)",
    "text": "4 한글설정 (개발용 서버일 경우 생략 가능)\n- 아래와 같이 커맨드에 친다.\nibus-setup\n이걸 치면 IBus Preferences 라는 창이 나오는데 여기에서 (1) Input Method 탭 클릭 (2) Add 버튼 클릭 (3) Korean 선택 (4) Hangul 선택을 한다.\n- 위의 단계에서 Korean이 안보이면 Language Support로 가서 한국어팩을 설치하고 리부팅 하면 된다. (보통 실행하자마자 알아서 설치되더라.. 설치가 안되면 Install / Remove Languages... 이라는 탭을 클릭해서 설치하자) 리부팅을 꼭 해야한다는 것에 주의하자.\n- 이제 Region & Language로 가서 설정하면 된다."
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#그래픽카드-드라이버설치",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#그래픽카드-드라이버설치",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "5 그래픽카드 드라이버설치",
    "text": "5 그래픽카드 드라이버설치\n- 전체적인 내용은 여기를 참고하자.\n- 준비작업\nsudo apt update \nsudo apt install gcc\nsudo apt install build-essential\n- 우선 gedit를 열고 아래를 복사해서 붙여넣는다.\nblacklist nouveau\noptions nouveau modeset=0\n파일이름을 blacklist-nouveau.conf로 home에 저장\n- 루트권한획득\nsudo -i\n아이디와 비밀번호를 입력하고 루트권한을 얻는다.\n- 아래를 입력한다.\nsudo cp /home/cgb2/blacklist-nouveau.conf /etc/modprobe.d\nsudo update-initramfs -u\nsudo reboot \n- 그래픽카드 다운로드: 드라이버 설치파일을 다운받는다. 앤비디아공식홈페이지에서 다운받자. OS를 리눅스 64-bit으로 선택하고 검색을 누르면 다운받아진다.\n- 그래픽키다 설치: 다운받은뒤에는 파일이 있는 폴더로 이동하여\nchmod +x NVIDIA-Linux-x86_64-410.78.run\n를 실행하자. 보통 NVI까지치고 적당히 탭을 누르면 알아서 뒷부분이 완성된다. 이 과정은 추후에 드라이버를 실행할수 있도록 권한을 풀어두는 것이다. 그리고 아래를 실행한다.\nsudo ./NVIDIA-Linux-x86_64-410.78.run\n그 다음 드라이버가 잘 설치되었는지 확인한다.\nnvidia-smi"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#아나콘다",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#아나콘다",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "6 아나콘다",
    "text": "6 아나콘다\n- (아나콘다 설치) 아나콘다를 다운받은 폴더로 가서 아래와 같이 실행한다.\nbash Anaconda3-2019.03-Linux-x86_64.sh\n대충 bash Ana 정도까지만 치고 tab을 누르면 알아서 완성된다.\n- (환경만들기) 커맨드를 키고 아래를 실행한다.\n(base) conda create -n py38r40 python=3.8\n(base) conda create --name py38r40 python=3.8\n둘 중 아무거나 실행해도 된다. 파이썬 환경이 너무 높으면 나중에 conda tensorflow-gpu가 먹히지 않으니 환경을 만들때 파이썬버전을 3.8.x로 하자. (현시점 2021년 2월25일기준 3.9.x이면 conda tensorflow-gpu 가 동작하지 않음.)"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#ssh연결",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#ssh연결",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "7 ssh연결",
    "text": "7 ssh연결\n- 처음에 ssh를 연결하기위해서는 연결당하는 컴퓨터에 가서 아래를 실행해야 한다.\nsudo apt install openssh-server\n22번포트 우회하기\n- step1: /etc/ssh/sshd_config 파일을 연다.\nsudo vi /etc/ssh/sshd_config \n- step2: Port 22 라고 된 부분의 주석을 풀고 원하는 포트번호 설정\n...\n\n#Port 22\n#AddressFamily any\n#ListenAddress 0.0.0.0\n#ListenAddress ::\n\n...\n- step3: 수정내용을 적용\nsudo systemctl restart ssh.service\n- step4: 수정한 포트로 ssh접속"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#주피터-원격제어",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#주피터-원격제어",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "8 주피터 원격제어",
    "text": "8 주피터 원격제어\n- 1단계: 주피랩설치\n(py38) conda install -c conda-forge jupyterlab\n\nNote: 사실 위에서 주피터랩을 따로 설치안해도 주피터랩이 잘만 실행된다. 하지만 이렇게하니까 나중에 R커널을 만들기위해 IRkernel::installspec()을 실행할때 에러가 난다.\n\n- 2단계: 패스워드 설정\n(py38) jupyter lab --generate-config\n(py38) jupyter lab password\n- 3단계: jupyter lab 환경설정\nnano /home/cgb/.jupyter/jupyter_lab_config.py \n아래를 변경\nc.ServerApp.ip = '192.168.0.4'\nc.ServerApp.port = 1306\nc.ServerApp.open_browser = False\n여기에서 192.168.0.4 는 내부아이피다. 고정아피이가 있다면 고정아이피 주소를 쓰면 된다."
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#주피터노트북-원격제어",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#주피터노트북-원격제어",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "9 주피터노트북 원격제어",
    "text": "9 주피터노트북 원격제어\n- 1단계: 주피터노트북 설치 (보통 lab을 설치하면 이미 설치되어있음)\n(py38) conda install -c conda-forge notebook \n- 2단계: 패스워드 설정\nfrom notebook.auth import passwd\npasswd()\nEnter password: \nVerify password: \n생성된값 (argon 어쩌고..)을 복사\n- 3단계: 환경설정\njupyter notebook --generate-config\nnano /home/cgb/.jupyter/jupyter_notebook_config.py\n아이피주소와 패스워드를 바꾼다. (port는 선택, browser도 선택 )\nc.NotebookApp.open_browser = False\nc.NotebookApp.ip = '192.168.0.4'\nc.NotebookApp.port = 1307\nc.NotebookApp.password = ''\n여기에서 192.168.0.4 는 내부아이피다. 고정아피이가 있다면 고정아이피 주소를 쓰면 된다.\n\nTip: 주피터노트북과 랩을 양쪽으로 셋팅후 주피터 노트북으로 실행하면 2개를 모두 쓸 수 있음"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#r설치ver1-base에-설치",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#r설치ver1-base에-설치",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "10 R설치ver1: (base)에 설치",
    "text": "10 R설치ver1: (base)에 설치\n- 설치전: 기존의 R 삭제\nconda remove r-base -y \nsudo apt-get remove r-base-core \nsudo apt purge r-base* r-recommended r-cran-*\nsudo apt autoremove\n- R설치전 준비작업: 나노에디터를 키고 /etc/apt/sources.list를 연다.\nsudo nano /etc/apt/sources.list\n화살표로 이동하여 맨아래로 간뒤에 아래중 하나를 추가한다. (나는 focal-cran40으로 추가함)\ndeb https://cloud.r-project.org/bin/linux/ubuntu impish-cran40/\ndeb https://cloud.r-project.org/bin/linux/ubuntu hirsute-cran40/\ndeb https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/\ndeb https://cloud.r-project.org/bin/linux/ubuntu bionic-cran40/\ndeb https://cloud.r-project.org/bin/linux/ubuntu xenial-cran40/\n저장후 나노에디터 종료. 그리고 아래를 실행.\nsudo apt-get update\n경우에 따라서 아래와 같은 에러메시지가 뜰 수 있다.\n...\nW: GPG error: https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/ InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 51716619E084DAB9 \n...\n공개키가 없어서 생기는 에러이므로 아래와 같이 가져온다.\nwget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9\n#sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 51716619E084DAB9\n그리고 다시 아래를 실행\nsudo apt-get update\n에러가 없이 뭔가 마무리 되어야한다.\n(base) cgb3@cgb3:~$ sudo apt-get update\nIgn:1 http://linux.dropbox.com/ubuntu disco InRelease\nHit:2 http://security.ubuntu.com/ubuntu focal-security InRelease  \nHit:3 http://kr.archive.ubuntu.com/ubuntu focal InRelease                                 \nHit:4 http://ppa.launchpad.net/graphics-drivers/ppa/ubuntu focal InRelease                \nHit:5 http://linux.dropbox.com/ubuntu disco Release                 \nGet:6 https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/ InRelease [3,622 B]\nHit:8 http://kr.archive.ubuntu.com/ubuntu focal-updates InRelease\nGet:9 https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/ Packages [46.4 kB]\nHit:10 http://kr.archive.ubuntu.com/ubuntu focal-backports InRelease\nFetched 50.0 kB in 1s (36.5 kB/s)                   \nReading package lists... Done\n- R설치\nwget http://security.ubuntu.com/ubuntu/pool/main/i/icu/libicu66_66.1-2ubuntu2_amd64.deb\nsudo dpkg -i libicu66_66.1-2ubuntu2_amd64.deb\nsudo apt-get install r-base\n- tidyverse 설치 (R studio 설치전에 tidyverse 설치해야함)\n- Rstudio 설치: https://www.rstudio.com/products/rstudio/download-server/debian-ubuntu/\n\n우분투22로 설정할것!!\n\nsudo apt remove rstudio-server\nsudo apt-get install gdebi-core\nwget https://download2.rstudio.org/server/jammy/amd64/rstudio-server-2022.12.0-353-amd64.deb\nsudo gdebi rstudio-server-2022.12.0-353-amd64.deb\n- Rstudio를 설치하면 ~/R/x86_64-conda-linux-gnu-library/4.1이 새로 생성된다.\n\nRstudio에서 설치한 패키지는 이 폴더에 저장된다.\n\n- 주피터와 R커널 연결\nR # sudo R \ninstall.packages(\"IRkernel\")\nIRkernel::installspec()"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#r설치ver2-py38r40에-설치",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#r설치ver2-py38r40에-설치",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "11 R설치ver2: (py38r40)에 설치",
    "text": "11 R설치ver2: (py38r40)에 설치\n- R설치\n(py38r40) conda install -c conda-forge r-essentials=4.0\n이러면 콘다환경에는 R이 깔리고 base에는 R이 깔리지 않는다.\n- 커널연결\n콘다환경에서 R을 실행한다. Rstudio가 아니라 커맨드에서 R을 실행해야한다. 그리고 아래를 실행하면 주피터랩과 R환경이 연결된다.\nIRkernel::installspec()\n이제 주피터랩에서 R kernel을 사용할 수 있다."
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#가상환경에서-rstudio-server-설치-어려움",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#가상환경에서-rstudio-server-설치-어려움",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "12 가상환경에서 Rstudio server 설치 (어려움)",
    "text": "12 가상환경에서 Rstudio server 설치 (어려움)\n- 이제 Rstudio server를 설치하는 방법을 다룬다.\n- 먼저 Rstudio를 설치한다. 참고로 Rstudio server 설치하는법은 여기를 참고하라. 요약하면 터미널에서 아래3줄을 입력하기만 하면된다.\n(py38r40) sudo apt-get install gdebi-core\n(py38r40) wget https://download2.rstudio.org/server/bionic/amd64/rstudio-server-1.2.5033-amd64.deb\n(py38r40) sudo gdebi rstudio-server-1.2.5033-amd64.deb\n\nWarning: Rstudio 1.3x 이상을 설치하지말고 1.2x를 설치해야 한다. 이상하게 1.3x이상은 후에 서술할 Gregor Strurm가 그의 깃허브에서 제안하는 방식이 잘 동작하지 않았다. 이는 알려진 문제였고 이를 해결하는 해결책을 서술한 스레드가 있어보이긴 했지만 나는 그냥 Rstudio 1.2x를 설치하고 쓰는 것을 선택했다.\n\n\nNote: 이미 rstudio server 가 다른버전으로 깔려있다면 sudo apt remove rstudio-server 를 통하여 삭제하고 설치하자.\n\n- 이제 Rstudio 설치가 끝났다. 설치된 Rstudio를 아나콘다 가상환경에 설치된 R과 연결해보자. 우선 아래를 실행한다.\n(py38r40) sudo apt install uuid\n(py38r40) sudo apt install git\n(py38r40) git clone https://github.com/grst/rstudio-server-conda.git\n위에 두줄은 Gregor Sturm이 만든 어떤 프로그램을 쓰기 위한 사전준비작업이다. 마지막줄을 실행하면 Gregor Sturm이 만든 프로그램이 다운받아진다. 이게 프로그램 설치가 완료된것이다. 이제 컴퓨터 껐다 킬때마다 아래를 실행한다.\n(py38r40) ./rstudio-server-conda/local/start_rstudio_server.sh 8787 # use any free port number here. \n이제 192.168.0.4:8787 따위의 주소로 접속하면 Rstudio를 쓸 수 있다. 참고로 system-wide Rstudio server를 죽여야 할 때가 있다. 그럴땐 아래 명령을 치면 된다.\n(py38r40) sudo systemctl disable rstudio-server.service\n(py38r40) sudo systemctl stop rstudio-server.service"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#자주-설치하는-패키지-리스트",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#자주-설치하는-패키지-리스트",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "13 자주 설치하는 패키지 리스트",
    "text": "13 자주 설치하는 패키지 리스트\n- 아래를 미리 깔아두자..\n# conda install -c conda-forge notebook\nconda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch\nconda install -c conda-forge plotly \npip install plotnine\npip install seaborn\npip install opencv-python\npip install folium\npip install pandas_datareader\nconda install -c conda-forge r-essentials=4 \npip install rpy2\nconda install -c conda-forge python-graphviz\n- tensorflow-gpu 는 현재(2022-03-06) python=3.10 에서 동작함\nconda create -n py310 python=3.10 \nconda activate py310 \nconda install -c conda-forge tensorflow-gpu \n- 아래를 설치하면 좋음\nsudo apt install mc"
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#터미널-예쁘게-만들기",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#터미널-예쁘게-만들기",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "14 터미널 예쁘게 만들기",
    "text": "14 터미널 예쁘게 만들기\n- zsh 설치 + oh my zsh 설치\nsudo install zsh \nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n- 테마변경\n\n.zshrc 파일 열기\n\nnano ~/.zshrc \n\n아래의 내용 수정\n\n...\nZSH_THEME=\"agnoster\"\n...\n- 색상변경\n\n아래의 파일 열기\n\ncd ~/.oh-my-zsh/themes/\nnano agnoster.zsh-theme  \n\n내용수정\n\n...\nprompt_dir() {\n  prompt_segment 39d $CURRENT_FG '%~'\n}\n..."
  },
  {
    "objectID": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#sublime-text-and-tex-개발용-서버일-경우-생략-가능",
    "href": "posts/2000-01-01-(메모) 우분투 포맷 및 개발용 서버 셋팅(old).html#sublime-text-and-tex-개발용-서버일-경우-생략-가능",
    "title": "(메모) 우분투 포맷 및 개발용 서버 셋팅 (old)",
    "section": "15 sublime text and TeX (개발용 서버일 경우 생략 가능)",
    "text": "15 sublime text and TeX (개발용 서버일 경우 생략 가능)\n- ‘Ubuntu Software’에 가서 ’sublime Text’를 치면 다운받을 수 있다. 다운받은뒤에 ’file’ -&gt; ’open folder’를 활용하여 깃허브의 로칼저장소를 열어두면 편리하다.\n- 아래를 실행하여 TeX을 깐다.\nsudo apt install texlive-full\n- 이제 sublime과 latex을 연결하여보자. 여기를 참고하자. (1) sublime을 키고 ‘컨트롤+쉬프트+p’를 눌러 ’Install Package Control’ 선택 (2) 다시 ‘컨트롤+쉬프트+p’ 를 눌러 ‘Package Control: Install Package’를 실행 (3) 그러면 바로 검색창이 나오는데 거기서 ’LaTeXTools’를 입력해서 실행 (4) 다시 ’컨트롤+쉬프트+p’를 누르고 ’LaTeXTools: Check system’ 선택. 모두 ’available’이 나오면 잘 설치된 것이다.\n- *.tex파일을 열고 ’컨트롤+b’를 누르자. 처음이면 어떤 메뉴들이 보일텐데 그냥 ’Latex’을 선택하자. 그러면 코딩결과가 pdf로 나온다.\n- (수식미리보기) ‘Perferences’ &gt; ‘Packages Setting’ &gt; ‘LaTeXTools’ &gt; ‘Settings-User’를 선택한다. ’93번째라인’에 ’preview_math_mode’를 “all”로 바꾼다. 그러면 수식들이 미리 출력된다. 그외에도 자유롭게 셋팅을 조정할 수 있다. 원래셋팅은 ’Perferences’ &gt; ‘Packages Setting’ &gt; ‘LaTeXTools’ &gt; ‘Settings-Defaults’ 에 있다."
  },
  {
    "objectID": "posts/2023-09-24-(코드) ggraph.html",
    "href": "posts/2023-09-24-(코드) ggraph.html",
    "title": "(코드) ggraph",
    "section": "",
    "text": "source(\"ggplot3.R\")\nlibrary(ggraph)\nlibrary(tidygraph)\n\n\nfigsize()"
  },
  {
    "objectID": "posts/2023-09-24-(코드) ggraph.html#imports",
    "href": "posts/2023-09-24-(코드) ggraph.html#imports",
    "title": "(코드) ggraph",
    "section": "",
    "text": "source(\"ggplot3.R\")\nlibrary(ggraph)\nlibrary(tidygraph)\n\n\nfigsize()"
  },
  {
    "objectID": "posts/2023-09-24-(코드) ggraph.html#example",
    "href": "posts/2023-09-24-(코드) ggraph.html#example",
    "title": "(코드) ggraph",
    "section": "2 Example",
    "text": "2 Example\n\nas_tbl_graph(highschool)\n\n\n# A tbl_graph: 70 nodes and 506 edges\n#\n# A directed multigraph with 1 component\n#\n# A tibble: 70 × 1\n  name \n  &lt;chr&gt;\n1 1    \n2 2    \n3 3    \n4 4    \n5 5    \n6 6    \n# ℹ 64 more rows\n#\n# A tibble: 506 × 3\n   from    to  year\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n1     1    13  1957\n2     1    14  1957\n3     1    20  1957\n# ℹ 503 more rows\n\n\n\n\n\n# Create graph of highschool friendships\ngraph &lt;- as_tbl_graph(highschool) %&gt;% \n    mutate(Popularity = centrality_degree(mode = 'in'))\n\n# plot using ggraph\nggraph(graph, layout = 'kk') + \n    geom_edge_fan(aes(alpha = after_stat(index)), show.legend = FALSE) + \n    geom_node_point(aes(size = Popularity)) + \n    facet_edges(~year) + \n    theme_graph(foreground = 'steelblue', fg_text_colour = 'white')"
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html",
    "href": "posts/2000-01-17-(메모) tmux.html",
    "title": "(메모) tmux",
    "section": "",
    "text": "tmux는 터미널 멀티플렉서로, 하나의 터미널 세션 내에서 여러 창을 열고, 각 창에서 여러 창 패널을 생성할 수 있게 해줍니다. 이는 특히 원격 서버에 접속하여 여러 작업을 병렬로 수행하거나, 세션을 종료해도 작업을 지속할 수 있는 상황에서 매우 유용합니다.\n아래는 tmux의 기본적인 사용 방법입니다."
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#tmux-시작하기",
    "href": "posts/2000-01-17-(메모) tmux.html#tmux-시작하기",
    "title": "(메모) tmux",
    "section": "1 tmux 시작하기",
    "text": "1 tmux 시작하기\ntmux\n이 명령어는 새 tmux 세션을 시작합니다."
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#새로운-세션-생성하기",
    "href": "posts/2000-01-17-(메모) tmux.html#새로운-세션-생성하기",
    "title": "(메모) tmux",
    "section": "2 새로운 세션 생성하기",
    "text": "2 새로운 세션 생성하기\n새로운 tmux 세션을 시작하면서 세션 이름을 지정할 수 있습니다:\ntmux new -s 세션이름"
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#tmux-세션-목록-보기",
    "href": "posts/2000-01-17-(메모) tmux.html#tmux-세션-목록-보기",
    "title": "(메모) tmux",
    "section": "3 tmux 세션 목록 보기",
    "text": "3 tmux 세션 목록 보기\n현재 실행 중인 tmux 세션을 보려면:\ntmux ls"
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#tmux-세션에-재접속하기",
    "href": "posts/2000-01-17-(메모) tmux.html#tmux-세션에-재접속하기",
    "title": "(메모) tmux",
    "section": "4 tmux 세션에 재접속하기",
    "text": "4 tmux 세션에 재접속하기\n특정 세션에 재접속하려면:\ntmux attach -t 세션이름"
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#tmux-세션에서-나가기",
    "href": "posts/2000-01-17-(메모) tmux.html#tmux-세션에서-나가기",
    "title": "(메모) tmux",
    "section": "5 tmux 세션에서 나가기",
    "text": "5 tmux 세션에서 나가기\n세션을 종료하지 않고 tmux에서 나가려면:\nCtrl+b, d\n위의 키 조합을 사용하면 세션은 백그라운드에서 계속 실행됩니다."
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#창-관리",
    "href": "posts/2000-01-17-(메모) tmux.html#창-관리",
    "title": "(메모) tmux",
    "section": "6 창 관리",
    "text": "6 창 관리\n\n새 창 생성: Ctrl+b, c\n창 사이 이동: Ctrl+b, 숫자 (예: Ctrl+b, 1)\n창 닫기: exit 또는 Ctrl+d\n창 목록 보기: Ctrl+b, w"
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#창-패널-관리",
    "href": "posts/2000-01-17-(메모) tmux.html#창-패널-관리",
    "title": "(메모) tmux",
    "section": "7 창 패널 관리",
    "text": "7 창 패널 관리\n\n패널 수직 분할: Ctrl+b, %\n패널 수평 분할: Ctrl+b, \"\n패널 간 전환: Ctrl+b, 화살표키 (또는 Ctrl+b, o)\n패널 닫기: exit 또는 Ctrl+d\n패널 크기 조절: Ctrl+b, 화살표키 (Ctrl을 누른 상태에서 화살표키로 조절)"
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#tmux-세션-종료",
    "href": "posts/2000-01-17-(메모) tmux.html#tmux-세션-종료",
    "title": "(메모) tmux",
    "section": "8 tmux 세션 종료",
    "text": "8 tmux 세션 종료\n세션을 완전히 종료하려면 모든 창과 패널을 닫거나, 다음 명령어를 입력합니다:\nexit"
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#tmux-설정",
    "href": "posts/2000-01-17-(메모) tmux.html#tmux-설정",
    "title": "(메모) tmux",
    "section": "9 tmux 설정",
    "text": "9 tmux 설정\n기본적으로 ~/.tmux.conf 파일을 만들어 tmux의 기본 동작을 커스터마이징할 수 있습니다. 예를 들어, tmux에서 사용되는 기본 키 바인딩을 변경하려면 이 파일에 관련 설정을 추가하면 됩니다."
  },
  {
    "objectID": "posts/2000-01-17-(메모) tmux.html#자주-사용하는-명령어-요약",
    "href": "posts/2000-01-17-(메모) tmux.html#자주-사용하는-명령어-요약",
    "title": "(메모) tmux",
    "section": "10 자주 사용하는 명령어 요약",
    "text": "10 자주 사용하는 명령어 요약\n\nCtrl+b, ?: tmux의 모든 단축키 보기\nCtrl+b, [: 복사 모드로 진입 (텍스트 스크롤 및 복사 가능)\nCtrl+b, d: 세션 분리 (detach)\nCtrl+b, :: 명령어 모드로 진입 (예: 세션 이름 변경 등)\n\n이러한 기본적인 사용법을 익히고 나면 tmux를 사용해 보다 효율적으로 터미널 작업을 수행할 수 있습니다. 추가적으로 tmux 플러그인 매니저(TPM)를 사용하여 다양한 플러그인을 설치하고 관리할 수도 있습니다."
  },
  {
    "objectID": "posts/2024-01-26-(공부) 조건부확률.html",
    "href": "posts/2024-01-26-(공부) 조건부확률.html",
    "title": "(공부) 조건부확률, 조건부기대값",
    "section": "",
    "text": "\\(\\mathbb{E}[Y|X]\\)의 의미를 알아보자."
  },
  {
    "objectID": "posts/2024-01-26-(공부) 조건부확률.html#엄밀하지-않은-정의",
    "href": "posts/2024-01-26-(공부) 조건부확률.html#엄밀하지-않은-정의",
    "title": "(공부) 조건부확률, 조건부기대값",
    "section": "1 엄밀하지 않은 정의",
    "text": "1 엄밀하지 않은 정의\n# 정의 – 조건부확률(이산형)\n\\[P(Y=y|X=x):=\\frac{P(X=x,Y=y)}{P(X=x)}\\]\n#\n# 정의 – 조건부pdf(이산형,연속형)\n\\[f_{2|1}(y|x):=\\frac{f_{1,2}(x,y)}{f_1(x)}\\]\n#\n- 함수 \\(f_{2|1}(y|x)\\) 와 \\(f_{2}(y)\\)는 모두 확률변수 \\(Y\\)의 pdf 조건을 만족한다는 것을 주의하자. 즉 아래가 성립한다.\n\n\\(\\int_{-\\infty}^{\\infty} f_{2}(y)dy=1\\)\n\\(\\int_{-\\infty}^{\\infty} f_{2|1}(y|x)dy=1\\)\n\n# 정의 – 조건부평균(연속형)\n\\[\\mathbb{E}[Y|X=x]:=\\int y f_{2|1}(y|x)dy \\]\n#\n# 정의할 수 없음 – \\(\\mathbb{E}(Y|X)\\)\n학부수준에서는 엄밀하게 정의할수는 없으며, 개념적으로 접근한다.\n\n\\(\\mathbb{E}(Y|X=x)\\)는 \\(x\\)의 값에 따라서 그 값이 바뀌는 함수로 해석할 수 있다.\n1을 다시 표현하면 \\(h(x):=\\mathbb{E}(Y|X=x)\\)를 만족하는 적당한 \\(h\\)가 있다는 의미.\n2번에서 정의된 \\(h\\)에 입력을 \\(x\\)가 아니라 \\(X\\)로 준다면 \\(h(X)\\)와 같은 확률 변수를 생각할 수 있음. 1\n3번과 같은 확률변수를 \\(\\mathbb{E}(Y|X)\\)로 정의하자는 의미\n\n학부수준에서는 이정도가 설명의 끝이며 \\(\\mathbb{E}(Y|X)\\)를 수식으로 명확하게 정의하진 않는다.\n#\n# 정의할 수 없음 – \\(\\mathbb{V}(Y|X)\\)\n\\(\\mathbb{E}(Y|X)\\)와 비슷한 방식으로 피해서 정의한다.\n#\n# 예제 – \\(\\mathbb{E}[\\mathbb{E}[Y|X]]=\\mathbb{E}[Y]\\) 의 증명 (\\(\\star\\))\n(풀이)\n헷갈리니까 아래와 같이 치환한다.\n\n\\(\\mathbb{E}[Y|X]=h(X)\\)\n\\(\\mathbb{E}[Y|X=x]=h(x)\\)\n\n그러면 좌변은 아래와 같이 된다.\n\n\\(\\mathbb{E}[h(X)]=\\int h(x) f_1(x)dx = \\int \\mathbb{E}[Y|X=x] f_1(x)dx\\)\n\n그런데 \\(\\mathbb{E}[Y|X=x]\\)는 조건부확률의 정의에 의하여 \\(\\mathbb{E}[Y|X=x]=\\int y f_{2|1}(y|x)dy\\) 이다. 이걸 그대로 넣으면\n\n\\(\\int \\mathbb{E}[Y|X=x] f_1(x)dx=\\int \\int y f_{2|1}(y|x)dy f_1(x)dx=\\int \\int y f_{2|1}(y|x)f_1(x)dydx\\)\n\n이제 조건부 pdf의 정의를 쓰면 \\(f_{2|1}(y|x)f_1(x)=f_{1,2}(x,y)\\)가 된다. 따라서\n\n\\(\\int \\int y f_{2|1}(y|x)f_1(x)dydx=\\int\\int y f_{1,2}(x,y)dydx\\)\n\n푸비니의 정리를 쓰면\n\n\\(\\int\\int y f_{1,2}(x,y)dydx=\\int\\int y f_{1,2}(x,y)dxdy\\)\n\n\\(y\\)를 밖으로 빼고 marginal pdf의 정의2를 이용하면\n\n\\(\\int\\int y f_{1,2}(x,y)dxdy=\\int y\\int f_{1,2}(x,y)dxdy=\\int y f_2(y)dy = \\mathbb{E}[y]\\)\n\n그래서 증명이 되었음."
  },
  {
    "objectID": "posts/2024-01-26-(공부) 조건부확률.html#엄밀한정의",
    "href": "posts/2024-01-26-(공부) 조건부확률.html#엄밀한정의",
    "title": "(공부) 조건부확률, 조건부기대값",
    "section": "2 엄밀한정의",
    "text": "2 엄밀한정의\n# 예제 - 주사위던지기\n- 아래와 같은 상황을 가정하자.\n\n\\(\\Omega = \\{1,2,3,\\dots,6\\}\\)\n\\({\\cal F} = 2^\\Omega\\)\n\\(P: {\\cal F} \\to [0,1]\\) such that \\(P(\\{\\omega\\})=\\frac{1}{6}\\).\n\n이제 \\((\\Omega, {\\cal F})\\) 위에서 아래와 같은 확률변수 \\(X: \\Omega \\to \\mathbb{R}\\)을 정의하자.\n\n\\(X(\\{1\\}) =1\\)\n\\(X(\\{2\\}) =2\\)\n\\(X(\\{3\\}) =3\\)\n\\(X(\\{4\\}) =4\\)\n\\(X(\\{5\\}) =5\\)\n\\(X(\\{6\\}) =6\\)\n\n여기까지는 익숙한 셋팅이며, 이럴때\n\n\\(X\\) is r.v. on \\((\\Omega, {\\cal F})\\)\n\\(X \\in {\\cal F}\\)\n\n와 같이 표현한다.\n- 이제 여기에서 아래와 같이 \\(\\Omega\\)를 disjoin한 \\(\\{B_i\\}\\)로 나누자.\n\n\\(B_1 = \\{1,2\\}\\)\n\\(B_2 = \\{3,4,5,6\\}\\)\n\n그리고 \\(B_1\\), \\(B_2\\)를 measurable하게 만드는 새로운 시그마필드 \\({\\cal F}^*=\\sigma(B_1,B_2)\\)를 아래와 같이 정의하자.\n\n\\({\\cal F}^* = \\{\\emptyset, B_1, B_2, \\Omega\\}\\)3\n\n이제 아래와 같은 \\(Y: \\Omega\\to\\mathbb{R}\\)를 고려하자.\n\n\\(Y(\\{1\\}) = 1.5\\)\n\\(Y(\\{2\\}) = 1.5\\)\n\\(Y(\\{3\\}) = 4.5\\)\n\\(Y(\\{4\\}) = 4.5\\)\n\\(Y(\\{5\\}) = 4.5\\)\n\\(Y(\\{6\\}) = 4.5\\)\n\n여기에서 \\(Y\\)는 \\((\\Omega, {\\cal F})\\) 에서의 확률변수이기도 하지만 \\((\\Omega, {\\cal F}^*)\\)에서의 확률변수이기도 하다. 즉\n\n\\(Y\\) is r.v. on \\((\\Omega, {\\cal F})\\)\n\\(Y \\in {\\cal F}\\)\n\\(Y\\) is r.v. on \\((\\Omega, {\\cal F}^*)\\)\n\\(Y \\in {\\cal F}^*\\)\n\n이다.4\n또 \\(Y\\)는 아래와 같은 특징이 있다.\n\n\\(\\forall A \\in {\\cal F}^*:~\\int_A X dP = \\int_A Y dP.\\)\n\n이것을 조금만 따져보자. \\(\\int_A X dP = \\int_\\Omega X \\mathbb{1}_A dP\\) 임을 이용하면,\n\ncase1: \\(A = \\emptyset \\Rightarrow 0=0\\):\ncase2: \\(A = B_1 \\Rightarrow \\frac{1+2+0+0+0+0}{6}=\\frac{1.5+1.5+0+0+0+0}{6}\\)\ncase3: \\(A = B_2 \\Rightarrow \\frac{0+0+3+4+5+6}{6}=\\frac{0+0+4.5+4.5+4.5+4.5}{6}\\)\ncase4: \\(A = \\Omega \\Rightarrow \\frac{1+2+3+4+5+6}{6}=\\frac{1.5+1.5+4.5+4.5+4.5+4.5}{6}\\)\n\n이다.\n- 이러한 조건을 만족하는 확률변수 \\(Y\\)를 conditional expectation of \\(X\\) given \\({\\cal F}^*\\)이라고 한다.5\n#\n# 정의 – [@klenke2013probability, Def 8.11] \\(X \\in {\\cal L}^1(\\Omega, {\\cal F}, P)\\) 이라고 하자. 6 그리고 \\({\\cal F}^*\\)는\n\n\\({\\cal F}^* \\subset {\\cal F}\\)\n\n을 만족하는 \\(\\Omega\\)에서의 시그마필드라고 하자. 확률변수 \\(Y\\) 가 아래를 만족한다고 하자.\n\n\\(Y \\in {\\cal F}^*\\)\n\\(\\forall A \\in {\\cal F}^*:~ \\int_A X dP = \\int_A Y dP\\)\n\n그러면 \\(Y\\)는 conditional expectation of \\(X\\) given \\({\\cal F}^*\\)라고 하고 기호로는\n\\[Y:=\\mathbb{E}[X|{\\cal F}^*]\\]\n로 표현한다.\n#\n- \\(Y\\)는 \\((\\Omega,{\\cal F}^*)\\)에서의 확률변수이기도 하지만 일단 \\(Y \\in (\\Omega, {\\cal F})\\) 이기도 하다. 가측공간 \\((\\Omega,{\\cal F}^*)\\) 에서는 적절한 확률측도를 정의한적이 없지만 \\((\\Omega,{\\cal F})\\) 에서는 확률측도 \\(P\\)가 이미 정의되어 있다. 이를 이용하여 아래를 계산해보자.\n\n\\(\\mathbb{E}[Y]=\\int Y dP\\)\n\n이것을 정리하면\n\n\\(\\frac{1.5+1.5+4.5+4.5+4.5+4.5}{6}\\)\n\n가 되어서 \\(\\mathbb{E}[X]\\)와 같다. 따라서\n\n\\(\\mathbb{E}[X] = \\mathbb{E}[\\mathbb{E}[X|{\\cal F}^*]]\\)\n\n이다. 여기에서 \\(\\mathbb{E}[X|{\\cal F}^*]\\)은 일단 그 자체로 하나의 기호라 생각하자.\n# Thm – [@klenke2013probability, Thm 8.12] \\(X \\in {\\cal L}^1(\\Omega, {\\cal F}, P)\\) 이라고 하자. 7 그리고 \\({\\cal F}^*\\)는\n\n\\({\\cal F}^* \\subset {\\cal F}\\)\n\n을 만족하는 \\(\\Omega\\)에서의 시그마필드라고 하자. 아래를 만족하는 확률변수 \\(Y\\)는 (\\(P\\)에 대하여) 거의 유일하게 존재한다.\n\n\\(Y \\in {\\cal F}^*\\)\n\\(\\forall A \\in {\\cal F}^*:~ \\int_A X dP = \\int_A Y dP\\)\n\n#\n# 정의 – [@klenke2013probability, Def 8.13] 아래와 같은 두 확률변수를 정의하자.\n\n\\(X\\) is rv on \\((\\Omega, {\\cal F})\\) with \\(\\int X dP &lt;\\infty\\).8\n\\(Y\\) is rv on \\((\\Omega, {\\cal F})\\).\n\n아래를 정의하자.\n\\[\\mathbb{E}[X|Y]:=\\mathbb{E}[X|\\sigma(Y)].\\]\n#"
  },
  {
    "objectID": "posts/2024-01-26-(공부) 조건부확률.html#footnotes",
    "href": "posts/2024-01-26-(공부) 조건부확률.html#footnotes",
    "title": "(공부) 조건부확률, 조건부기대값",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n\\(X\\)가 확률변수이면 \\(f(X)\\)역시 확률변수라고 배웠으니까↩︎\n\\(\\int f_{1,2}(x,y)dx = f_2(y)\\)↩︎\n당연히 \\({\\cal F}^* \\subset {\\cal F}\\)↩︎\n이렇게 보니까 \\({\\cal F}^* \\subset {\\cal F}\\) 임을 감안하면 \\(Y \\in {\\cal F}^* \\Rightarrow  Y \\in {\\cal F}\\) 임이 당연하게 느껴진다. \\(Y \\in {\\cal F}\\)와 같은 기호표현이 너무 이상하게 느껴졌는데, 여기에서 의문이 조금 풀리는 것 같음.↩︎\n조건부기대값이라고 번역하기는 조금 어색해서 원문그대로 외우는게 나은듯↩︎\n\\(X\\)가 \\((\\Omega, {\\cal F})\\)에서의 rv이고 \\(\\int_P XdP &lt;\\infty\\) 라는 의미↩︎\n\\(X\\)가 \\((\\Omega, {\\cal F})\\)에서의 rv이고 \\(\\int_P XdP &lt;\\infty\\) 라는 의미↩︎\n\\(X \\in {\\cal L}^1(\\Omega, {\\cal F}, P)\\) 이라는 의미↩︎"
  },
  {
    "objectID": "posts/2019-04-26-(공부) 퓨리에변환.html",
    "href": "posts/2019-04-26-(공부) 퓨리에변환.html",
    "title": "(공부) 퓨리에변환",
    "section": "",
    "text": "- 이번에는 퓨리에 표현들을 정리하도록 하겠다. 내생각엔 퓨리에 표현들도 벡터의 미분만큼 복잡한 것 같다. 정의가 너무 많고 그게 그거 같아서 그렇다. 이번기회에 깔끔하게 정리하도록 하자. 참고한 문헌은 아래와 같다.\n\nHaykin, S., & Van Veen, B. (2007). Signals and systems. John Wiley & Sons."
  },
  {
    "objectID": "posts/2019-04-26-(공부) 퓨리에변환.html#about-this-doc",
    "href": "posts/2019-04-26-(공부) 퓨리에변환.html#about-this-doc",
    "title": "(공부) 퓨리에변환",
    "section": "",
    "text": "- 이번에는 퓨리에 표현들을 정리하도록 하겠다. 내생각엔 퓨리에 표현들도 벡터의 미분만큼 복잡한 것 같다. 정의가 너무 많고 그게 그거 같아서 그렇다. 이번기회에 깔끔하게 정리하도록 하자. 참고한 문헌은 아래와 같다.\n\nHaykin, S., & Van Veen, B. (2007). Signals and systems. John Wiley & Sons."
  },
  {
    "objectID": "posts/2019-04-26-(공부) 퓨리에변환.html#들어가며",
    "href": "posts/2019-04-26-(공부) 퓨리에변환.html#들어가며",
    "title": "(공부) 퓨리에변환",
    "section": "2 들어가며",
    "text": "2 들어가며\n- 우선 신호와 하나의 신호값을 구분하는 notation을 생각하자. 우리가 다루는 신호 즉 데이터는 값들의 집합이다. 우리가 시계열자료를 다룬다면 데이터는 아래와 같이 표현한다.\n\n\\(\\{x_i: i \\in \\mathbb{Z}\\}\\)\n\n이와 유시하게 우리가 다루는 자료가 \\(t \\in \\mathbb{R}\\)인 연속신호라면 아래와 같이 표현한다.\n\n\\(\\{x(t): t \\in \\mathbb{R}\\}\\)\n\n우리가 모든 \\(i \\in \\mathbb{Z}\\) 혹은 모든 \\(t \\in \\mathbb{R}\\)에서 신호를 다룰 생각이 없다면 아래와 같은 표현도 얼마든지 가능하다.\n\n\\(\\{x_i: i=0,1,\\dots, \\xi-1 \\}\\)\n\\(\\{x(t):t \\in (0,\\zeta) \\}\\)\n\n- 위와 같이 집합의 표현 없이 단독으로 \\(x_i\\), \\(x(t)\\)와 같이 쓰면 하나의 고정된 값 \\(i,t\\)에 대한 \\(x_i\\), \\(x(t)\\)로 이해하자. 솔직히 이렇게 꼭 신호를 엄밀하게 집합으로 정의하는게 유별나 보일수도 있다. 일반적으로 사람들은 \\(\\{x(t): ~t \\in \\mathbb{R} \\}\\) 대신에 보통 \\(x(t)\\)로 간단하게 줄여서 쓰곤한다.1 하지만 이 포스팅에 한정하여 위와 같이 집합의 형태로 엄밀하게 구분해 쓰도록 하자. 처음에는 익숙하지 않지만 나중에는 편리하다."
  },
  {
    "objectID": "posts/2019-04-26-(공부) 퓨리에변환.html#퓨리에표현들",
    "href": "posts/2019-04-26-(공부) 퓨리에변환.html#퓨리에표현들",
    "title": "(공부) 퓨리에변환",
    "section": "3 퓨리에표현들",
    "text": "3 퓨리에표현들\n- 지금부터 우리가 고려하는 모든 신호들은 기본적으로 (1) infinity range에서 정의된 신호라고 가정한다. 즉 연속신호이면 \\(\\mathbb{R}\\)에서 정의된다고 가정하고 이산신호면 \\(\\mathbb{Z}\\)에서 정의된다고 가정한다. 또한 우리가 분석하고자 하는 신호는 (2) integrable 하다고 가정한다. 이건 퓨리에표현들이 적분 혹은 무한합의 형태로 표현된다는 것을 상기하면 타당하여 보인다.\n- 즉 우리가 고려하는 신호는 인피니티-레인지에서 정의되며 인피니티-레인지에서 적분값이 유한한 연속신호 혹은 이산신호 임을 알 수 있다. 이러한 신호는 구체적으로는 아래와 같이 쓸 수 있다.\n\n\\(\\left\\{x(t): \\int_{-\\infty}^{\\infty} |x(t)| dt &lt;\\infty,~ t \\in \\mathbb{R} \\right\\}\\)\n\\(\\left\\{x_i: \\sum_{i=-\\infty}^{\\infty} |x_i| &lt;\\infty,~ i \\in \\mathbb{Z} \\right\\}\\)\n\n- 그런데 integrable 한 함수들만을 고려하다 보면 우리가 다룰 수 있는 신호의 범위가 확 줄어들게 된다. 가령 예를 들어서 아래와 같은 신호는 적분을 하면 무한대가 나오기 때문에 intergrable 하지 않다.\n\n\\(\\left\\{x(t): x(t)=\\sin(t)+1 ,~ t \\in \\mathbb{R} \\right\\}\\)\n\n이것은 좀 불합리해 보이는데 위의 신호는 주기신호라서 한 주기의 패턴만 분석하면 될것 같이 보이기 때문이다. 위의 신호는 intergrable 하지않지만 아래의 신호는 intergrable 하다.\n\n\\(\\left\\{x(t): x(t)=\\sin(t)+1 ,~ t \\in (0,2\\pi) \\right\\}\\)\n\n우리는 이런신호까지 분석하기로 한다. 이런신호를 분석할 수 있는 이유는 해석학 교재를 참고하면 된다.2\n- 아무튼 우리는 (1) 인피니티-레인지에서 정의되는 가지는 신호 (2) 인피니티-레인지에서 적분값이 잘 정의되는 신호, 혹은 한 주기만 적분해 보았을때 그 값이 잘 정의되는 주기신호 를 타겟팅해 분석한다. 즉 분석하는 신호는 구체적으로 아래의 4가지이다.\ncase 1: 연속/비주기\n\\(\\left\\{x(t): \\int_{-\\infty}^{\\infty} |x(t)| dt &lt;\\infty,~ t \\in \\mathbb{R} \\right\\}.\\)\ncase 2: 연속/주기\n\\(\\left\\{x(t): \\int_{0}^{\\zeta} |x(t)| dt &lt;\\infty, ~ , x(t)=x(t+\\zeta), ~ t \\in \\mathbb{R},  \\right\\}.\\)\ncase 3: 이산/비주기(=이산/무한)\n\\(\\left\\{x_i: \\sum_{i=-\\infty}^{\\infty} |x_i| &lt;\\infty,~ i \\in \\mathbb{Z} \\right\\}.\\)\ncase 4: 이산/주기(=이산/유한)\n\\(\\left\\{x_i: \\sum_{i=0}^{\\xi-1} |x_i| &lt;\\infty,~ i, x_i=x_{i+\\xi},~ i \\in \\mathbb{Z} \\right\\}.\\)\n- 표현들을 정리하기에 앞서서 몇 가지 알아두어야 할 사항이 있다. (1) 시간축에서 연속인 신호는 주파수측에서는 비주기신호가 나온다. (2) 시간축에서 디스크릿한 신호는 주파수측에서는 주기신호이다. (3) 시간축에서 주기인 신호는 주파수에서는 디스크릿하다. (4) 시간축에서 비주기신호는 주파수에서 연속이다. 이 사실들을 종합하면 각각의 경우에 해당하는 퓨리에 표현들은 아래와 같은 특징을 가지고 있음을 알 수 있다.\ncase 1: 연속/비주기 \\(\\star\\)\n\\(\\left\\{x(t): \\int_{-\\infty}^{\\infty} |x(t)| dt &lt;\\infty,~ t \\in \\mathbb{R} \\right\\}\\) – 시간\n\\(\\quad \\overset{FT}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x(\\omega): \\int_{-\\infty}^{\\infty} |\\hat x(\\omega)| d\\omega &lt;\\infty,~ \\omega \\in \\mathbb{R} \\right\\}\\) – 주파수\ncase 2: 연속/주기\n\\(\\left\\{x(t): \\int_{0}^{\\zeta} |x(t)| dt &lt;\\infty,~ x(t)=x(t+\\zeta),~ t \\in \\mathbb{R} \\right\\}\\) – 시간\n\\(\\quad \\overset{FS}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x_k: \\sum_{k=-\\infty}^{\\infty} |\\hat x_k| &lt;\\infty,~ k \\in \\mathbb{Z} \\right\\}\\) – 주파수\ncase 3: 이산/비주기(=이산/무한)\n\\(\\left\\{x_i: \\sum_{i=-\\infty}^{\\infty} |x_i| &lt;\\infty,~ i \\in \\mathbb{Z} \\right\\}\\)\n\\(\\quad \\overset{DTFT}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x(\\omega): \\int_{0}^{2\\pi} |\\hat x(\\omega)| d\\omega &lt;\\infty,~ \\hat x(\\omega)=\\hat x(\\omega+2\\pi),~  \\omega \\in \\mathbb{R} \\right\\}\\)\ncase 4: 이산/주기(=이산/유한) \\(\\star\\)\n\\(\\left\\{x_i: \\sum_{i=0}^{\\xi-1} |x_i| &lt;\\infty,~ x_i=x_{i+\\xi},~ i \\in \\mathbb{R} \\right\\}\\)\n\\(\\quad \\overset{DTFS}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x_k: \\sum_{k=0}^{\\xi-1} |\\hat x_k| &lt;\\infty,~\\hat x_k = \\hat x_{k+\\xi} ,~ k \\in \\mathbb{Z} \\right\\}\\)\n- 여기에서 \\(\\zeta\\)는 (시간축에서) 연속신호의 주기라고 정의하고 \\(\\xi\\)는 (시간축에서) 이산신호의 주기라고 약속하자. 주파수영역이 디스크릿하게 나오면 FS라고 부르고 주파수영역이 컨티뉴어스하게 나오면 FT라고 부른다. 특이한점은 비주기-이산신호에 대한 FS \\(\\hat x(\\omega)\\)는 주파수 영역에서 주기가 \\(2\\pi\\)임을 파악할 수 있다. 이유는 궁금해하지말자. (내생각에 그냥 \\(\\omega\\)를 적당히 스케일링하여 주기를 \\(2\\pi\\)로 맞췄을 거다.)\n- 이제 짜증나는 적분가능조건따위는 버리도록 하자. 대신에 각 경우에 퓨리에변환(혹은series)과 그 역이 어떻게 정의되는지 알아보자. 그리고 외우자. 각 신호가 어떠한 도메인에서 정의되는지만 잘 파악하면 의외로 외우기 쉽다.\ncase 1. 연속/비주기 \\(\\star\\star\\star\\)\n\\(\\left\\{x(t): x(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} \\hat x(\\omega)e^{j\\omega t} d\\omega,~ t \\in \\mathbb{R} \\right\\}\\)\n\\(\\quad \\overset{FT}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x(\\omega): \\hat x(\\omega)=\\int_{-\\infty}^{\\infty} x(t)e^{-j\\omega t} dt,~ \\omega \\in \\mathbb{R} \\right\\}\\)\ncase 2. 연속/주기\n\\(\\left\\{x(t): x(t)= \\sum_{k=-\\infty}^{\\infty} \\hat x_k e^{j \\frac{2\\pi}{\\zeta} t} ,~ t \\in \\mathbb{R} \\right\\}\\)\n\\(\\quad \\overset{FS}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x_k: \\hat x_k= \\frac{1}{\\zeta}\\int_{0}^{\\zeta}x(t)e^{-j \\frac{2\\pi k}{\\zeta}t}dt,~ k \\in \\mathbb{Z} \\right\\}\\)\ncase 3. 이산/비주기(=이산/무한)\n\\(\\left\\{x_i:  x_i=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}\\hat x(\\omega)e^{j \\omega i}d\\omega, ~ i \\in \\mathbb{Z} \\right\\}\\)\n\\(\\quad \\overset{DTFT}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x(\\omega): \\hat x(\\omega)=\\sum_{i=-\\infty}^{\\infty}x_ie^{-j\\omega i}, ~\\omega \\in \\mathbb{R} \\right\\}\\)\ncase 4. 이산/주기(=이산/유한) \\(\\star\\star\\star\\)\n\\(\\left\\{x_i: x_i=\\sum_{k=0}^{\\xi-1} \\hat x_k e^{-j\\frac{2\\pi k}{\\xi}i},~ i \\in \\mathbb{Z} \\right\\}\\)\n\\(\\quad \\overset{DTFS}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x_k: \\hat x_k= \\frac{1}{\\xi}\\sum_{i=0}^{\\xi-1} x_i e^{-j\\frac{2\\pi k}{\\xi}i},~ k \\in \\mathbb{Z} \\right\\}\\)\n- 주기함수는 (그것이 이산이든 연속이든) 주파수영역에서의 값이 디스크릿하다. 즉 위에서 case2와 case4인 경우는 주파수영역에서 값이 디스크릿하다. 이것을 연속함수인것처럼 바꿔보면 아래와 같이 쓸 수 있다.\ncase 2. 연속/주기\n\\(\\left\\{x(t): x(t)= \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} \\hat x(\\omega)e^{j\\omega t} d\\omega,~ t \\in \\mathbb{R} \\right\\}\\)\n\\(\\quad \\overset{FT}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x(\\omega): 2\\pi\\sum_{k=-\\infty}^{\\infty}\\left[\\frac{1}{\\zeta}\\int_{0}^{\\zeta}x(t)e^{-j \\frac{2\\pi k}{\\zeta}t}dt\\right]\\delta\\left(\\omega-\\frac{2\\pi k}{\\zeta}\\right), ~ k \\in \\mathbb{Z} \\right\\}\\)\ncase 4. 이산/주기(=이산/유한)\n\\(\\left\\{x_i: x_i=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}\\hat x(\\omega)e^{j \\omega i}d\\omega,,~ i \\in \\mathbb{Z} \\right\\}\\)\n\\(\\quad\\overset{DTFT}{\\Longleftrightarrow}\\)\n\\(\\left\\{\\hat x(\\omega): 2\\pi\\sum_{k=-\\infty}^{\\infty}\\left[\\frac{1}{\\xi}\\sum_{i=0}^{\\xi-1} x_i e^{-j\\frac{2\\pi k}{\\xi}i}\\right]\\delta\\left(\\omega-\\frac{2\\pi k}{\\xi}\\right),~ k \\in \\mathbb{Z} \\right\\}\\)\n- 주목할것은 주기가 \\(\\zeta\\) 혹은 \\(\\xi\\) 인 함수의 주파수 응답은 오로지\n\n\\(\\omega \\in \\left\\{\\frac{2 \\pi k}{\\zeta}, k \\in \\mathbb{Z}\\right\\}\\)\n\n혹은\n\n\\(\\omega \\in \\left\\{\\frac{2 \\pi k}{\\xi}, k \\in \\mathbb{Z}\\right\\}\\)\n\n에서만 존재한다는 점이다. 또한 이산신호의 경우 \\(x_i\\)의 주기가 \\(\\xi\\) 이면 \\(\\hat{x}(\\omega)\\)의 주기역시 \\(\\xi\\) 라는점 역시 주목할만한 부분이다.\n- 주파수영역에서 디스크릿한 함수를 연속인것처럼 표현했듯이 시간영역에서 디스크릿한 함수 역시 연속인것처럼 표현할 수 있다. 예를들면 \\(\\{x_i: x_i=x(iT),~i \\in \\mathbb{Z}\\}\\) 와 같은 관계가 있는 경우 아래와 같이 표현 가능하다.\n\\[x_{\\delta}(t)=\\sum_{i=-\\infty}^{\\infty}x_i\\delta(t-iT).\\]\n이거 엄청 중요하다."
  },
  {
    "objectID": "posts/2019-04-26-(공부) 퓨리에변환.html#footnotes",
    "href": "posts/2019-04-26-(공부) 퓨리에변환.html#footnotes",
    "title": "(공부) 퓨리에변환",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n나도 그렇다.↩︎\n사실 나도 잘 모름 (뭐 quotient group이런거 알아야 하는데 공부하려면 꽤 걸릴듯)↩︎"
  },
  {
    "objectID": "posts/2023-10-25-(공부) Julia -- 문자와 문자열.html",
    "href": "posts/2023-10-25-(공부) Julia -- 문자와 문자열.html",
    "title": "(공부) Julia – 문자와 문자열",
    "section": "",
    "text": "- 선언 및 자료형\n\n'B' # 선언 \n\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n\n\n\ntypeof('b') # 자료형\n\nChar\n\n\n\n\n\n- 선언 및 자료형\n\n\"A\" # 선언\n\n\"A\"\n\n\n\ntypeof(\"A\") # 자료형\n\nString\n\n\n\n\n\n- \"a\"와 'a'의 차이\n\n'a' # 단일문자\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\"a\" # 문자열\n\n\"a\"\n\n\n\n\"a\"[1] # 'a'와 같음\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)"
  },
  {
    "objectID": "posts/2023-10-25-(공부) Julia -- 문자와 문자열.html#문자와-문자열의-차이",
    "href": "posts/2023-10-25-(공부) Julia -- 문자와 문자열.html#문자와-문자열의-차이",
    "title": "(공부) Julia – 문자와 문자열",
    "section": "",
    "text": "- 선언 및 자료형\n\n'B' # 선언 \n\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n\n\n\ntypeof('b') # 자료형\n\nChar\n\n\n\n\n\n- 선언 및 자료형\n\n\"A\" # 선언\n\n\"A\"\n\n\n\ntypeof(\"A\") # 자료형\n\nString\n\n\n\n\n\n- \"a\"와 'a'의 차이\n\n'a' # 단일문자\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\"a\" # 문자열\n\n\"a\"\n\n\n\n\"a\"[1] # 'a'와 같음\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)"
  },
  {
    "objectID": "posts/2023-10-25-(공부) Julia -- 문자와 문자열.html#문자문자열-관련-기능",
    "href": "posts/2023-10-25-(공부) Julia -- 문자와 문자열.html#문자문자열-관련-기능",
    "title": "(공부) Julia – 문자와 문자열",
    "section": "2 문자/문자열 관련 기능",
    "text": "2 문자/문자열 관련 기능\n\n2.1 문자 관련 기능\n- isuppercase: 대소문자 판단\n\nisuppercase('a'), islowercase('a')\n\n(false, true)\n\n\n\nisuppercase('A'), islowercase('A')\n\n(true, false)\n\n\n\n\n2.2 문자열 관련 기능\n- 문자열 슬라이싱\n\nstr = \"Jeonbuk National University\"\nstr[end-1:end]\n\n\"ty\"\n\n\n- 문자열의 결합\n\n\"a\"*\"b\"\n\n\"ab\"\n\n\n- 문자열의 반복\n\n\"a\"^5\n\n\"aaaaa\"\n\n\n\nrepeat(\"a\",5)\n\n\"aaaaa\"\n\n\n- 문자열 끼워넣기\n\nname = \"최규빈\"\n\"제 이름은 $name 입니다\"\n\n\"제 이름은 최규빈 입니다\"\n\n\n- 문자열 바꾸기\n\nstr = \"abcdefg\"\nreplace(str, \"g\" =&gt; \"u\")\n\n\"abcdefu\"\n\n\n- 문자열 나누기\n\nstr = \"2023-08\"\nsplit(str,\"-\")\n\n2-element Vector{SubString{String}}:\n \"2023\"\n \"08\"\n\n\n- 문자열 합치기\n\njoin([\"2023\",\"08\"],\"-\")\n\n\"2023-08\"\n\n\n\njoin([\"2023\",\"08\"])\n\n\"202308\"\n\n\n- lowercase: 대문자를 소문자로 바꾸는 방법\n\nstr = \"HELLO, JULIA!\"\nlowercase(str)\n\n\"hello, julia!\""
  },
  {
    "objectID": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html",
    "href": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html",
    "title": "(메모) 줄리아 설치 및 실행",
    "section": "",
    "text": "- 여기에 접속한다. 스크롤링하여 ’Generic Linux Binaries for x86 / 64-bit(GPG)’를 찾는다. 그리고 ’64-bit’를 클릭해서 다운받는다. (참고로 왼쪽에 ’help’를 누르면 설치페이지 설명서가 나온다.) 그러면 아래와 같은 파일이 나온다.\njulia-1.3.1-linux-x86_64.tar.gz\n이 파일을 더블클릭해서 압축을 풀어준다. 압축을 풀면 julia-1.3.1라는 폴더가 생긴다. 이 폴더를 원하는 위치로 (줄리아가 설치되기를 원하는 위치) 이동시킨다. 나는 home에 이동시켰다.\n- 아래를 실행하면 줄리아가 실행된다. (둘중 아무거나)\n/home/cgb/julia-1.3.1/bin/julia\n~/julia-1.3.1/bin/julia"
  },
  {
    "objectID": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#설치",
    "href": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#설치",
    "title": "(메모) 줄리아 설치 및 실행",
    "section": "",
    "text": "- 여기에 접속한다. 스크롤링하여 ’Generic Linux Binaries for x86 / 64-bit(GPG)’를 찾는다. 그리고 ’64-bit’를 클릭해서 다운받는다. (참고로 왼쪽에 ’help’를 누르면 설치페이지 설명서가 나온다.) 그러면 아래와 같은 파일이 나온다.\njulia-1.3.1-linux-x86_64.tar.gz\n이 파일을 더블클릭해서 압축을 풀어준다. 압축을 풀면 julia-1.3.1라는 폴더가 생긴다. 이 폴더를 원하는 위치로 (줄리아가 설치되기를 원하는 위치) 이동시킨다. 나는 home에 이동시켰다.\n- 아래를 실행하면 줄리아가 실행된다. (둘중 아무거나)\n/home/cgb/julia-1.3.1/bin/julia\n~/julia-1.3.1/bin/julia"
  },
  {
    "objectID": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#주피터와-연결",
    "href": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#주피터와-연결",
    "title": "(메모) 줄리아 설치 및 실행",
    "section": "2 주피터와 연결",
    "text": "2 주피터와 연결\n- 아래중 하나를 실행하여 줄리아를 킨다.\n/home/cgb/julia-1.3.1/bin/julia\n~/julia-1.3.1/bin/julia\n- 줄리아를 실행한뒤에 아래를 입력하면 주피터노트북에 연결된다.\nusing Pkg\nPkg.add(\"IJulia\")\n- 한 가지 의문점이 있다. 나같은 경우는 ’(base)’에서 줄리아를 실행하고 연결하였다. 그런데 혹시 몰라서 (py38r40)에서도 줄리아를 실행해봤는데 잘 실행되었다. 줄리아를 실행시키고 위의 명령 Pkg.add(\"IJulia\")를 다시쳤는데, 이미 연결되어서 더이상 변화시킨게 없다는 메시지가 떴다. 이러면 (base)에 설치된 줄리아가 (py38r40)에서도 실행된 줄리아와 동일하다는 의미일까? \\(\\Longrightarrow\\) 그렇다. 왜냐하면 줄리아는 anaconda내의 폴더에 설치한 것이 아니기 때문에. home에 보통 설치하니깐."
  },
  {
    "objectID": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#환경변수-조정",
    "href": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#환경변수-조정",
    "title": "(메모) 줄리아 설치 및 실행",
    "section": "3 환경변수 조정",
    "text": "3 환경변수 조정\n- 참고로 어디서든 줄리아를 실행시키고 싶다면 환경변수를 조작하면 된다. 아래를 실행해서 나노에디터를 킨다.\nsudo nano /etc/environment\n맨끝에 다음과 같이 되어있을 것이다.\n~~ usr/local/games\"\n마지막에 /home/cgb/julia-1.3.1/bin/julia를 추가한다. 즉 아래와 같이 만든다.\n~~ usr/local/games:/home/cgb/julia-1.3.1/bin/julia\"\n세이브하고 나온다. (그런데 이 과정을 안거쳐도 되는것 같음.) 이제 커맨드에서 아래를 실행한다.\nexport PATH=$PATH:/home/cgb/julia-1.3.1/bin\n이렇게하면 이제 단순히 julia라고만 쳐도 julia가 실행된다."
  },
  {
    "objectID": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#플루토에서-강의영상-넣는-방법",
    "href": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#플루토에서-강의영상-넣는-방법",
    "title": "(메모) 줄리아 설치 및 실행",
    "section": "4 플루토에서 강의영상 넣는 방법",
    "text": "4 플루토에서 강의영상 넣는 방법\n- 아래를 삽입\nhtml\"\"\"\n&lt;div style=\"display: flex; justify-content: center;\"&gt;\n&lt;div  notthestyle=\"position: relative; right: 0; top: 0; z-index: 300;\"&gt;\n&lt;iframe src=\n\"\nhttps://www.youtube.com/embed/\n\"\nwidth=600 height=375  frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\""
  },
  {
    "objectID": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#플루토를-이용한-홈페이지-만드는-방법",
    "href": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#플루토를-이용한-홈페이지-만드는-방법",
    "title": "(메모) 줄리아 설치 및 실행",
    "section": "5 플루토를 이용한 홈페이지 만드는 방법",
    "text": "5 플루토를 이용한 홈페이지 만드는 방법\n- 단계1: https://github.com/JuliaPluto/static-export-template 에 가서 Clone\n- 단계2: Setting -&gt; GitHub Pages -&gt; Source -&gt; gh-pages / root"
  },
  {
    "objectID": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#플루토-키는-방법",
    "href": "posts/2000-01-07-(메모) 줄리아 설치 및 실행.html#플루토-키는-방법",
    "title": "(메모) 줄리아 설치 및 실행",
    "section": "6 플루토 키는 방법",
    "text": "6 플루토 키는 방법\nimport Pluto\nPluto.run(host=\"0.0.0.0\",port=1234,launch_browser=false,require_secret_for_open_links=false,require_secret_for_access=false,threads=\"8\")"
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html",
    "href": "posts/2023-07-04-(공부) 토폴로지.html",
    "title": "(공부) 토폴로지",
    "section": "",
    "text": "- 수학공부\n- 학부수준\n- 이 문서는 논문을 읽을때 등장하는 topology 용어들을 좀더 명확하게 이해하고 싶어서 작성하였다. 가볍게 정의만 훑어보는 것이라 깊게 들어가지는 않을 예정이다. 교재는 Schaum’s General Topology 를 참고하였다. - Lipschutz, S. (1965). Schaum’s outline of theory and problems of general topology. Schaum’s Outline Series.\n- 여기에서는 토폴로지의 정의와 메트릭스페이스의 정의 그리고 컴플리션의 정의에 대하여 다룬다."
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html#about-this-doc",
    "href": "posts/2023-07-04-(공부) 토폴로지.html#about-this-doc",
    "title": "(공부) 토폴로지",
    "section": "",
    "text": "- 수학공부\n- 학부수준\n- 이 문서는 논문을 읽을때 등장하는 topology 용어들을 좀더 명확하게 이해하고 싶어서 작성하였다. 가볍게 정의만 훑어보는 것이라 깊게 들어가지는 않을 예정이다. 교재는 Schaum’s General Topology 를 참고하였다. - Lipschutz, S. (1965). Schaum’s outline of theory and problems of general topology. Schaum’s Outline Series.\n- 여기에서는 토폴로지의 정의와 메트릭스페이스의 정의 그리고 컴플리션의 정의에 대하여 다룬다."
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html#chap-5-토폴로지",
    "href": "posts/2023-07-04-(공부) 토폴로지.html#chap-5-토폴로지",
    "title": "(공부) 토폴로지",
    "section": "2 Chap 5: 토폴로지",
    "text": "2 Chap 5: 토폴로지\n- (@lipschutz1965schaum, p.66) \\({\\cal T}\\) 가 \\(X\\) 의 subset 으로 이루어진 collection 이라고 하자. \\({\\cal T}\\) 가 \\(X\\) 를 포함하며 uncountable union 에 닫혀있고 finite intersection 에 닫혀있다면 \\({\\cal T}\\) 를 \\(X\\) 의 topology 라고 한다. 그리고 \\((X,{\\cal T})\\) 를 topological space 라고 한다. \\({\\cal T}\\) 가 \\(X\\)의 토플로지일때 \\({\\cal T}\\) 의 원소를 \\({\\cal T}\\)-open set 이라고 한다. 따라서 원래 오픈셋은 마치 확률변수처럼 단독으로 정의할 수 없고 어떠한 토폴로지 \\({\\cal T}\\)와 같이 정의된다.\n- (@lipschutz1965schaum, p.66) 아래와 같은 collection 을 생각하자.\n\\[{\\cal O}:=\\{O: O=\\cup_i(a_i,b_i), a_i,b_i \\in \\mathbb{R} \\} \\]\n컬렉션 \\({\\cal O}\\) 는 \\(\\mathbb{R}\\) 의 토폴로지가 된다. (증명은 알아서..) 이러한 토폴로지(=오픈인터벌의 카운터블-유니온으로 표현가능한 집합들의 모임)을 특별히 usual topology 라고 한다. 그리고 이 토폴로지의 원소를 \\({\\cal O}\\)-오픈셋이라고 부른다. 따라서 어떤 집합 \\(O\\) 가 \\({\\cal O}\\)-오픈셋 이라는 말은 그 집합이 오픈인터벌의 카운터블-유니온으로 표현가능한 집합임을 의미한다.\n- 참고로 \\({\\cal O}\\) 가 우리가 일반적으로 생각하는 ‘오픈셋들의 모임’ 이고 \\({\\cal O}\\)-오픈셋이 보통 우리가 일반적으로 유클리드 공간에서 상상하는 오픈셋이다. 그래서 앞으로 특별한 언급없이 그냥 ‘오픈셋’ 이라고 부르면 토폴로지 \\((\\mathbb{R},{\\cal O})\\) 에서 정의가능한 ‘\\({\\cal O}\\)-오픈셋’ 을 의미하는 것이라고 생각하면 된다.\n- 즉 우리가 일반적으로 생각하는 오픈셋1은 오픈인터벌 \\((a,b)\\) 의 countable-many union 으로 표현가능한 집합이라고 이해해도 된다.\n- 오픈셋 \\(O\\)의 원소를 interior point of \\(O\\) 라고 한다. \\({\\cal O}\\)의 정의에 의해서 인테리어포인트는 모두 아래의 성질을 만족한다.\n\\[\\forall o \\in O ~ \\exists a,b \\in \\mathbb{R}~ st.~  o \\in (a,b)\\]\n증명은 귀류법을 쓰면 쉽게 된다.\n- 저 정리가 생각보다 중요하다. 그리고 이 정리를 나이테정리 라고 기억하자. 이 정리는 \\({\\cal O}\\)-오픈셋이 아닌 일반적인 \\({\\cal T}\\)-오픈셋에 대하여서도 성립한다. 즉 \\((X,{\\cal T})\\)가 위상공간이고 \\(T\\)가 \\({\\cal T}\\)의 임의의 집합이라 하자. \\(T\\)의 임의의 원소 \\(p\\)에 대하여 (1) \\(p\\) 를 포함하지만 (2) \\(T\\) 보다 작은 다른 \\({\\cal T}\\)-오픈셋이 항상 존재한다.\n- 그리고 교재에 따라서는 위와 같은 성질을 만족하는 것을 오픈셋이라고 정의하기도 한다. 이와 같은 논리흐름으로는 오픈인터벌 \\((a,b)\\)를 정의하고 그로부터 인테리어포인트 \\(o\\)와 오픈셋 \\(O\\)를 정의하고 그로부터 토폴로지 \\({\\cal O}\\)를 정의할 수 있다. 하지만 이러한 방식의 contruction 으로는 \\((\\mathbb{R},{\\cal O})\\) 만 만들수있다. 일반적으로는 적당한 \\({\\cal T}\\)가 \\(X\\)의 토폴로지임을 밝히고 그로부터 오픈셋을 정의하고 그 다음 인테리어포인트를 정의하는 식으로 각 요소들을 contruction 한다.\n- 오픈셋의 여집합을 클로즈드셋이라고 한다. 여기서 사람들이 “모든 집합은 오픈셋이거나 클로즈드셋 이어야 한다” 라고 착각하기 쉬운데 사실 그런것은 아니다.\n- 어떠한 construction을 사용하든지 아래의 사실들이 성립한다. 따로 설명을 쓰지 않은 것은 아주 약간의 머리를 쓰면 쉽게 증명할 수 있는 것들이다. (하지만 그냥 받아들이거나 외우는 것이 편하다.) 참고로 아래의 모든 사실들은 보통위상공간 즉 \\((\\mathbb{R},{\\cal O})\\) 를 전제하고 서술한 것이다.\n(1) \\((a,b)\\) 는 오픈셋이다.\n(2) \\(\\mathbb{R}\\) 은 오픈셋이다. 동시에 클로즈드셋이다2.\n(3) \\(\\emptyset\\) 은 오픈셋이다. 동시에 클로즈드셋이다3.\n(4) 오픈셋은 uncountable union 에 닫혀있다. 즉 \\(O_t\\)가 각각 오픈셋일때 \\(\\cup_t O_t\\) 역시 오픈셋이다.\n(5) 오픈셋은 finite intersection 에 닫혀있다. 즉 \\(O_i\\)가 각각 오픈셋이면 \\(\\cap_{i=1}^{n} O_i\\) 역시 오픈셋이다\n(6) 한점 \\(p\\)로 이루어진 집합 \\(\\{p\\}\\)는 오픈셋이 아니다. 이것이 오픈셋이 되려면 \\(\\{p\\}\\)의 모든원소(라고 해봤자 \\(p\\) 밖에 없음)가 내점이어야 하고 \\(p\\)가 \\(\\{p\\}\\)의 내점이려면 \\(p\\)를 포함하는 오픈인터벌 \\((a,b)\\)가 \\(\\{p\\}\\)의 부분집합으로 존재해야하는데 이것이 불가능하기 때문이다. 4\n(7) 오픈셋의 countable-many intersection 은 오픈셋이 아니다. 왜냐하면 \\(\\cap_{n=1}^{\\infty}(-1/n,1/n)=\\{0\\}\\) 인데 \\(\\{0\\}\\)은 오픈셋이 아니기 때문이다.\n- (@lipschutz1965schaum, p. 69) 위상공간 \\((X,{\\cal T})\\) 를 상상하자. \\(X\\)의 부분집합 \\(A\\)를 상상하자. “집합 \\(A\\)가 \\(X\\)에서 dense 하다” 라는 의미는 \\(\\bar{A}=X\\)라는 의미이다. 가장 빈번하게 사용하는 표현은 “유리수집합 \\(\\mathbb{Q}\\)는 실수 \\(\\mathbb{R}\\)에서 dense 하다” 인데 이것은\\(\\bar{\\mathbb{Q}}=\\mathbb{R}\\)이 성립하기 때문이다 (예제 4.3)."
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html#chap-6-기저",
    "href": "posts/2023-07-04-(공부) 토폴로지.html#chap-6-기저",
    "title": "(공부) 토폴로지",
    "section": "3 Chap 6: 기저",
    "text": "3 Chap 6: 기저\n- 오픈인터벌 \\((a,b)\\)를 적당히 countable-many union 하면 \\(\\mathbb{R}\\) 에 존재하는 어떠한 오픈셋 \\(O\\)도 표현할 수 있다. 이럴때 \\((a,b)\\) 모아놓은 collection \\({\\cal B}:=\\{(a,b): a&lt;b \\in \\mathbb{R}\\}\\) 를 토폴로지 \\({\\cal O}\\)의 base 라고 한다. 이처럼 어떠한 위상공간 \\((X,{\\cal T})\\) 가 있을때 토폴로지 \\({\\cal T}\\) 의 임의의 집합을 \\({\\cal B}\\)의 원소들의 uncountable union 으로 표현가능때 \\({\\cal B}\\)를 \\({\\cal T}\\)의 base 라고 한다. 그리고 추가적으로 base의 모든 원소는 \\({\\cal T}\\)-오픈셋이어야 한다는 조건도 포함된다.\n- 토폴로지 \\({\\cal T}\\)의 base는 유일하지 않다.\n- 아래와 같은 collection을 상상하여 보자.\n\\[\\tilde{\\cal B}:=\\{all~ ray~ in~\\mathbb{R} \\} := \\{(-\\infty,b): b\\in \\mathbb{R} \\} \\cup \\{(a,\\infty): a \\in \\mathbb{R}\\}\\]\n보는 것처럼 \\(\\tilde{\\cal B}\\)는 위상의 정의를 만족한다. 그리고 \\(\\tilde{\\cal B}\\)는 \\({\\cal O}\\)의 base가 아니다. 하지만 \\(\\pi(\\tilde{\\cal B})\\) 는 \\((a,b)\\)를 포함하고 있기에 \\({\\cal O}\\) 의 base가 된다. 여기에서 \\(\\pi(\\tilde{\\cal B})\\) 는 \\(\\tilde{\\cal B}\\) 에 의해서 생성된 가장 작은 \\(\\pi\\)-system 이다.\n- 참고로 \\(\\pi\\)-시스템은 모든 원소가 finite intersection 에 닫혀있는 collection 을 의미한다. 전체집합은 empty intersection 으로 해석할 수 있으므로 모든 파이시스템은 전체집합을 포함한다. 따라서 파이시스템을 정의하면 전체집합을 같이 정의하는것과 마찬가지이다. 따라서 파이시스템 역시 시그마필드와 토폴로지처럼 전체집합과 동시에 정의된다. 그리고 정의에 따라서 임의의 집합에 대한 토폴로지와 시그마필드 모두 파이시스템이 된다.\n- 위에서 예를 든 \\(\\tilde{\\cal B}\\) 와 같이 그것 자체가 어떤 위상 \\({\\cal T}\\) 의 base는 아니지만 \\(\\pi(\\tilde{\\cal B})\\) 는 \\({\\cal T}\\) 의 base가 될때 \\(\\tilde{\\cal B}\\)를 \\({\\cal T}\\)의 subbase 라고 한다.\n- \\(\\tilde{\\cal B}\\) 가 토폴로지 \\({\\cal T}\\)의 subbase이면 \\(\\tilde{\\cal B}\\)로 \\({\\cal T}\\)를 generate 할 수 있다."
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html#chap-8-metric-and-normed-spaces",
    "href": "posts/2023-07-04-(공부) 토폴로지.html#chap-8-metric-and-normed-spaces",
    "title": "(공부) 토폴로지",
    "section": "4 Chap 8: Metric and Normed Spaces",
    "text": "4 Chap 8: Metric and Normed Spaces\n- \\(d:X \\times X \\to \\mathbb{R}\\) 가 (1) 음이 아니고 (2) 대칭이며 (3) 삼각부등식을 만족하면 집합 \\(X\\) 에서의 metric 이라고 한다. 이때 음이 아닐 조건은\n\\[\\begin{cases}\nd(a,b) &gt; 0 & a \\neq b \\\\\nd(a,b) = 0 & a=b\n\\end{cases}\\]\n이다. 만약에 메트릭의 모든 조건을 만족하는데 \\(d(a,b)=0\\) 인 서로 다른 \\(a,b \\in X\\) 가 존재하는 경우 \\(d\\) 를 pseudometric 이라고 한다.\n- \\(d\\) 을 집합 \\(X\\) 에서의 메트릭이라고 하자. 메트릭이 존재한다는 것은 집합 \\(X\\)의 어떠한 두 원소라도 그 사이의 거리를 잴 수 있다는 말이고 그것은 집합 \\(X\\)의 임의의 점 \\(p\\)에서 아래와 같은 ball 을 정의할 수 있는 말이다.\n\\[S(p,\\delta) := \\{x:d(p,x)&lt;\\delta,x \\in X \\}\\]\n참고로 위와 같은 ball 들을 모은 collection 을 \\({\\cal B}\\)라고 하자. 그리고 \\({\\cal B}\\)의 임의의 원소를 언카운터블-유니온하여 얻을 수 있는 집합들의 모임을 \\({\\cal T}\\)라고 하자. 그러면 (1) \\({\\cal T}\\) 가 \\(X\\) 의 토폴로지임을 보이고 (2) \\({\\cal B}\\)의 모든 원소가 \\({\\cal T}\\)-오픈셋임을 보인다면 \\({\\cal B}\\)는 \\({\\cal T}\\)의 base가 된다고 주장할 수 있다(Thm 8.4). 그런데 (2)는 (1)이 성립하면 자동으로 성립하므로 (1)만 보이면 된다. 그러기 위해서는 아래의 (i)-(iii)을 보이면 된다.\n(i) 우선 \\({\\cal T}\\)가 언카운터블-유니온에 닫혀있음은 associative laws 에 의해서 쉽게 증명된다.\n(ii) 이제 \\({\\cal T}\\)가 파이나이트-인터섹션에 닫혀있음을 보이자. \\({\\cal T}\\)의 임의의 두 원소는 각각 \\({\\cal B}\\)의 언카운터블-유니온으로 표현가능하다. 가령 예를들어 임의의 \\(T,S \\in {\\cal T}\\) 가 아래와 같이 표현되었다고 치자.\n\\[T=\\bigcup_{t\\in [0,1]}B_{t}, \\quad S=\\bigcup_{s\\in [2,3]}B_{s}\\]\n따라서 \\(T\\cap S\\) 는 distributive laws 에 의해서 아래와 같이 표현가능하다.\n\\[T \\cap S = \\bigcup_{(t,s) \\in [0,1]\\times[2,3]} B_t \\cap B_s \\]\n(i)에 의해서 \\(B_t \\cap B_s\\)가 \\({\\cal T}\\)의 원소이기만 하면 \\(T \\cap S\\) 역시 \\({\\cal T}\\)의 원소가 되는 구조라 (ii)가 증명된다. 따라서 이제 우리가 할일은 \\(B_t\\cap B_s\\)가 \\({\\cal T}\\)의 원소임을 보이는 것이고 이것은 \\(B_t \\cap B_s\\)가 \\({\\cal B}\\)의 언카운터블-유니온으로 표현가능하다는 조건과 동치이다. 우선 \\(B_t \\cap B_s\\)에 속하는 임의의 원소를 $b^* $ 라고 하자. 이 점에 대하여 나이테정리를 만족시키는 ball이 존재한다. 즉\n\\[\\exists S(b^* ,\\delta)~ st. ~ S(b^* ,\\delta) \\subset B_t \\cap B_s\\]\n이다(Lemma 8.3). 그런데 \\(B_t \\cap B_s\\)의 모든점에서 이런식으로 나이테정리를 만족하는 ball을 잡을 수 있다. 이러한 ball들의 합집합을\n\\[\\bigcup_{b^* \\in (B_t \\cap B_s)} S(b^* , \\delta)\\]\n이라고 하자. 자명하게 이 집합은 \\(B_t\\cap B_s\\) 보다 작다(부분집합들의 합이므로). 하지만 \\(B_t\\cap B_s\\)의 모든 원소는 이 집합에 포함되므로 이 집합은 \\(B_t\\cap B_s\\)보다 크다. 따라서\n\\[\\bigcup_{b^* \\in (B_t \\cap B_s)} S(b^* , \\delta)=B_t \\cap B_s\\]\n이 성립한다.\n(iii) \\({\\cal T}\\)가 \\(X\\)를 포함한다는 것을 보이는것은 볼의 반지름을 크게 만들면 쉽게 증명할 수 있다.\n- 참고로 위의 (i)-(iii)을 요약하면 (1) \\(X\\)가 \\({\\cal B}\\)의 언카운터블 유니온으로 표현가능하고 (2) \\({\\cal B}\\)의 임의의 두 원소가 \\({\\cal B}\\)의 언카운터블 유니온으로 표현가능하기만 하면 볼들이 집합이 아니라 어떠한 \\({\\cal B}\\)라도 특정 토폴로지의 base라고 주장할 수 있다. 이것이 교재의 Thm 6.1 이다.\n- 아무튼 위의 과정을 거치면 \\(X\\)위에서 거리를 정의할 수 있을때 그 거리에 의해서 ball을 정의할 수 있고 ball들의 콜렉션을 base \\({\\cal B}\\)로 정의하고 \\({\\cal B}\\) 원소들의 언카운터블-유니온으로 표현가능한 집합모임을 토폴로지 \\({\\cal T}\\)로 정의해도 논리적모순점이 없다. 즉 \\(X\\)에서 메트릭이 정의되기만 하면 그것에 의해서 순차적으로 토폴로지 \\({\\cal T}\\)를 자연스럽게 유도할 수 있는데 이러한 토폴로지를 특별히 \\(X\\)와 \\(d\\)에 의해서 유도된 metric topology 라고 한다. 그리고 \\((X,d)\\)를 metric-space 라고 한다.\n- \\(\\mathbb{R}\\)에서 \\({\\cal O}\\)를 유도하는 메트릭은 우리가 보통 생각하는 유클리드거리이다. 이러한 메트릭을 usual metric 이라고 한다.\n- \\(\\mathbb{R}\\)에서 아래와 같은 거리를 정의할 수 있다.\n\\[d(a,b)=\\begin{cases}\n0 & a=b \\\\\n1 & a\\neq b\n\\end{cases}\\]\n이러한 거리를 trivial metric 이라고 한다. 그리고 이 거리가 유도하는 토폴로지는 \\(2^{\\mathbb{R}}\\) 이다. (아 몰라.. 따지기 싫어.. 그냥 외워..)\n- 만약에 집합 \\(X\\)에서 정의된 2개의 메트릭 \\(d_1\\), \\(d_2\\)가 같은 토폴로지를 유도한다면 두 메트릭 \\(d_1\\)과 \\(d_2\\)는 equivalent 하다고 말한다.\n- 토폴로지컬-스페이스 \\((X,{\\cal T})\\) 가 있다고 하자. 그런데 \\(X\\) 에서 어떠한 메트릭 \\(d\\)가 존재해 그것이 \\({\\cal T}\\)를 유도하였다고 하자. 그럼 \\({\\cal T}\\)는 메트릭-토폴로지가 된다. 이와 같이 (1) \\(X\\)에서 정의되고 (2) 메트릭-토폴로지 \\({\\cal T}\\)를 유도하는 적당한 메트릭 \\(d\\)가 명시된것은 아니지만 그런 메트릭의 존재를 하나 이상 우리가 알고 있을때 위상공간 \\((X,{\\cal T})\\)를 metrizable 하다고 한다.\n- 두 메트릭스페이스 \\((X,d_1)\\) 와 \\((Y,d_2)\\) 가 isometric 하다는 것은 아래가 만족하는 one-one, onto 인 \\(f:X \\to Y\\) 가 존재한다는 것이다.\n\\[d_1(p,q) = d_2(f(p),f(q))\\]\n- 이때 isometric 이라는 relation 은 보는것 처럼 모든 메트릭공간들의 집합 \\({\\cal M}\\)에서 equivalence relation 이다. 즉 아래가 성립한다.\n(i) \\((X,d_1) \\overset{ism}{\\sim} (X,d_1)\\),\n(ii) \\((X,d_1) \\overset{ism}{\\sim} (Y,d_2)\\) implies \\((Y,d_2) \\overset{ism}{\\sim} (X,d_1)\\),\n(iii) \\((X,d_1) \\overset{ism}{\\sim} (Y,d_2)\\) and \\((Y,d_2) \\overset{ism}{\\sim} (Z,d_3)\\) imply \\((X,d_1) \\overset{ism}{\\sim} (Z,d_3)\\)."
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html#chap-9-countability",
    "href": "posts/2023-07-04-(공부) 토폴로지.html#chap-9-countability",
    "title": "(공부) 토폴로지",
    "section": "5 Chap 9: Countability",
    "text": "5 Chap 9: Countability\n- (@lipschutz1965schaum, p. 132) 위상공간 \\((X,{\\cal T})\\)가 separable 하다는 의미는 \\((X,{\\cal T})\\) countable dense subset 을 가진다는 의미이다.\n- 위상공간 \\((\\mathbb{R}, {\\cal O})\\)를 상상하자.\n\n\\(A_n = [-n,n] \\cap \\mathbb{Q}\\)\n\n라고 한다면 (1) \\({\\cal A} = \\{A_n\\}\\) 은 countable 하고 (2) \\(A_n\\)은 모두 (\\([-n,n]\\)에서) dense 하다. 따라서 \\(\\mathbb{R}\\)은 countable한 dense subset을 가진다. 따라서 \\((\\mathbb{R},{\\cal O})\\)는 seperable 하다."
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html#chap-10-separation-axioms",
    "href": "posts/2023-07-04-(공부) 토폴로지.html#chap-10-separation-axioms",
    "title": "(공부) 토폴로지",
    "section": "6 Chap 10: Separation Axioms",
    "text": "6 Chap 10: Separation Axioms\n- 예비학습1: 위상공간 \\((X,{\\cal T})\\)를 고려하자. \\(X\\)의 임의의 닫힌집합 \\(F\\)를 상상하자. 그리고 \\(F\\)에 소속되지 않은 한 점 \\(p \\in X\\)를 상상하자. 이제 닫힌집합 \\(F\\)를 포함하는 아주 작은 열린집합 \\(G\\)와 \\(p\\)를 포함하는 아주 작은 열린집합 \\(H\\)를 상상하자. 위상공간 \\((X,{\\cal T})\\)에서 임의의 \\(F\\)와 \\(p\\)에 대하여서도 두 열린집합 \\(G\\),\\(H\\)가 서로소가 되도록 선택할 수 있다면 그 위상공간은 regular 하다고 표현한다 (@lipschutz1965schaum, p. 140).\n이해를 위한 예시\n\n\\(F= [0,1]\\)\n\\(p = 1.01\\)\n\\(G= (-0.001, 1.001)\\)\n\\(H= (1.009,1.011)\\)\n\n- 예비학습2: 위상공간 \\((X,{\\cal T})\\)를 고려하자. \\(X\\)의 부분집합중 서로소인 닫힌집합 \\(F_1,F_2\\)를 상상하자.이제 닫힌집합 \\(F_1\\)를 포함하는 아주 작은 열린집합 \\(G\\)와 \\(F_2\\)를 포함하는 아주 작은 열린집합 \\(H\\)를 상상하자. 위상공간 \\((X,{\\cal T})\\)에서 임의의 \\(F_1\\)와 \\(F_2\\)에 대하여서도 두 열린집합 \\(G\\),\\(H\\)가 서로소가 되도록 선택할 수 있다면 그 위상공간은 normal 하다고 표현한다 (@lipschutz1965schaum, p. 141).\n- 위상공간 \\((X,{\\cal T})\\) 에는 얼마나 많은 (혹은 다양한) 열린집합이 있을까? 위상공간 \\((X,{\\cal T}_1)\\)이 \\(T_1\\)-space라는 의미는 서로 다른 \\(a,b \\in X\\)에 대하여 \\(a\\)만 포함하는 열린집합 혹은 \\(b\\)만 포함하는 열린집합이 각각 존재한다는 의미이다.5 위상공간 \\((X,{\\cal T}_2)\\)이 \\(T_2\\)-space 혹은 Hausdorff space라는 의미는 \\(T_1\\)-space에서, \\(a\\)만 포함하는 열린집합과 \\(b\\)만 포함하는 열린집합이 서로 disjoint한 경우를 의미한다. 위상공간 \\((X,{\\cal T}_3)\\)이 \\(T_3\\)-space 라는 의미는 \\(T_1\\)이고 regular space 라는 의미이다. 위상공간 \\((X,{\\cal T}_4)\\)이 \\(T_4\\)-space 라는 의미는 \\(T_1\\)이고 normal space 라는 의미이다.\n- 포함관계: \\(T_1\\)-space는 \\(T_2\\)-space를 포함하고, \\(T_2\\)-space는 \\(T_3\\)-space를, \\(T_3\\)-space는 \\(T_4\\)-space를 포함한다 (@lipschutz1965schaum, p. 141 그림). 그리고 metric space는 \\(T_4\\) space에 포함된다.\n- \\(T_1\\) 위상공간에서는 “singleton = closed set” 이라고 주장할 수 있다. (@lipschutz1965schaum, Thm 10.1) \\(T_2\\) 위상공간에서는 “convergent sequence has a unique limit” 을 주장할 수 있다 (@lipschutz1965schaum, Thm 10.3). \\(T_3\\) 위상공간은 특별히 기억할만한 부분이 없어보인다. \\(T_4\\) 위상공간은 우리손레마 (urysohn lemma) 가 성립하는 공간이다 (@lipschutz1965schaum, Thm 10.7).\n- 우리손레마: \\(T_4\\) 위상공간 \\((X,{\\cal T}_4)\\)를 상상하자. 그리고 \\(X\\)의 부분집합 중 서로소인 닫힌 부분집합 \\(F_1,F_2\\)를 상상하자. 우리손레마에 의하면 어떠한 \\(F_1,F_2\\)에 대하여서도,\n\n\\(f(F_1)=\\{0\\}\\)\n\\(f(F_1)=\\{1\\}\\)\n\n를 만족하는 적당한 연속함수 \\(f:X \\to [0,1]\\)이 항상 존재함이 알려져 있다 (@lipschutz1965schaum, Thm 10.7). 이것은 \\(F_1,F_2\\)를 구분할 수 있는 어떠한 함수 \\(f\\)가 항상 존재함을 의미하는데 이는 \\((X,{\\cal T}_4)\\)를 거리공간화 하는데 이용할 수 있다. 구체적으로 위상공간 \\((X,{\\cal T}_4)\\)가 추가적으로 second coutable 조건을 만족한다면6 \\((X,{\\cal T}_4)\\) 는 거리공간으로 바꿀 수 있음이 알려져 있다 (@lipschutz1965schaum, Thm 10.8).\n- 위상공간 \\((X,{\\cal T})\\)가 \\(T_4\\)-space이고 추가적으로 second coutable space 라면 \\((X,{\\cal T})\\)는 Hilbert cube 와 호모몰픽(homeomorphic) 하다는 것이 알려져 있다 (@lipschutz1965schaum, p. 142)."
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html#chap-14-complete-metric-spaces",
    "href": "posts/2023-07-04-(공부) 토폴로지.html#chap-14-complete-metric-spaces",
    "title": "(공부) 토폴로지",
    "section": "7 Chap 14: Complete Metric Spaces",
    "text": "7 Chap 14: Complete Metric Spaces\n- Convergent sequence 은 단독으로 정의될 수 없으며 위상공간 \\((X,{\\cal T})\\) 와 묶어서 정의된다. 그리고 Cauchy sequence 역시 단독으로 정의될 수 없으며 메트릭스페이스 \\((X,d)\\) 와 묶어서 정의된다.\n- Convergent sequence 와 Cauchy sequence 는 비슷해보이지만 미묘하게 다른점이 있다.\n(1) 컨버전트-시컨트는 위상공간 \\((X,{\\cal T})\\) 만 있으면 정의할 수 있지만 코시수열은 그 위상공간이 메트릭스페이스 이어야 한다는 제약이 있다. 왜냐하면 컨버전트-시컨스의 정의에는 오픈셋만 필요하지만 코시수열은 볼이 필요하고 볼은 메트릭에 의해서만 정의되기 때문이다.\n(2) 컨버전트-시컨스와 코시수열 모두 열의 각 항이 \\(X\\)의 원소이어야 한다는 조건이 있다. 하지만 컨버전트-시컨스는 그 limit 까지 \\(X\\)의 원소이어야 하는데 코시수열은 그렇지 않다는 차이점이 있다.\n- \\(X=(0,1)\\) 위의 usual metric 에 의해서 유도되는 메트릭스페이스 \\((X,d)\\) 를 생각하자. 수열\n\\[\\left\\{\\frac{1}{2},\\frac{1}{3},\\frac{1}{4},\\dots,\\right\\}\\]\n\\(X\\)에서 정의된 코시수열이지만 \\(X\\)에서 정의되는 컨버전트-시컨스는 아니다.\n- 내가 이해한 바는 아래와 같다.\n(1) 토폴로지 \\((X,{\\cal T})\\) 는 항상 컨버전트-시컨스를 정의할 준비가 되어있는 공간이다.\n(2) 위에서 정의가능한 컨버전트-시컨스는 코시수열과 아무런 관련이 없다. 그리고 우리가 통상적으로 고등학교때부터 다루어왔던 수열의 수렴의 개념과도 거리가 멀다.\n(3) 토폴로지 \\((X,{\\cal T})\\) 가 메트릭스페이스라면 컨버전트-시컨스는 코시수열과 어떤관계가 있으며 고등학교때부터 내가 다루어 왔던 상식적인 수렴하는 수열의 개념과도 관련이 있다.\n(4) \\((X,{\\cal T})\\) 가 메트릭스페이스 라고 가정하자. 그럼 아래가 만족한다고 생각할 수 있다.\n\n\\(\\{a_n\\}\\) converges on \\(X\\) \\(\\Longleftrightarrow\\) \\(\\{a_b\\}\\) is Cauchy sequence on \\(X\\) and \\(\\lim_{n\\to\\infty} a_n \\in X\\)\n\n즉 러프하게 말해서 \\(X\\)에서의 컨버전트-시컨스는 (i) \\(X\\)에서의 코시수열이면서 (ii) limit 이 \\(X\\)에 포함되는 수열이라고 말할 수 있다. 이런 정의로 치면 우리가 고등학교때부터 생각해왔던 소박한 정의의 수렴하는 수열은 사실 코시수열에 가깝고 컨버전트-시컨스는 고등학교때부터 배운 소박한 수렴을 하며 동시에 수렴값이 \\(X\\)에서 잘 정의되는 수열을 의미한다고 볼 수 있다. 앞으로는 소박한 수렴과 컨버전트-시컨스를 엄밀하게 구분하여 말하도록 하자. 즉 \\(\\{a_n\\}\\)이 코시수열이라는 말은 \\(\\{a_n\\}\\)이 소박한 수렴을 한다는 의미이고 \\(\\{a_n\\}\\)이 컨버전트-시컨스라는 의미는 \\(\\{a_n\\}\\)이 소박한수렴을 하며 동시에 그 극한값이 well-define 된다는 의미(=\\(\\{a_n\\}\\)의 수렴값이 \\(X\\)의 원소라는 의미)이다.\n- (proposition 14.1) 메트릭스페이스 한정으로, 컨버전트-시컨스는 모두 코시수열이다. (당연한 소리를.. 이런걸 proposition 이라고..)\n- 당연히 위 정리의 역은 성립하지 않는다. 즉 메트릭스페이스 \\((X,{\\cal T})\\) 에서 정의된 코시수열이 반드시 컨버전트-시컨스라는 보장은 없다. (이것도 당연한 소리.. 왜냐하면 수렴값이 \\(X\\)에 포함된다는 보장이 없기 때문) 하지만 그 메트릭스페이스가 complete 하다면 위 정리의 역도 성립한다.\n- 컴플리트하지 않은 메트릭스페이스 \\((X,d)\\)를 컴플리트한 메트릭스페이스 \\((X^* , d)\\) 로 바꿀 수 없을까? 유주얼메트릭(usual metric) \\(d\\) 와 \\(X=(0,1)\\) 로 만들어지는 메트릭스페이스는 컴플리트하지 않지만 \\(d\\) 와 \\(X^* =[0,1]\\) 로 만들어지는 메트릭스페이스는 컴플리트하다. 이런 경우 $(X^* ,d) $ 는 \\((X,d)\\) 의 completion 이라고 한다.\n- 즉 아래의 조건들을 만족하면 공간 $(X^* ,d) $ 는 공간 \\((X,d)\\) 의 completion 이라고 부른다.\n(1) \\(X\\subset X^*\\)\n(2) \\((X^* ,d)\\) is complete metric space\n(3) \\((X,d) \\overset{ism}{\\sim} (X^* ,d)\\).\n\n7.0.0.1 - 메트릭스페이스 \\((X,d)\\)에서 아래의 식을 만족하는 두 코시수열 \\(\\{a_n\\}\\), \\(\\{\\tilde a_n\\}\\) 을 생각하여보자.\n\\[\\lim_{n\\to\\infty} d(a_n,\\tilde a_n)=0 \\]\n이러한 코시수열들을\n\\[\\{a_n\\} \\overset{slim}{\\sim} \\{\\tilde a_n\\}\\]\n이라고 표현하자. 이때 관계 \\(\\overset{slim}{\\sim}\\) 은 \\(X\\)에서 정의가능한 모든 코시수열들의 집합 \\({\\cal C}_ X\\) 에서 equivalence relation 이 된다고 한다. (증명은 알아서) 따라서 이걸 이용하면 거리공간에서 \\(slim\\) 의 관계를 가지는 임의의 두 수열은 같은 극한을 가진다는 결론이 나온다. (이것도 잘 따져보자.)\n- 잠시 (1) 바이너리-릴레이션(binary relation), (2) 이퀴배런스-릴레이션(equivalence relation), (3) 이퀴배런스-클래스(equivalence class) 그리고 (4) 코션트셋(quotient set)에 대하여 설명하고 넘어가겠다.\n(1) 집합 \\({\\cal C}_ X\\) 의 두 원소 \\(\\{a_n\\}\\), \\(\\{b_n\\}\\) 간 바이너리-릴레이션 \\(R\\)이 존재한다는 문장은 집합론적인 언어로 표현가능하다. 구체적으로는 \\(R\\)을 곱집합 \\({\\cal C}_ X \\times {\\cal C}_ X\\) 의 적당한 부분집합으로 설정하고 순서쌍 \\(\\big(\\{a_n\\},\\{b_n\\}\\big)\\) 이 \\(R\\) 의 원소라는 식으로 표현한다. 예를 들면 아래와 같은 식으로 말이다.\n$ {a_n} and {b_n} has arelation with~ R \\ ({a_n},{b_n}) R _ X _ X \\ {a_n} {b_n}$\n(2) 그리고 \\({\\cal C}_ X\\) 위에서의 바이너리-릴레이션 \\(R\\)이 (i) reflexivity (ii) symmetricity (iii) transitivity 를 만족하면 이 릴레이션을 특별히 이퀴배런스-릴레이션 이라고 말한다.\n(3) 그리고 아래와 같이 \\({\\cal C}_ X\\) 에서 \\(\\{a_n\\}\\) 과 이퀴배런스-릴레이션을 가지는 원소들을 모아놓은 집합을 생각할 수 있다. \\[\\big[\\{a_n\\}\\big]_ R:=\\big\\{ \\{x_n\\} : \\{x_n\\} \\overset{R}{\\sim} \\{a_n\\} ~and~ \\{x_n\\} \\in {\\cal C}_ X \\big\\}\\]\n이 집합을 \\(\\{a_n\\}\\)의 equivalence class on \\({\\cal C}_ X\\) by \\(R\\) 이라고 부른다. 보통은 \\(R\\)을 생략하여 \\(\\big[\\{a_n\\}\\big]\\)와 같이만 표현하지만 나는 기호의 명확성을 위해서 관계까지 명시하였다.\n(4) 이퀴배런스-클래스는 본질적으로 파티션과 밀접한 연관이 있다. 여기에서 클래스 \\({\\cal P}_ A\\) 가 집합 \\(A\\)의 파티션이란 의미는 클래스 \\({\\cal P}_ A\\) 에 속한 모든 원소의 합이 \\(A\\) 이며 클래스 \\({\\cal P}_ A\\) 의 각 원소는 서로 배타적이라는 의미이다. 이퀴배런스-클래스가 그럼 왜 파티션과 관련이 있을까? 그것은 어떠한 집합에서 이퀴배런스-릴레이션이 존재하면 그 집합을 배타적인 이퀴배런스-클래스의 합집합으로 표현가능하기 때문이다. 즉 이퀴배런스-릴레이션 혹은 이퀴배런-클래스의 존재는 파티션의 존재를 임플라이 한다. 그리고 이러한 파티션을 이퀴배런스-릴레이션 \\(R\\)에 의해 생성된 quotient set 혹은 quotient space 라고 한다. 관계 \\(R\\)에 의한 \\(A\\)의 코션트 셋은 기호로 \\(A ~\\overset{R}{\\sim}\\) 와 같이 쓴다. 예를들어 \\[\\begin{align}\n{\\cal C}_ X ~ /\\overset{slim}{\\sim}\n\\end{align}\\] 은 집합 \\(X\\) 상에서 존재하는 코시수열들의 집합 \\({\\cal C}_ X\\) 에서 이퀴배런스-릴레이션 \\(slim\\) 에 의해서 생성된 코션트셋을 의미한다."
  },
  {
    "objectID": "posts/2023-07-04-(공부) 토폴로지.html#footnotes",
    "href": "posts/2023-07-04-(공부) 토폴로지.html#footnotes",
    "title": "(공부) 토폴로지",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n정확하게는 \\(\\cal O\\)-오픈셋↩︎\n공집합이 오픈셋이므로↩︎\n\\(\\mathbb{R}\\)이 오픈셋이므로↩︎\n다만 이것은 위상공간을 \\((\\mathbb{R},{\\cal O})\\)로 생각하였을때 이야기이고 위상공간을 \\((\\mathbb{R},2^{\\mathbb{R}})\\)로 생각한다면 \\(\\{p\\}\\) 도 오픈셋이 된다.↩︎\n\\({\\cal T}=\\{\\emptyset, X\\}\\)로 설정한다면 이 조건은 당연히 성립하지 않겠지?↩︎\n즉 \\((X,{\\cal T}_4)\\)가 countable한 base를 가진다면↩︎"
  }
]