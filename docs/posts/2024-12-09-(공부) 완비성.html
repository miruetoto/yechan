<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.533">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2024-12-09">

<title>신록예찬’s Blog - (공부) 추정</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">신록예찬’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DL2024/"> 
<span class="menu-text">DL2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/AP2023/"> 
<span class="menu-text">AP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/PP2024/"> 
<span class="menu-text">PP2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DV2023/"> 
<span class="menu-text">DV2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/MP2023/"> 
<span class="menu-text">MP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SC2024/"> 
<span class="menu-text">SC2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DS2022/"> 
<span class="menu-text">DS2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SP2023/"> 
<span class="menu-text">SP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/IR2021/"> 
<span class="menu-text">IR2021</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan/"> 
<span class="menu-text">yechan</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan2/"> 
<span class="menu-text">yechan2</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/miruetoto/yechan3"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">(공부) 추정</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>신록예찬 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 9, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#추정이란" id="toc-추정이란" class="nav-link active" data-scroll-target="#추정이란"><span class="header-section-number">1</span> 추정이란?</a></li>
  <li><a href="#ub-to-mvue" id="toc-ub-to-mvue" class="nav-link" data-scroll-target="#ub-to-mvue"><span class="header-section-number">2</span> UB <span class="math inline">\(\to\)</span> MVUE</a></li>
  <li><a href="#cs" id="toc-cs" class="nav-link" data-scroll-target="#cs"><span class="header-section-number">3</span> CS</a></li>
  <li><a href="#최소충분통계량" id="toc-최소충분통계량" class="nav-link" data-scroll-target="#최소충분통계량"><span class="header-section-number">4</span> 최소충분통계량</a></li>
  <li><a href="#라오블랙웰" id="toc-라오블랙웰" class="nav-link" data-scroll-target="#라오블랙웰"><span class="header-section-number">5</span> 라오블랙웰</a></li>
  <li><a href="#complete" id="toc-complete" class="nav-link" data-scroll-target="#complete"><span class="header-section-number">6</span> <em>complete</em></a></li>
  <li><a href="#레만쉐페정리" id="toc-레만쉐페정리" class="nav-link" data-scroll-target="#레만쉐페정리"><span class="header-section-number">7</span> 레만쉐페정리</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<blockquote class="blockquote">
<p>ref: <a href="http://www2.math.ou.edu/~cremling/teaching/lecturenotes/stat/ln5.pdf" class="uri">http://www2.math.ou.edu/~cremling/teaching/lecturenotes/stat/ln5.pdf</a></p>
</blockquote>
<section id="추정이란" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="추정이란"><span class="header-section-number">1</span> 추정이란?</h2>
<p>이 문서에서 추정은 점추정을 의미한다. 통계학에서 말하는 추정이라는 것은 기본적으로 미지의 모수 <span class="math inline">\(\theta\)</span> 를 하나의 수로 미루어 짐작하는 행위를 의미한다. 추정에서 전개하는 많은 논의는 확률측도들의 집합 <span class="math inline">\({\cal P}:= \big\{P_{\theta}: \theta \in \Theta \big\}\)</span> 을 우선적으로 상상해 놓아야 정확한 이해를 할 수 있다. 예를들어 <span class="math inline">\(\theta\)</span> 를 잘 추정한다는 말의 의미는 <span class="math inline">\({\cal P}\)</span> 에서 적절한 원소를 잘 선택한다는 것을 뜻한다. 또한 추정량이 가져야 하는 여러가지 좋은 성질에 대한 의미도 다시 생각해볼 수 있다. 추정량이 가져야할 좋은 성질은 어떠한 수식의 형태로 나타나는데, 그러한 수식은 true 가 <span class="math inline">\({\cal P}\)</span> 중 어떠한 원소라고 할지라도 항상 성립해야 한다. 즉 임의의 <span class="math inline">\(P_{\theta} \in {\cal P}\)</span> 에 대하여 성립해야 한다. 예를들어 불편성의 경우 <span class="math inline">\(\mathbb{E}(\hat{\theta})=\theta\)</span> 라는 수식이 떠오를텐데, 이 수식은 임의의 <span class="math inline">\(P_{\theta} \in {\cal P}\)</span> 혹은 임의의 <span class="math inline">\(\theta \in \Theta\)</span> 에 대하여 성립해야 한다. 아래는 호그 앤 크레이그의 수리통계학에서 발췌한 부분이다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hogg and Craig 5e 에서 발췌
</div>
</div>
<div class="callout-body-container callout-body">
<p>확률밀도함수족 <span class="math inline">\(\big\{f(x;\theta): \theta \in \Theta\big\}\)</span> 를 고려하자. 실험자는 이 함수족의 하나의 요소가 확률변수의 p.d.f. 이도록 택할 필요가 있다. 즉 실험자는 <span class="math inline">\(\theta\)</span>의 점추정치를 필요로 한다. <span class="math inline">\(X_1,X_2,\dots,X_n\)</span>은 확률밀도함수족 <span class="math inline">\(\big\{f(x;\theta): \theta \in \Theta \big\}\)</span> 의 하나의 요소 (알지 못하는 요소) 인 p.d.f. 를 갖는 분포에서 추출한 확률표본이라 하자. 즉 이 표본은 p.d.f. <span class="math inline">\(f(x; \theta), \theta \in \Theta\)</span> 인 분포에서 나온 것이다. 문제는 통계량 <span class="math inline">\(Y_1=u_1(X_1,X_2,\dots,X_n)\)</span>을 정의하는 것이므로 <span class="math inline">\(x_1,x_2,\dots,x_n\)</span> 이 <span class="math inline">\(X_1,X_2,\dots,X_n\)</span> 의 실험치로 관찰되었다면 수 <span class="math inline">\(y_1=u_1(x_1,x_2,\dots,x_n)\)</span> 은 <span class="math inline">\(\theta\)</span> 의 좋은 점추정치가 될 것이다.</p>
</div>
</div>
<p>예전에 공부할때는 왜 확률밀도함수족이라는 개념을 굳이 설명하는 것인가 의문이었는데, (복잡하기만 하다고 생각되었다) 이 확률밀도함수족이라는 개념이 미리 전제되지 않으면 이후의 논의를 정확하게 이해하는 것이 매우 어려워진다는 것을 오랜 시간이 지나고 알게 되었다.</p>
</section>
<section id="ub-to-mvue" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="ub-to-mvue"><span class="header-section-number">2</span> UB <span class="math inline">\(\to\)</span> MVUE</h2>
<p><code># 정의</code> – UB</p>
<p>연속형 혹은 이산형 확률변수 <span class="math inline">\(X_1,X_2,\dots,X_n\)</span>는 족(family) <span class="math inline">\({\cal P}:=\big\{P_{\theta}: \theta \in \Theta\big\}\)</span> 중 하나의 원소에서 추출한 확률표본이라고 하자. 만약에 모든 <span class="math inline">\(P_{\theta} \in {\cal P}\)</span> 에 대하여 아래의 조건을 만족하는 <span class="math inline">\(Y_1=u_1(X_1,X_2,\dots,X_n)\)</span> 가 있다면</p>
<p><span class="math display">\[\int u_1(X_1,X_2,\dots,X_n) dP_{\theta} = \theta \quad \cdots (\star)\]</span></p>
<p><span class="math inline">\(Y_1=u_1(X_1,X_2,\dots,X_n)\)</span> 는 <span class="math inline">\(\theta\)</span> 에 대한 불편추정량이라고 한다. 여기에서 중요한 점은 임의의 <span class="math inline">\(P_{\theta}\)</span> 에 대하여 수식 <span class="math inline">\((\star)\)</span>를 고려해야한다는 점이다. 임의의 <span class="math inline">\(P_{\theta} \in {\cal P}\)</span> 를 고려한다는 것은 임의의 <span class="math inline">\(\theta \in \Theta\)</span> 를 고려한다는 것과 같은 말이므로, 암기를 위해서 정의를 바꾸어 기억하면 아래와 같이 정리할 수 있겠다.</p>
<p><span class="math display">\[\hat{\theta} \text{ is UB of } \theta \Leftrightarrow \forall \theta \in \Theta: \mathbb{E}_{\theta}(\hat{\theta})=\theta\]</span></p>
<p><code>#</code></p>
<p><code># 예제1</code> 아래와 같은 상황을 가정하자.</p>
<p><span class="math display">\[X_n \overset{iid}{\sim} N(\theta,1)\]</span></p>
<p>여기에서</p>
<ol type="1">
<li><span class="math inline">\(\hat{\theta}_1=0\)</span> 은 <span class="math inline">\(\theta=0\)</span> 일 경우에는 <span class="math inline">\(E_{\theta}(\hat{\theta}_1)=\theta\)</span> 를 만족하지만 그 외의 경우에는 <span class="math inline">\(E_{\theta}(\hat{\theta}_1)\neq\theta\)</span> 이므로 UB가 아니다.</li>
<li><span class="math inline">\(\hat{\theta}_2=X_1\)</span> 은 UB이다.</li>
<li><span class="math inline">\(\hat{\theta}_3=\frac{X_1+X_2}{2}\)</span> 역시 UB이다.</li>
<li><span class="math inline">\(\hat{\theta}_4=X_1+X_2-X_3\)</span> 역시 UB이다.</li>
<li><span class="math inline">\(\hat{\theta}_5=-99X_1+100X_2\)</span> 역시 UB이다.</li>
<li><span class="math inline">\(\hat{\theta}_6=\frac{X_1+0}{2}\)</span> 은 1과 동일한 이유로 UB가 아니다.</li>
<li><span class="math inline">\(\hat{\theta}_7=\bar{X}\)</span>는 UB이다.</li>
</ol>
<p><code>#</code></p>
<p><code>-</code> 위의 예제에서 <span class="math inline">\(\hat{\theta}_2,\hat{\theta}_3,\hat{\theta}_4,\hat{\theta}_5,\hat{\theta}_7\)</span> 중에 좋은 추정치는 무엇일까? 각각의 분산을 계산해보면 <span class="math inline">\(\hat{\theta}_7=\bar{X}\)</span> 인 경우가 <span class="math inline">\(V(\hat{\theta}_7)=\frac{1}{n}\)</span> 로 가장 분산이 작음을 알 수 있는데, 이를 미루어 보면 <span class="math inline">\(\hat{\theta}_7\)</span> 이 가장 좋은 추정치임을 알 수 있다. 이처럼 비편향 추정량중에서 최소분산을 가지는 추정량은 좋은 추정량인데 이를 최소분산비편향추정량 (MVUE) 라고 한다.</p>
<p><code># 정의</code> – MVUE</p>
<p>최소분산비편향추정량(MVUE)란 <span class="math inline">\(\theta\)</span>에 대한 비편향추정량을 모아놓은 집합 <span class="math inline">\(\hat{\Theta}_{UB}\)</span> 에서 최소분산을 가지는 추정량을 의미한다.</p>
<p><code>#</code></p>
<p><code>-</code> MVUE를 구하는 방법은 아래와 같다.</p>
<blockquote class="blockquote">
<p><span class="math inline">\(\theta\)</span> 에 대한 모든 비편향추정량을 구한다. 즉 집합 <span class="math inline">\(\hat{\Theta}_{UB}\)</span> 를 구한다. 그리고 집합의 각 원소에 <span class="math inline">\(\hat{\theta} \in \hat{\Theta}_{UB}\)</span> 에 대하여 <span class="math inline">\(V(\hat{\theta})\)</span> 를 구한 뒤 <span class="math inline">\(V(\hat{\theta})\)</span> 가 가장 작은 <span class="math inline">\(\hat{\theta}\)</span> 를 선택한다.</p>
</blockquote>
<p><code>-</code> 의문: 왜 비편향추정량만 모아서 그중에서 최소분산을 구할까?</p>
<blockquote class="blockquote">
<p><span class="math inline">\(\hat{\theta}_1\)</span>와 같은 추정량은 <span class="math inline">\(V(\hat{\theta}_1)=0\)</span> 이므로 그냥 최소분산을 만족한다. 따라서 이러한 추정량은 제외해야 좋은 추정량을 고르는 게임이 성립함.</p>
</blockquote>
<p><code>-</code> 불만: 사실상 정의그대로 MVUE를 구하는건 거의 불가능에 가깝다. 즉 아래의 방법으로 구하는 것은 불가능에 가깝다.</p>
<blockquote class="blockquote">
<p><span class="math inline">\(\theta\)</span> 에 대한 모든 비편향추정량을 구한다. 즉 집합 <span class="math inline">\(\hat{\Theta}_{UB}\)</span> 를 구한다. 그리고 집합의 각 원소에 <span class="math inline">\(\hat{\theta} \in \hat{\Theta}_{UB}\)</span> 에 대하여 <span class="math inline">\(V(\hat{\theta})\)</span> 를 구한 뒤 <span class="math inline">\(V(\hat{\theta})\)</span> 가 가장 작은 <span class="math inline">\(\hat{\theta}\)</span> 를 선택한다.</p>
</blockquote>
<p>따라서 적당한 이를 쉽게 하기 위한 적당한 이론이 필요하다.</p>
<p><code># 이론1</code> – CRB</p>
<p>크래머라오 하한값(편의상 <span class="math inline">\(L^\star\)</span>이라고 하자)이라고 있는데, 이는 <span class="math inline">\({\Theta}_{UB}\)</span> 에 존재하는 모든 추정량에 대한 분산의 하한값을 제공한다.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 즉 아래가 성립한다.</p>
<blockquote class="blockquote">
<p><span class="math inline">\(L^\star\)</span> is Cramer-Rao lower bound <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\forall \hat{\theta} \in \hat{\Theta}_{UB}:~ V(\hat{\theta}) \geq L^\star\)</span></p>
</blockquote>
<p><code>#</code></p>
<p><code>-</code> 따라서 이론1을 이용하면 아래의 논리전개를 펼 수 있다.</p>
<ol type="1">
<li><span class="math inline">\(L^\star\)</span>를 구한다.</li>
<li>왠지 MVUE가 될 것 같은 <span class="math inline">\(\hat{\theta}\)</span>을 하나 찍고 그것의 분산 <span class="math inline">\(V(\hat{\theta})\)</span>를 구한다.</li>
<li>만약에 <span class="math inline">\(V(\hat{\theta})=L^\star\)</span>를 만족하면 그 <span class="math inline">\(\hat{\theta}\)</span>이 MVUE라고 주장할 수 있다.</li>
</ol>
<p>그렇지만 이러한 논리전개를 펴는것이 어려운 경우가 있다. 그 이유는 3의 과정이 만족하지 않는 경우가 있기 때문이다. 모든 MVUE 가 CRB 를 만족하면 좋겠으나 그렇지 않다. 즉 MVUE 이지만 CRB를 만족하지 않는 추정량이 존재한다. 이러한 추정량에 대하여 MVUE임을 보이기 위해서는 이론1이 아닌 다른것이 필요하다.</p>
<p><code># 이론2</code> – CSS</p>
<p><code>#</code></p>
</section>
<section id="cs" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="cs"><span class="header-section-number">3</span> CS</h2>
<p><code># 가짜정의</code> – 충분통계량</p>
<p>연속형 혹은 이산형 확률변수 <span class="math inline">\(X_1,X_2,\dots,X_n\)</span>는 족(family) <span class="math inline">\({\cal P}:=\big\{P_{\theta}: \theta \in \Theta\big\}\)</span> 중 하나의 원소에서 추출한 확률표본이라고 하자. 실제 true가 <span class="math inline">\({\cal P}\)</span>의 어떤 원소이든 상관없이,</p>
<blockquote class="blockquote">
<p>통계량 <span class="math inline">\(Y_1=u_1(X_1,X_2,\dots,X_n)\)</span> 만 <strong>기억</strong>하면 <span class="math inline">\(\theta\)</span>를 추정하기에 “충분” 할 것 같다..</p>
</blockquote>
<p>라는 생각이 든다면, <span class="math inline">\(Y_1\)</span>을 <span class="math inline">\(\theta\)</span>에 대한 충분통계량 (CS) 이라고 할 수 있다.</p>
<p><code>#</code></p>
<p><code># 예시1</code> – <span class="math inline">\(X_1 \sim N(\theta,1)\)</span></p>
<ul>
<li><span class="math inline">\(X_1\)</span>은 <span class="math inline">\(\theta_1\)</span> 의 SS. (하나밖에 없으니 그거라도 기억해야지)</li>
<li>즉 <span class="math inline">\(\hat{\theta}=X_1\)</span>은 <span class="math inline">\(\theta\)</span> 의 SS</li>
</ul>
<p><code>-</code> 예시2: <span class="math inline">\(X_1,X_2 \sim N(\theta,1)\)</span></p>
<ul>
<li>당연히 <span class="math inline">\(\hat{\boldsymbol \theta}=(X_1,X_2)\)</span>는 <span class="math inline">\(\theta\)</span> 의 SS (둘다 기억하면 당연히 <span class="math inline">\(\theta\)</span>를 추정함에 있어서 충분함)</li>
<li>그렇지만 좀 더 생각해보면 굳이 값 두개를 기억하기보다 <span class="math inline">\(\frac{1}{2}(X_1+X_2)\)</span>의 값만 기억해도 <strong><em>왠지 충분할것 같음</em></strong>. 따라서 <span class="math inline">\(\hat{\theta} = \frac{1}{2}(X_1+X_2)\)</span> 역시 <span class="math inline">\(\theta\)</span>의 SS 일듯</li>
<li>그런데 좀 더 생각해보니까 <span class="math inline">\(X_1+X_2\)</span>의 값만 기억해도 <span class="math inline">\(\frac{1}{2}(X_1+X_2)\)</span>를 나중에 만들 수 있음 (1/2만 곱하면 되니까) 따라서 <span class="math inline">\(X_1+X_2\)</span>만 기억해도 <strong><em>왠지 충분할 것 같음</em></strong>. 따라서 <span class="math inline">\(\hat{\theta}=X_1+X_2\)</span> 역시 <span class="math inline">\(\theta\)</span>의 SS 일듯</li>
</ul>
<p><code>-</code> 예시3: <span class="math inline">\(X_1,\dots,X_n \sim N(\theta,1)\)</span></p>
<ul>
<li>당연히 <span class="math inline">\(\hat{\boldsymbol \theta}=(X_1,X_2,\dots,X_n)\)</span>은 <span class="math inline">\(\theta\)</span>의 SS.</li>
<li>하지만 <span class="math inline">\(n\)</span>개의 숫자를 기억할 필요 없이 <span class="math inline">\(\sum_{i=1}^{n} X_i\)</span> 하나의 숫자만 기억해도 <strong><em>왠지 충분할듯</em></strong>. 그래서 <span class="math inline">\(\hat{\theta} = \sum_{i=1}^{n} X_i\)</span> 역시 <span class="math inline">\(\theta\)</span>의 SS 일듯</li>
</ul>
<p><code>-</code> SS에 대한 직관1</p>
<ul>
<li>기억할 숫자가 적을수록 유리 -&gt; MSS의 개념</li>
<li>충분통계량의 1:1은 충분통계량 (<span class="math inline">\(\frac{1}{2}(X_1+X_2)\)</span>을 기억하면 충분한 상황이라면, <span class="math inline">\(X_1+X_2\)</span>를 기억해도 충분하니까..)</li>
</ul>
<p><code>-</code> 예시4: <span class="math inline">\(X_1,X_2 \sim {\cal B}er(\theta)\)</span></p>
<ul>
<li>당연히 <span class="math inline">\(\hat{\boldsymbol \theta}=(X_1,X_2)\)</span>은 <span class="math inline">\(\theta\)</span>의 SS.</li>
<li>그리고 <span class="math inline">\(\hat{\theta}=X_1+X_2\)</span> 역시 <span class="math inline">\(\theta\)</span> SS 일듯.</li>
<li>두개보다 한개가 유리하니까 둘다 SS이면 <span class="math inline">\((X_1,X_2)\)</span>보다 <span class="math inline">\(X_1+X_2\)</span>가 더 좋은 SS.</li>
<li><span class="math inline">\(X_1\)</span>은 SS가 아닐듯. <span class="math inline">\(p\)</span>를 추정함에 있어서 <span class="math inline">\(X_1\)</span>만 가지고서는 충분하지 않아보임</li>
<li><span class="math inline">\(X_2\)</span>도 SS가 아닐듯.</li>
</ul>
<p><strong><em>왠지 충분할 것 같은 느낌의 정의</em></strong></p>
<p>아래와 같은 상황을 가정하자.</p>
<p><span class="math display">\[X_1,X_2 \sim {\cal B}er(\theta)\]</span></p>
<p><code>-</code> 일반적으로</p>
<ul>
<li><span class="math inline">\(P((X_1,X_2)=(0,0))=P(X_1=0,X_2=0)=(1-\theta)^2\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(0,1))=P(X_1=0,X_2=1)=\theta(1-\theta)\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(1,0))=P(X_1=1,X_2=0)=(1-\theta)^2\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(1,1))=P(X_1=1,X_2=1)=\theta^2\)</span></li>
</ul>
<p>와 같은 확률들은 <span class="math inline">\(\theta\)</span>가 unknown일 때 하나의 숫자로 정할 수 없다. 예를들어 <span class="math inline">\(\theta=0\)</span> 이라면 아래와 같을 것이고</p>
<ul>
<li><span class="math inline">\(P((X_1,X_2)=(0,0))=P(X_1=0,X_2=0)=1\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(0,1))=P(X_1=0,X_2=1)=0\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(1,0))=P(X_1=1,X_2=0)=0\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(1,1))=P(X_1=1,X_2=1)=0\)</span></li>
</ul>
<p><span class="math inline">\(\theta=1/2\)</span> 이라면 아래와 같을 것이다.</p>
<ul>
<li><span class="math inline">\(P((X_1,X_2)=(0,0))=P(X_1=0,X_2=0)=1/4\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(0,1))=P(X_1=0,X_2=1)=1/4\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(1,0))=P(X_1=1,X_2=0)=1/4\)</span></li>
<li><span class="math inline">\(P((X_1,X_2)=(1,1))=P(X_1=1,X_2=1)=1/4\)</span></li>
</ul>
<p>즉 <span class="math inline">\(X_1,X_2\)</span>의 결합확률분포는 <span class="math inline">\(\theta\)</span>가 변함에 따라 같이 변화한다. 이를 이용해 우리는 <span class="math inline">\(X_1,X_2\)</span>의 결합확률분포에서 관찰한 샘플들을 이용하여 <span class="math inline">\(\theta\)</span>의 값을 역으로 추론한다.</p>
<p><code>-</code> 만약에 어떠한 “특수한 정보를 알고 있을 경우” <span class="math inline">\(X_1,X_2\)</span>의 결합확률분포를 완벽하게 기술할 수 있을 때를 가정해보자.</p>
<p><code>-</code> 경우1: <span class="math inline">\(\theta\)</span>를 알고 있을 경우. <span class="math inline">\((X_1,X_2)\)</span>의 조인트를 완벽하게 기술할 수 있다. 예를들어 <span class="math inline">\(\theta=1/2\)</span>일 경우는 아래와 같다.</p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0 | \theta=1/2)=1/4\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1 | \theta=1/2)=1/4\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0 | \theta=1/2)=1/4\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1 | \theta=1/2)=1/4\)</span></li>
</ul>
<p><code>-</code> 경우2: <span class="math inline">\(X_1,X_2\)</span>의 realization을 알고 있을 경우. <span class="math inline">\((X_1,X_2)\)</span>의 조인트를 완벽하게 기술할 수 있다. 예를들어 <span class="math inline">\(X_1=0,X_2=1\)</span>일 경우는 아래와 같다.</p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0 | X_1=0,X_2=0)=0\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1=0,X_2=1)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1=1,X_2=0)=1\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1=1,X_2=1)=0\)</span></li>
</ul>
<p><code>-</code> 경우3: <span class="math inline">\((X_1+X_2)(\omega)\)</span>의 realization을 알고 있을 경우. 이때도 <strong><em>매우 특이하게</em></strong> <span class="math inline">\((X_1,X_2)\)</span> 의 조인트를 완벽하게 기술할 수 있다.</p>
<p><strong><em>case1: <span class="math inline">\(X_1+X_2=0\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=0)=1\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=0)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=0)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=0)=0\)</span></li>
</ul>
<p><strong><em>case2: <span class="math inline">\(X_1+X_2=1\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=1)=0\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=1)=1/2\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=1)=1/2\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=1)=0\)</span></li>
</ul>
<p><strong><em>case3: <span class="math inline">\(X_1+X_2=2\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=2)=1\)</span></li>
</ul>
<p><code>-</code> 경우4: <span class="math inline">\(X_1\)</span>의 realization만 알고 있을 경우. 이때는 <span class="math inline">\((X_1,X_2)\)</span> 의 조인트를 완벽하게 기술할 수 없다.</p>
<p><strong><em>case1: <span class="math inline">\(X_1=0\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1=0)=1-\theta\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1=0)=\theta\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1=0)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1=0)=0\)</span></li>
</ul>
<p><strong><em>case2: <span class="math inline">\(X_1=1\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1=1)=0\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1=1)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1=1)=1-\theta\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1=1)=\theta\)</span></li>
</ul>
<p><code>-</code> 종합해보면 경우1,경우2,경우3은 경우4와 구분되는 어떠한 공통점을 가지고 있다 볼 수 있다. 특징은 결합확률분포가 <span class="math inline">\(\theta\)</span>에 대한 함수로 표현되지 않는다는 것이다. 하나씩 살펴보면</p>
<ul>
<li>경우1: 당연히 <span class="math inline">\(\theta\)</span>를 줬으니까 <span class="math inline">\((X_1,X_2)\)</span>의 조인트는 <span class="math inline">\(\theta\)</span>에 의존하지 않음.</li>
<li>경우2: <span class="math inline">\(X_1,X_2\)</span>를 줬음. <span class="math inline">\((X_1,X_2)\)</span>의 조인트는 <span class="math inline">\(\theta\)</span>에 의존하지 않음.</li>
<li>경우3: <span class="math inline">\(X_1+X_2\)</span>를 줬음. <span class="math inline">\((X_1,X_2)\)</span>의 조인트는 <span class="math inline">\(\theta\)</span>에 의존하지 않음.</li>
</ul>
<p>이렇게보면 경우1과 경우2,3은 또 다시 구분된다. 경우1은 <strong><span class="math inline">\(\theta\)</span>에 대한 완전한 정보를 준 상황</strong>이므로 당연히 조인트는 <span class="math inline">\(\theta\)</span>에 의존하지 않는다. 경우2-3은 <span class="math inline">\(\theta\)</span>를 주지 않았음에도 조인트가 <span class="math inline">\(\theta\)</span>에 의존하지 않는 매우 특별해보이는 상황이다. 따라서 이를 통해서 유추하면</p>
<blockquote class="blockquote">
<p>경우2에서는 <span class="math inline">\((X_1,X_2)\)</span> 가 경우3에서는 <span class="math inline">\(X_1+X_2\)</span>가 <span class="math inline">\(\theta\)</span>에 대한 완전한 정보를 대신하고 있는것 아닐까?</p>
</blockquote>
<p>라는 생각이 든다. 정리하면</p>
<ul>
<li>경우2: <span class="math inline">\((X_1,X_2)\)</span>을 주는 것은 <span class="math inline">\(\theta\)</span>의 값을 그냥 알려주는 것과 대등한 효과</li>
<li>경우3: <span class="math inline">\(X_1+X_2\)</span>를 주는 것은 <span class="math inline">\(\theta\)</span>의 값을 그냥 알려주는 것과 대등한 효과</li>
</ul>
<p>라고 해석할 수 있는데 이를 수식화 하면 아래와 같다.</p>
<p><code>-</code> 대충정의: 어떠한 통계량 <span class="math inline">\(S\)</span>의 값을 줬을때, <span class="math inline">\((X_1,X_2\dots,X_n)\)</span>의 조인트가 <span class="math inline">\(\theta\)</span>에 의존하지 않으면 그 통계량 <span class="math inline">\(S\)</span>를 <span class="math inline">\(\theta\)</span>의 충분통계량이라고 한다.</p>
<p><code>-</code> 엄밀하게 정의: 아래의 상황을 가정하자.</p>
<ul>
<li>확률벡터: <span class="math inline">\({\bf X}_{sample} = (X_1,\dots,X_n)\)</span></li>
<li>확률변수: <span class="math inline">\({\bf X}_{sample} \sim P_{\theta}\)</span>,</li>
<li>통계량: <span class="math inline">\(T=T({\bf X}_{sample})\)</span></li>
</ul>
<p><span class="math inline">\(T\)</span> 가 <span class="math inline">\(\theta\)</span> 에 대한 충분통계량이면, <span class="math inline">\(P_{\theta}(X_1,X_2,\dots,X_n)\)</span> 을</p>
<p><code>-</code> 충분통계량 구하는 방법</p>
<ol type="1">
<li>지수족일때 구하는 방식이 있음!</li>
<li>분해정리를 쓰는 경우.</li>
<li>1-2로도 잘 모르겠으면 충분통계량일듯한 애를 잡아와서 정의에 넣고 노가다로 때려맞춤. (문제가 디스크릿할때만 쓸것)</li>
</ol>
</section>
<section id="최소충분통계량" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="최소충분통계량"><span class="header-section-number">4</span> 최소충분통계량</h2>
<p><code>-</code> 충분통계량에 대한 realization을 알려주면 <span class="math inline">\(\theta\)</span>의 값을 그냥 알려주는 효과임. 그래서 충분통계량은 좋은 것임</p>
<p><code>-</code> 그런데 충분통계량에도 급이 있음. 아래와 같은 상황을 가정하자.</p>
<p><span class="math display">\[X_1,X_2 \sim {\cal B}er(\theta)\]</span></p>
<p>이 경우</p>
<ol type="1">
<li><span class="math inline">\((X_1,X_2)\)</span>는 SS</li>
<li><span class="math inline">\(X_1+X_2\)</span>는 SS</li>
</ol>
<p>이지만 1은 두개의 숫자를 기억해야하고 2는 하나의 숫자만 기억하면 되니까 2가 더 좋음. 1을 이용하면 2를 만들 수 있지만, 2를 이용해서 1을 만들 수는 없음. 즉 <span class="math inline">\(1\to 2\)</span> 인 변환(=함수)는 가능하지만 <span class="math inline">\(2\to 1\)</span>로 만드는 변환(=함수)는 가능하지 않음.</p>
<p><code>-</code> 이를 확장하자. 어떠한 충분 통계량 <span class="math inline">\(S^\star\)</span>가 있다고 가정하자. 다른 모든 충분통계량 <span class="math inline">\(S_1,S_2,S_3 \dots\)</span>에서 <span class="math inline">\(S^\star\)</span>로 만드는 변환은 존재하는데 (함수는 존재하는데) 그 반대는 <span class="math inline">\(S^\star\)</span>의 전단사인 충분통계량만 가능하다고 하자. 그렇다면 <span class="math inline">\(S^\star\)</span>는 가장 좋은 충분통계량이라고 하며, 가장 적은 숫자만 기억하면 되는 충분통계량이라 볼 수 있다. 이러한 충분통계량을 MSS 라고 하자.</p>
</section>
<section id="라오블랙웰" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="라오블랙웰"><span class="header-section-number">5</span> 라오블랙웰</h2>
<p><code>-</code> 어떠한 정보를 줬을때 <span class="math inline">\(\hat{\theta}\)</span>의 값을 update하는 방법</p>
<p>아래와 같은 상황을 가정하자.</p>
<p><span class="math display">\[X_1,X_2 \sim {\cal B}er(\theta)\]</span></p>
<p><span class="math inline">\(\hat{\theta}=X_1\)</span> 이라면 <span class="math inline">\(\hat{\theta}\)</span>은 UB이다.</p>
<p><code>-</code> 경우3: <span class="math inline">\((X_1+X_2)(\omega)\)</span>의 realization을 알고 있을 경우. 이때도 <strong><em>매우 특이하게</em></strong> <span class="math inline">\((X_1,X_2)\)</span> 의 조인트를 완벽하게 기술할 수 있다.</p>
<p><strong><em>case1: <span class="math inline">\(X_1+X_2=0\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=0)=1\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=0)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=0)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=0)=0\)</span></li>
</ul>
<p><strong><em>case2: <span class="math inline">\(X_1+X_2=1\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=1)=0\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=1)=1/2\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=1)=1/2\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=1)=0\)</span></li>
</ul>
<p><strong><em>case3: <span class="math inline">\(X_1+X_2=2\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=2)=1\)</span></li>
</ul>
<p><code>-</code> 충분통계량 <span class="math inline">\(S\)</span>을 알려주면 (기븐하면) <span class="math inline">\(\theta\)</span>에 대한 완벽한 정보를 알려주는 셈이다. 따라서 <span class="math inline">\(\theta\)</span>를 추정하는 어떠한 추정량 <span class="math inline">\(\hat{\theta}\)</span>도 충분통계량의 정보 <span class="math inline">\(S\)</span>가 있다면 <span class="math inline">\(\hat{\theta}\)</span>를 업그레이드할 수 있다고 볼 수 있다. (뭐 수틀리면 정보야 안쓰면 그만이니까 나빠질것은 없다)</p>
<p><code>-</code> 충분통계량을 줬을때 <span class="math inline">\(\hat{\theta}\)</span>의 업그레이드 방법은</p>
<p><span class="math display">\[\hat{\theta}^{new}:=E(\hat{\theta}|S)\]</span></p>
<p>와 같이 할 수 있는데 이는 충분통계량 <span class="math inline">\(S\)</span>의 정보를 받아서 어떠한 방식으로 업데이트된 <span class="math inline">\(\hat{\theta}\)</span> 이므로 <span class="math inline">\(S\)</span>의 함수라 해석할 수 있다.</p>
<p><code>-</code> 이론 (라오블랙웰, Thm, 4.5): <span class="math inline">\(\hat{\theta}\)</span>가 UB일때 충분통계량의 값을 알려주면 <span class="math inline">\(\hat{\theta}^{new}:=E(\hat{\theta}|S)\)</span>와 같이 <span class="math inline">\(\hat{\theta}\)</span>를 업그레이드 할 수 있다.</p>
</section>
<section id="complete" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="complete"><span class="header-section-number">6</span> <em>complete</em></h2>
<p><code># 예시1</code> – <span class="math inline">\(L^2\)</span> 공간에서 <span class="math inline">\(\{\sin(x), \sin(2x), \sin(3x), \dots \}\)</span> 는 <em>complete</em> 이다. 왜냐하면 이 집합으로 모든 <span class="math inline">\(L^2\)</span> 함수(=제곱적분가능 함수)를 근사할 수 있기 때문이다.</p>
<ul>
<li>basis 느낌 + 채우는 느낌</li>
</ul>
<p><code># 예시2</code> – <span class="math inline">\(\mathbb{R}^n\)</span> 공간에서 표준기저 <span class="math inline">\(\{{\boldsymbol e}_1, {\boldsymbol e}_2, \dots, {\boldsymbol e}_n \}\)</span> 는 <em>complete</em> 이다.</p>
<ul>
<li>basis 느낌</li>
</ul>
<p><code># 예시3</code> – 무리수와 유리수는 완비공간 (<em>complete space</em>) 이 아니지만, 실수는 완비공간 (<em>complete space</em>) 이다.</p>
<ul>
<li>basis 느낌</li>
</ul>
<p><code># 예시4</code> – 어떠한 벡터공간에서 <span class="math inline">\(B=\{{\bf v}_1,{\bf v}_2,\dots,{\bf v}_n\}\)</span> 가 <em>complete</em> 하다고 하자. 그렇다면 모든 <span class="math inline">\({\bf v} \in B\)</span> 와 직교하는 벡터 <span class="math inline">\({\bf w}\)</span> 는 영벡터 밖에 없다. 즉 <span class="math inline">\(B\)</span> 가 어떠한 벡터공간에서 <em>complete</em> 인 경우 아래가 성립한다.</p>
<p><span class="math display">\[\Big(\forall {\bf v} \in B: \langle{\boldsymbol w},{\boldsymbol v}\rangle = 0\Big) \Rightarrow {\bf w}={\bf 0} \]</span></p>
<p><code># 예제5</code> – <span class="math inline">\(X_1, X_2 \overset{i.i.d.}{\sim} {\cal B}er(\theta)\)</span> 라고 하자. <span class="math inline">\(Y=X_1+X_2\)</span> 라고 하자. <span class="math inline">\(Y\)</span> 가 가질 수 있는 값은 <span class="math inline">\(0,1,2\)</span> 이다. 이제 아래의 값에 관심이 있다고 하자.</p>
<ul>
<li><span class="math inline">\(Y=0\)</span> 일 확률</li>
<li><span class="math inline">\(Y=1\)</span> 일 확률</li>
<li><span class="math inline">\(Y=2\)</span> 일 확률</li>
</ul>
<p>이러한 확률들을 편의상 벡터로 표현하면 아래와 같다.</p>
<p><span class="math display">\[{\bf p}_{\theta}= \begin{bmatrix} P_{\theta}(Y=0) \\ P_{\theta}(Y=1) \\  P_{\theta}(Y=2)\end{bmatrix}=\begin{bmatrix} (1-\theta)^2 \\ \theta(1-\theta) \\ \theta^2\end{bmatrix}\]</span></p>
<p>여기에서 벡터의 원소값은 <span class="math inline">\(\theta\)</span> 의 변화에 따라서 달라지는데 이러한 의미로 <span class="math inline">\({\bf p}_{\theta}\)</span> 라는 기호를 사용하였다. 이제 <span class="math inline">\(\theta\)</span>를 변화하여 바뀌는 아래와 같은 <span class="math inline">\({\bf p}_\theta\)</span> 들을 상상하자.</p>
<ul>
<li><span class="math inline">\({\bf p}_0 = [1,0,0]^\top\)</span></li>
<li><span class="math inline">\({\bf p}_1 = [0,0,1]^\top\)</span></li>
<li><span class="math inline">\({\bf p}_{0.5} = [0.25,0.25,0.25]^\top\)</span></li>
<li><span class="math inline">\(...\)</span></li>
</ul>
<p>이러한 벡터를 모두 모은 집합 <span class="math inline">\(B\)</span>를 상상하자. 즉 <span class="math inline">\(B\)</span>는 아래와 같다.</p>
<p><span class="math display">\[B = \{{\bf p}_{\theta}: \theta \in [0,1]\}\]</span></p>
<p>집합 <span class="math inline">\(B\)</span>는 <span class="math inline">\(\mathbb{R}^3\)</span> 의 base가 되는가?</p>
<blockquote class="blockquote">
<p>답변: 된다.</p>
</blockquote>
<p><code># 예제6</code> – <span class="math inline">\(X_1, X_2 \overset{i.i.d.}{\sim} {\cal B}er(\theta)\)</span> 라고 하자. <span class="math inline">\(Y=(X_1-X_2)^2\)</span> 라고 하자. <span class="math inline">\(Y\)</span> 가 가질 수 있는 값은 <span class="math inline">\(0,1\)</span> 이다. 이제 아래의 값에 관심이 있다고 하자.</p>
<ul>
<li><span class="math inline">\(Y=0\)</span> 일 확률</li>
<li><span class="math inline">\(Y=1\)</span> 일 확률</li>
</ul>
<p>이러한 확률들을 편의상 벡터로 표현하면 아래와 같다.</p>
<p><span class="math display">\[{\bf p}_{\theta}= \begin{bmatrix} P_{\theta}(Y=0) \\ P_{\theta}(Y=1) \end{bmatrix}=\begin{bmatrix} (1-\theta)^2 +\theta^2\\ \theta(1-\theta) \end{bmatrix}\]</span></p>
<p>여기에서 벡터의 원소값은 <span class="math inline">\(\theta\)</span> 의 변화에 따라서 달라지는데 이러한 의미로 <span class="math inline">\({\bf p}_{\theta}\)</span> 라는 기호를 사용하였다. 이제 <span class="math inline">\(\theta\)</span>를 변화하여 바뀌는 아래와 같은 <span class="math inline">\({\bf p}_\theta\)</span> 들을 상상하자.</p>
<ul>
<li><span class="math inline">\({\bf p}_0 = [1,0]^\top\)</span></li>
<li><span class="math inline">\({\bf p}_1 = [1,0]^\top\)</span></li>
<li><span class="math inline">\({\bf p}_{0.5} = [0.625,0.1875]^\top\)</span></li>
</ul>
<p>이러한 벡터를 모두 모은 집합 <span class="math inline">\(B\)</span>를 상상하자. 즉 <span class="math inline">\(B\)</span>는 아래와 같다.</p>
<p><span class="math display">\[B = \{{\bf p}_{\theta}: \theta \in [0,1]\}\]</span></p>
<p>집합 <span class="math inline">\(B\)</span>는 <span class="math inline">\(\mathbb{R}^2\)</span> 의 base가 되는가?</p>
<blockquote class="blockquote">
<p>답변: 이것도 된다.</p>
</blockquote>
<p><code># 정의</code> – 통계량 <span class="math inline">\(T\)</span> 가 complete 하지 않다는 것은 <span class="math inline">\(T\)</span> 를 적당히 변형하여 새로운 통계량 <span class="math inline">\(g(T)\)</span> 를 만들어 <span class="math inline">\(\mathbb{E}g(T)=c\)</span> 를 만들 수 있다는 것이다.</p>
<ul>
<li>확률변수: <span class="math inline">\(X_i \sim P_{\theta}\)</span>,</li>
<li>통계량: <span class="math inline">\(Y=X_1+\dots+X_n\)</span></li>
<li>완비통계량조건: <span class="math inline">\(\Big(\forall \theta: \int g(Y) d P_{\theta} =0\Big) \Leftrightarrow \Big(\forall \theta: P_{\theta}(g(Y)=0)=1\Big)\)</span></li>
</ul>
<div class="img-fluid quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2024-12-09-(공부) 완비성_files/figure-html/f1d25ff4-35f6-40d3-a026-83df5f546881-1-ddcf4fab-dd01-4bc0-bfa1-4c8ebcf056cd.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<div class="img-fluid quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2024-12-09-(공부) 완비성_files/figure-html/8ebb2a95-e2f0-4116-baed-ef0202154b39-1-6b6d820c-80c8-4f15-9719-a1429e9dd149.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<p><span class="math inline">\(\int g(Y) dP_\theta = 0\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \sum_{y=0}^n \binom{n}{y} \theta^y (1 - \theta)^{n-y} g(y) = 0\)</span></p>
<p><span class="math inline">\(\Leftrightarrow\binom{n}{0} \theta^0 (1 - \theta)^{n} g(0)+ \binom{n}{1} \theta^1 (1 - \theta)^{n-1} g(1)+ \dots + \binom{n}{n} \theta^n (1 - \theta)^{0} g(n)= 0\)</span></p>
<p>여기에서 <span class="math inline">\(\theta\)</span>는 임의의 값을 가지므로 <span class="math inline">\(g(0)\)</span>이 항상 0이어야함.</p>
</section>
<section id="레만쉐페정리" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="레만쉐페정리"><span class="header-section-number">7</span> 레만쉐페정리</h2>
<p><code>-</code> 충분통계량 <span class="math inline">\(S\)</span>을 알려주면 (기븐하면) <span class="math inline">\(\theta\)</span>에 대한 완벽한 정보를 알려주는 셈이다. 따라서 <span class="math inline">\(\theta\)</span>를 추정하는 어떠한 추정량 <span class="math inline">\(\hat{\theta}\)</span>도 충분통계량의 정보 <span class="math inline">\(S\)</span>가 있다면 <span class="math inline">\(\hat{\theta}\)</span>를 업그레이드할 수 있다고 볼 수 있다. (뭐 수틀리면 정보야 안쓰면 그만이니까 나빠질것은 없다)</p>
<p><code>-</code> 충분통계량을 줬을때 <span class="math inline">\(\hat{\theta}\)</span>의 업그레이드 방법은</p>
<p><span class="math display">\[\hat{\theta}^{new}:=E(\hat{\theta}|S)\]</span></p>
<p>와 같이 할 수 있는데 이는 충분통계량 <span class="math inline">\(S\)</span>의 정보를 받아서 어떠한 방식으로 업데이트된 <span class="math inline">\(\hat{\theta}\)</span> 이므로 <span class="math inline">\(S\)</span>의 함수라 해석할 수 있다.</p>
<p><code>-</code> 이론 (라오블랙웰, Thm, 4.5): <span class="math inline">\(\hat{\theta}\)</span>가 UB일때 충분통계량의 값을 알려주면 <span class="math inline">\(\hat{\theta}^{new}:=E(\hat{\theta}|S)\)</span>와 같이 <span class="math inline">\(\hat{\theta}\)</span>를 업그레이드 할 수 있다.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>사실 <span class="math inline">\({\Theta}_{UB}\)</span>가 아닌 집합에 대해서도 하한값을 제공함<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>