<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.520">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2025-02-01">

<title>신록예찬’s Blog - (공부) 추정</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">신록예찬’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DL2024/"> 
<span class="menu-text">DL2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/AP2023/"> 
<span class="menu-text">AP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/PP2024/"> 
<span class="menu-text">PP2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DV2023/"> 
<span class="menu-text">DV2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/MP2023/"> 
<span class="menu-text">MP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SC2024/"> 
<span class="menu-text">SC2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DS2022/"> 
<span class="menu-text">DS2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SP2023/"> 
<span class="menu-text">SP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/IR2021/"> 
<span class="menu-text">IR2021</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan/"> 
<span class="menu-text">yechan</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan2/"> 
<span class="menu-text">yechan2</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/miruetoto/yechan3"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">(공부) 추정</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>신록예찬 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 1, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#약속" id="toc-약속" class="nav-link active" data-scroll-target="#약속"><span class="header-section-number">1</span> 약속</a></li>
  <li><a href="#추정이란" id="toc-추정이란" class="nav-link" data-scroll-target="#추정이란"><span class="header-section-number">2</span> 추정이란?</a></li>
  <li><a href="#불편추정량" id="toc-불편추정량" class="nav-link" data-scroll-target="#불편추정량"><span class="header-section-number">3</span> 불편추정량</a></li>
  <li><a href="#최소분산불편추정량" id="toc-최소분산불편추정량" class="nav-link" data-scroll-target="#최소분산불편추정량"><span class="header-section-number">4</span> 최소분산불편추정량</a></li>
  <li><a href="#충분통계량" id="toc-충분통계량" class="nav-link" data-scroll-target="#충분통계량"><span class="header-section-number">5</span> 충분통계량</a></li>
  <li><a href="#완비충분통계량" id="toc-완비충분통계량" class="nav-link" data-scroll-target="#완비충분통계량"><span class="header-section-number">6</span> 완비충분통계량</a></li>
  <li><a href="#라오블랙웰" id="toc-라오블랙웰" class="nav-link" data-scroll-target="#라오블랙웰"><span class="header-section-number">7</span> 라오블랙웰</a></li>
  <li><a href="#레만쉐페정리" id="toc-레만쉐페정리" class="nav-link" data-scroll-target="#레만쉐페정리"><span class="header-section-number">8</span> 레만쉐페정리</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">9</span> References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<blockquote class="blockquote">
<p>ref: <a href="http://www2.math.ou.edu/~cremling/teaching/lecturenotes/stat/ln5.pdf" class="uri">http://www2.math.ou.edu/~cremling/teaching/lecturenotes/stat/ln5.pdf</a></p>
</blockquote>
<section id="약속" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="약속"><span class="header-section-number">1</span> 약속</h2>
<p><code>-</code> 모수공간은 일반적으로 <span class="math inline">\(d\)</span>차원을 가정. 확률변수는 일반적으로 <span class="math inline">\(n\)</span>개를 가정</p>
<ul>
<li><span class="math inline">\(\boldsymbol \theta:=(\theta_1,\dots,\theta_d)\)</span></li>
<li><span class="math inline">\(X_1,\dots,X_n \sim F_{\boldsymbol \theta}\)</span></li>
</ul>
<p><code>-</code> 확률변수 <span class="math inline">\(X_1,X_2,\dots,X_n\)</span> 은 간단히 <span class="math inline">\({\bf X}\)</span>로 표현, 실험치 <span class="math inline">\(x_1,x_2,\dots,x_n\)</span> 은 간단히 <span class="math inline">\({\bf x}\)</span>로 표현</p>
<p><code>-</code> 통계량 <span class="math inline">\(u_1(X_1,X_2,\dots,X_n)\)</span> 은 간단히 <span class="math inline">\(u_1({\bf X})\)</span>로 표현, 통계량의 실험치 <span class="math inline">\(u_1(x_1,x_2,\dots,x_n)\)</span> 은 간단히 <span class="math inline">\(u_1({\bf x})\)</span>로 표현<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p><code>-</code> <span class="math inline">\(\boldsymbol \theta\)</span>에 대한 추정치는 <span class="math inline">\(\hat{\boldsymbol \theta}={\bf Y}=(Y_1,\dots,Y_d)=(u_1({\bf X}), \dots, u_d({\bf X}))\)</span>로 표현.</p>
<p><code>-</code> <span class="math inline">\(X_1,X_2,\dots,X_n \sim F_{\boldsymbol{\theta}}\)</span> 의 결합확률 밀도함수 <span class="math inline">\(f_{X_1,X_2,\dots,X_n}(x_1,x_2,\dots,x_n ; {\boldsymbol \theta})\)</span> 는 간단히 <span class="math inline">\(f_{\bf X}({\bf x};{\boldsymbol \theta})\)</span> 로 표현</p>
<ul>
<li>그런데 다음과 같이 표현하기도 함. <span class="math inline">\(f_{\bf X}({\bf x};{\boldsymbol \theta})=f_{\bf X}({\bf x}, {\boldsymbol \theta})=f_{\bf X}({\bf x}|{\boldsymbol \theta})=f_{\bf X}({\bf x})=f({\bf x})\)</span></li>
<li><span class="math inline">\(f_{\bf X}({\bf x};{\boldsymbol \theta})\)</span> 는 호그 앤 크레이그 스타일 (<span class="citation" data-cites="hogg2013introduction">Hogg et al. (<a href="#ref-hogg2013introduction" role="doc-biblioref">2013</a>)</span>), <span class="math inline">\(f_{\bf X}({\bf x}, {\boldsymbol \theta})\)</span> 은 비켈 앤 닥섬 스타일 (<span class="citation" data-cites="bickel2015mathematical">Bickel and Doksum (<a href="#ref-bickel2015mathematical" role="doc-biblioref">2015</a>)</span>), 그리고 <span class="math inline">\(f_{\bf X}({\bf x}|{\boldsymbol \theta})\)</span> 는 카셀라 앤 버거 스타일(<span class="citation" data-cites="casella2024statistical">Casella and Berger (<a href="#ref-casella2024statistical" role="doc-biblioref">2024</a>)</span>) 이다. 은근히 교재마다 고유의 특징이 있음.</li>
<li>사실 <span class="math inline">\(f_{\bf X}({\bf x}|{\boldsymbol \theta})\)</span> 이 표현은 잘못된 표현이라 생각함. 조건부 pdf 처럼 보여서..</li>
</ul>
<p><code>-</code> <span class="math inline">\(\{P_{\boldsymbol \theta}: {\boldsymbol \theta} \in {\bf \Theta}\}\)</span> 의 모든 원소에 대하여 어떠한 state가 성립한다는 것은 <span class="math inline">\(\forall {\boldsymbol \theta} \in {\bf \Theta}\)</span> 에 대하여 어떠한 state가 성립한다는 말과 같음</p>
<p><code>-</code> <span class="math inline">\(P_{\boldsymbol \theta}\)</span>가 더이상 <span class="math inline">\({\boldsymbol \theta}\)</span>에 대한 함수가 아니라면 간단하게 <span class="math inline">\(P\)</span>라고 쓴다.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p><code>-</code> <span class="math inline">\(\mathbb{E}_{\boldsymbol \theta}(X)\)</span>는 <span class="math inline">\(\mathbb{E}_{\boldsymbol \theta}(X)=\int_{X \in {\cal X}} X dP_{\boldsymbol\theta}\)</span> 을 의미한다.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p><code>-</code> <span class="math inline">\({\cal X}\)</span> 는 density function의 정의역을 의미한다.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
</section>
<section id="추정이란" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="추정이란"><span class="header-section-number">2</span> 추정이란?</h2>
<p><code>-</code> 통계학에서 말하는 추정이라는 것은 기본적으로 미지의 모수 <span class="math inline">\({\boldsymbol \theta}\)</span> 를 하나의 수로 미루어 짐작하는 행위를 의미한다.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p><code>-</code> 추정에서 전개하는 많은 논의는 확률측도들의 집합 <span class="math inline">\(\big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta} \big\}\)</span> 을 우선적으로 상상해 놓아야 정확한 이해를 할 수 있다. 예를들어 <span class="math inline">\(\boldsymbol\theta\)</span> 를 잘 추정한다는 말의 의미는 <span class="math inline">\(\big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta} \big\}\)</span> 에서 적절한 원소를 잘 선택한다는 것을 뜻한다. 또한 추정량이 가져야 하는 여러가지 좋은 성질에 대한 의미도 다시 생각해볼 수 있다. 추정량이 가져야할 좋은 성질은 어떠한 수식의 형태로 나타나는데, 그러한 수식은 true 가 <span class="math inline">\(\big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta} \big\}\)</span> 중 어떠한 원소라고 할지라도 항상 성립해야 한다. 즉 임의의 <span class="math inline">\(P_{\boldsymbol\theta} \in \big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta} \big\}\)</span> 에 대하여 성립해야 한다. 예를들어 불편성의 경우 <span class="math inline">\(\mathbb{E}(\hat{\boldsymbol \theta})=\boldsymbol\theta\)</span> 라는 수식이 떠오를텐데, 이 수식은 임의의 <span class="math inline">\(P_{\boldsymbol\theta} \in \big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta} \big\}\)</span> 혹은 임의의 <span class="math inline">\({\boldsymbol \theta} \in {\bf \Theta}\)</span> 에 대하여 성립해야 한다. 아래는 호그 앤 크레이그의 수리통계학에서 발췌한 부분이다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hogg and Craig 5e 에서 발췌
</div>
</div>
<div class="callout-body-container callout-body">
<p>확률밀도함수족 <span class="math inline">\(\big\{f(x;\theta): {\boldsymbol \theta} \in {\bf \Theta}\big\}\)</span> 를 고려하자. 실험자는 이 함수족의 하나의 요소가 확률변수의 p.d.f. 이도록 택할 필요가 있다. 즉 실험자는 <span class="math inline">\({\boldsymbol \theta}\)</span>의 점추정치를 필요로 한다. <span class="math inline">\(X_1,X_2,\dots,X_n\)</span>은 확률밀도함수족 <span class="math inline">\(\big\{f(x;{\boldsymbol \theta}): {\boldsymbol \theta} \in {\bf \Theta} \big\}\)</span> 의 하나의 요소 (알지 못하는 요소) 인 p.d.f. 를 갖는 분포에서 추출한 확률표본이라 하자. 즉 이 표본은 p.d.f. <span class="math inline">\(f(x; {\boldsymbol \theta}), {\boldsymbol \theta} \in {\bf \Theta}\)</span> 인 분포에서 나온 것이다. 문제는 통계량</p>
<ul>
<li><span class="math inline">\(\hat{\theta}_1=Y_1=u_1(X_1,X_2,\dots,X_n)=u_1({\bf X})\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
<li><span class="math inline">\(\hat{\theta}_d=Y_d=u_d(X_1,X_2,\dots,X_n)=u_d({\bf X})\)</span></li>
</ul>
<p>을 정의하는 것이므로 <span class="math inline">\((x_1,x_2,\dots,x_n)\)</span> 이 <span class="math inline">\((X_1,X_2,\dots,X_n)\)</span> 의 실험치로 관찰되었다면 수 <span class="math inline">\((y_1,\dots,y_d)\)</span> 는 <span class="math inline">\((\theta_1,\dots,\theta_d)\)</span> 의 좋은 점추정치가 될 것이다.</p>
</div>
</div>
<p>예전에 공부할때는 왜 확률밀도함수족이라는 개념을 굳이 설명하는 것인가 의문이었는데, (복잡하기만 하다고 생각되었다) 이 확률밀도함수족이라는 개념이 미리 전제되지 않으면 이후의 논의를 정확하게 이해하는 것이 매우 어려워진다는 것을 오랜 시간이 지나고 알게 되었다.</p>
</section>
<section id="불편추정량" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="불편추정량"><span class="header-section-number">3</span> 불편추정량</h2>
<p><code># 정의</code> – UB</p>
<p>연속형 혹은 이산형 확률변수 <span class="math inline">\(X_1,X_2,\dots,X_n\)</span>는 족(family) <span class="math inline">\(\big\{P_{\boldsymbol \theta}: {\boldsymbol \theta} \in {\bf \Theta}\big\}\)</span> 중 하나의 원소에서 추출한 확률표본이라고 하자. 만약에 모든 <span class="math inline">\(P_{\boldsymbol\theta} \in \big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta}\big\}\)</span> 에 대하여</p>
<p><span class="math display">\[\mathbb{E}_{\boldsymbol\theta}[{\bf Y}] =\int {\bf Y} dP_{\boldsymbol\theta}= {\boldsymbol\theta} \quad \cdots (\star)\]</span></p>
<p>을 만족하는 <span class="math inline">\({\bf Y}=(Y_1,\dots,Y_d)=(u_1({\bf X}),\dots,u_d({\bf X}))\)</span> 가 있다면 <span class="math inline">\({\bf Y}\)</span>는 <span class="math inline">\({\boldsymbol \theta}\)</span>에 대한 불편추정량이라고 한다. 여기에서 중요한 점은 임의의 <span class="math inline">\(P_{\boldsymbol \theta}\)</span>에 대하여 수식 <span class="math inline">\((\star)\)</span>를 고려해야한다는 점이다.</p>
<p><code>#</code></p>
<p><code># 정의</code> – UB</p>
<p>위의 정의에서</p>
<ul>
<li><span class="math inline">\(\hat{\boldsymbol\theta}:={\bf Y}=(u_1({\bf X}),\dots,u_d({\bf X}))\)</span> 이고</li>
<li>임의의 <span class="math inline">\(P_{\boldsymbol \theta} \in \big\{P_{\boldsymbol \theta}: {\boldsymbol \theta} \in {\bf \Theta}\big\}\)</span> 를 고려한다는 것은 임의의 <span class="math inline">\({\boldsymbol \theta} \in {\bf \Theta}\)</span> 를 고려한다는 것과 같은 말</li>
</ul>
<p>임을 고려한다면 암기를 위해서 정의를 아래와 같이 바꾸어 정리할 수 있겠다.</p>
<p><span class="math display">\[\hat{\boldsymbol\theta} \text{ is UB of } {\boldsymbol \theta} \Leftrightarrow \forall {\boldsymbol \theta} \in {\bf \Theta}: \mathbb{E}_{\boldsymbol\theta}[\hat{\boldsymbol\theta}]=\boldsymbol\theta\]</span></p>
<p>UB라는 의미를 좀 더 강조하여 아래와 같이 표현하는 것도 가능하다.</p>
<p><span class="math display">\[\hat{\boldsymbol\theta}^{UB} \text{ is UB of } {\boldsymbol \theta} \Leftrightarrow \forall {\boldsymbol \theta} \in {\bf \Theta}: \mathbb{E}_{\boldsymbol\theta}[\hat{\boldsymbol\theta}^{UB}]=\boldsymbol\theta\]</span></p>
<p><code>#</code></p>
<p><code># 예제1</code> 아래와 같은 상황을 가정하자.</p>
<p><span class="math display">\[X_1,\dots, X_n \overset{iid}{\sim} N(\theta,1)\]</span></p>
<p><code>ex1</code> – <span class="math inline">\(\hat{\theta}_1=0\)</span> 은 <span class="math inline">\(\theta=0\)</span> 일 경우에는 <span class="math inline">\(E_{\theta}(\hat{\theta}_1)=\theta\)</span> 를 만족하지만 그 외의 경우에는 <span class="math inline">\(E_{\theta}(\hat{\theta}_1)\neq\theta\)</span> 이므로 UB가 아니다.</p>
<p><code>ex2</code> – <span class="math inline">\(\hat{\theta}_2=X_1\)</span> 은 UB이다.</p>
<p><code>ex3</code> – <span class="math inline">\(\hat{\theta}_3=\frac{X_1+X_2}{2}\)</span> 역시 UB이다.</p>
<p><code>ex4</code> – <span class="math inline">\(\hat{\theta}_4=X_1+X_2-X_3\)</span> 역시 UB이다.</p>
<p><code>ex5</code> – <span class="math inline">\(\hat{\theta}_5=-99X_1+100X_2\)</span> 역시 UB이다.</p>
<p><code>ex6</code> – <span class="math inline">\(\hat{\theta}_6=\frac{X_1+0}{2}\)</span> 은 1과 동일한 이유로 UB가 아니다.</p>
<p><code>ex7</code> –<span class="math inline">\(\hat{\theta}_7=\bar{X}\)</span>는 UB이다.</p>
<p><code>#</code></p>
</section>
<section id="최소분산불편추정량" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="최소분산불편추정량"><span class="header-section-number">4</span> 최소분산불편추정량</h2>
<p><code># Motive</code> – 아래의 상황을 다시 복습하자.</p>
<p><span class="math display">\[X_1, \dots, X_n \overset{iid}{\sim} N(\theta,1)\]</span></p>
<p><code>ex2</code> – <span class="math inline">\(\hat{\theta}_2=X_1\)</span></p>
<p><code>ex3</code> – <span class="math inline">\(\hat{\theta}_3=\frac{X_1+X_2}{2}\)</span></p>
<p><code>ex4</code> – <span class="math inline">\(\hat{\theta}_4=X_1+X_2-X_3\)</span></p>
<p><code>ex5</code> – <span class="math inline">\(\hat{\theta}_5=-99X_1+100X_2\)</span></p>
<p><code>ex7</code> – <span class="math inline">\(\hat{\theta}_7=\bar{X}\)</span></p>
<p>위의 예제에서 <span class="math inline">\(\hat{\theta}_2,\hat{\theta}_3,\hat{\theta}_4,\hat{\theta}_5,\hat{\theta}_7\)</span> 중에 좋은 추정치는 무엇일까? 각각의 분산을 계산해보면 <span class="math inline">\(\hat{\theta}_7=\bar{X}\)</span> 인 경우가 <span class="math inline">\(\mathbb{V}_{\theta}(\hat{\theta}_7)=\frac{1}{n}\)</span> 로 가장 분산이 작음을 알 수 있는데, 이를 미루어 보면 <span class="math inline">\(\hat{\theta}_7\)</span> 이 가장 좋은 추정치임을 알 수 있다. 이처럼 비편향 추정량중에서 최소분산을 가지는 추정량은 좋은 추정량인데 이를 최소분산비편향추정량 (MVUE) 라고 한다.</p>
<p><code>#</code></p>
<p><code>-</code> 의문: 왜 비편향추정량만 모아서 그중에서 최소분산을 구할까?</p>
<blockquote class="blockquote">
<p><span class="math inline">\(\hat{\theta}_1\)</span>와 같은 추정량은 <span class="math inline">\(\mathbb{V}_{\theta}(\hat{\theta}_1)=0\)</span> 이므로 그냥 최소분산을 만족한다. 따라서 이러한 추정량은 제외해야 좋은 추정량을 고르는 게임이 성립함.</p>
</blockquote>
<p><code># 정의</code> – MVUE</p>
<p><span class="math inline">\({\boldsymbol \theta}\)</span> 에 대한 최소분산비편향추정량 <span class="math inline">\(\hat{\boldsymbol \theta}^{MVUE}=\big(u_1({\bf X}),\dots,u_d({\bf X})\big)\)</span> 찾는 일은 모든 <span class="math inline">\({\boldsymbol \theta} \in {\bf \Theta}\)</span> 에 대하여 아래의 조건을 만족하는 적당한 함수 <span class="math inline">\(u_1,\dots,u_d\)</span>를 찾는 일과 같다.</p>
<ol type="1">
<li><p><code>불편성</code> – <span class="math inline">\(\hat{\boldsymbol \theta}^{MVUE} \in \hat{\bf \Theta}^{UB}\)</span></p></li>
<li><p><code>최소분산성</code> – <span class="math inline">\(\forall \hat{\boldsymbol \theta} \in \hat{\bf \Theta}^{UB}: ~\mathbb{V}_{\boldsymbol\theta}\big[\hat{\boldsymbol \theta}^{MVUE}\big] \leq \mathbb{V}_{\boldsymbol\theta}\big[\hat{\boldsymbol \theta}\big]\)</span></p></li>
</ol>
<p>여기에서 <span class="math inline">\(\hat{\bf \Theta}^{UB}=\hat{\bf \Theta}^{UB}:=\{\hat{\boldsymbol \theta}:~ \mathbb{E}_{\boldsymbol\theta}[\hat{\boldsymbol \theta}] ={\boldsymbol \theta}\}\)</span>는 <span class="math inline">\({\boldsymbol\theta}\)</span>에 대한 비편향추정량들의 집합을 의미하며, <span class="math inline">\(\leq\)</span> 는 Positive Semi-Definite Ordering을 의미한다.</p>
<p><code>#</code></p>
<p><code>-</code> 정리하면 고정된 <span class="math inline">\({\boldsymbol \theta} \in {\bf \Theta}\)</span> 에 대하여 MVUE를 구하는 방법은 아래와 같다.</p>
<ol type="1">
<li>고정된 <span class="math inline">\(\boldsymbol\theta\)</span> 에 대한 모든 비편향추정량을 구한다. 즉 집합 <span class="math inline">\(\hat{\bf\Theta}^{UB}\)</span> 를 구한다.</li>
<li>그리고 집합의 각 원소에 <span class="math inline">\(\hat{\boldsymbol\theta} \in \hat{\bf\Theta}_{UB}\)</span> 에 대하여 <span class="math inline">\(\mathbb{V}(\hat{\boldsymbol\theta})\)</span> 를 구한뒤</li>
<li><span class="math inline">\(\mathbb{V}(\hat{\boldsymbol\theta})\)</span> 가 가장 작은 <span class="math inline">\(\hat{\boldsymbol\theta}\)</span> 를 선택한다.</li>
</ol>
<p><code>-</code> 불만: 사실상 정의그대로 MVUE를 구하는건 거의 불가능에 가깝다. 따라서 적당한 이를 쉽게 하기 위한 적당한 이론이 필요하다.</p>
<p><code># 이론1</code> – CRB</p>
<p>크래머라오 하한값(편의상 <span class="math inline">\({\bf L}^\star\)</span>이라고 하자)이라고 있는데, 이는 <span class="math inline">\({\bf \Theta}^{UB}\)</span> 에 존재하는 모든 추정량에 대한 분산의 하한값을 제공한다.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> 즉 아래가 성립한다.</p>
<blockquote class="blockquote">
<p><span class="math inline">\({\bf L}^\star\)</span> is Cramer-Rao lower bound <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\forall \hat{\boldsymbol \theta} \in \hat{\bf \Theta}^{UB}:~ \mathbb{V}_{\boldsymbol \theta}(\hat{\boldsymbol\theta}) \geq {\bf L}^\star\)</span></p>
</blockquote>
<p>여기에서 <span class="math inline">\(\geq\)</span>는 Positive Semi-Definite Ordering 을 의미한다. <span class="math inline">\({\bf L}^{\star}\)</span>는 이후에 <span class="math inline">\({\bf L}^{\star}:=I({\boldsymbol \theta})^{-1}\)</span> 임이 밝혀진다.</p>
<p><code>#</code></p>
<p><code>-</code> 따라서 이론1을 이용하면 아래의 논리전개를 펼 수 있다.</p>
<ol type="1">
<li><span class="math inline">\({\bf L}^\star\)</span>를 구한다.</li>
<li>왠지 MVUE가 될 것 같은 <span class="math inline">\(\hat{\boldsymbol \theta}\)</span>을 하나 찍고 그것의 분산 <span class="math inline">\(\mathbb{V}_{\boldsymbol \theta}(\hat{\boldsymbol \theta})\)</span>를 구한다.</li>
<li>만약에 <span class="math inline">\(\mathbb{V}_{\boldsymbol \theta}(\hat{\boldsymbol \theta})={\bf L}^\star\)</span>를 만족하면 그 <span class="math inline">\(\hat{\boldsymbol\theta}\)</span>이 MVUE라고 주장할 수 있다.</li>
</ol>
<p>그렇지만 이러한 논리전개를 펴는것이 어려운 경우가 있다. 그 이유는 3의 과정이 만족하지 않는 경우가 있기 때문이다. 모든 MVUE 가 CRB 를 만족하면 좋겠으나 그렇지 않다. 즉 MVUE 이지만 CRB를 만족하지 않는 추정량이 존재한다. 이러한 추정량에 대하여 MVUE임을 보이기 위해서는 이론1이 아닌 다른것이 필요하다.</p>
<p><code># 이론2</code> – CSS</p>
<p><code>#</code></p>
</section>
<section id="충분통계량" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="충분통계량"><span class="header-section-number">5</span> 충분통계량</h2>
<section id="언어-그대로의-설명" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="언어-그대로의-설명"><span class="header-section-number">5.1</span> 언어 그대로의 설명</h3>
<p><code># 충분통계량 설명1</code></p>
<p>연속형 혹은 이산형 확률변수 <span class="math inline">\(X_1,X_2,\dots,X_n\)</span>는 족(family) <span class="math inline">\(\big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta}\big\}\)</span> 중 하나의 원소에서 추출한 확률표본이라고 하자. 실제 true가 <span class="math inline">\(\big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf\Theta}\big\}\)</span> 의 어떤 원소이든 상관없이,</p>
<blockquote class="blockquote">
<p>통계량 <span class="math inline">\(Y_1=u_1(X_1,X_2,\dots,X_n), \dots, Y_d=u_d(X_1,X_2,\dots,X_n)\)</span> 만 <strong>기억</strong>하면 <span class="math inline">\({\boldsymbol\theta}=(\theta_1,\dots,\theta_d)\)</span>를 추정하기에 “충분” 할 것 같다..</p>
</blockquote>
<p>라는 생각이 드는 통계량 <span class="math inline">\(Y_1,\dots,Y_d\)</span> 이 있을 수 있다. 이러한 통계량의 개념을 수식적으로 구체화하여 이를 <span class="math inline">\(\boldsymbol\theta\)</span> 에 대한 충분통계량 (CS) 이라고 하고 싶다.</p>
<p><code>#</code></p>
<p><code># 예시1</code> – <span class="math inline">\(X_1 \sim N(\theta,1)\)</span></p>
<p><span class="math inline">\(X_1\)</span>은 <span class="math inline">\(\theta\)</span> 의 SS 이다. (하나밖에 없으니 그거라도 기억해야지)</p>
<p><code>#</code></p>
<p><code># 예시2</code> – <span class="math inline">\(X_1,X_2 \sim N(\theta,1)\)</span></p>
<p>당연히 <span class="math inline">\(\hat{\theta}=(X_1,X_2)\)</span> 라고 한다면 <span class="math inline">\(\hat{\theta}\)</span> 은 <span class="math inline">\(\theta\)</span> 의 SS 이다. (둘다 기억하면 당연히 <span class="math inline">\(\theta\)</span>를 추정함에 있어서 충분하기 때문임) 예제1번과 연결하여 생각하면 결국 “모든 샘플을 기억하면, <span class="math inline">\(\theta\)</span>를 추정하는데 충분” 하므로 모든 샘플은 당연히 <span class="math inline">\(\theta\)</span>의 충분통계량이다.</p>
<p>그렇지만 좀 더 생각해보면 굳이 값 두개를 기억하기보다 <span class="math inline">\(\frac{1}{2}(X_1+X_2)\)</span>의 값만 기억해도 왠지 <span class="math inline">\(\theta\)</span>를 추정하기에 충분할것 같다. 실제로 <span class="math inline">\(\hat{\theta} = \frac{1}{2}(X_1+X_2)\)</span> 역시 <span class="math inline">\(\theta\)</span>의 충분통계량이다.</p>
<p>그런데 좀 더 생각해보니까 <span class="math inline">\(X_1+X_2\)</span>의 값만 기억해도 <span class="math inline">\(\frac{1}{2}(X_1+X_2)\)</span>를 나중에 만들 수 있다. (1/2만 곱하면 되니까) 따라서 <span class="math inline">\(X_1+X_2\)</span>만 기억해도 왠지 <span class="math inline">\(\theta\)</span>를 추정하기에 충분할것 같다. 실제로 그러하다. (충분통계량의 1:1함수는 충분통계량)</p>
<p><code>#</code></p>
<p><code># 예시3</code>– <span class="math inline">\(X_1,\dots,X_n \sim N(\theta,1)\)</span></p>
<p>모든 샘플은 항상 <span class="math inline">\(\theta\)</span>에 대한 충분통계량이므로 <span class="math inline">\(\hat{\theta}=(X_1,X_2,\dots,X_n)\)</span>는 <span class="math inline">\(\theta\)</span>의 충분통계량이다.</p>
<p>하지만 <span class="math inline">\(n\)</span> 개의 숫자를 기억할 필요 없이 <span class="math inline">\(\sum_{i=1}^{n} X_i\)</span> 하나의 숫자만 기억해도 왠지 <span class="math inline">\(\theta\)</span>를 추정하기에 충분할 것 같다. 실제로 <span class="math inline">\(\hat{\theta} = \sum_{i=1}^{n} X_i\)</span> 역시 <span class="math inline">\(\theta\)</span>의 충분통계량이다.</p>
<p><code># 예시4</code> – <span class="math inline">\(X_1,X_2 \sim {\cal B}er(\theta)\)</span></p>
<p>모든 샘플은 <span class="math inline">\(\theta\)</span>에 대한 충분통계량이므로 당연히 <span class="math inline">\(\hat{\theta}=(X_1,X_2)\)</span>은 <span class="math inline">\(\theta\)</span>의 충분통계량이다.</p>
<p>사실 모든 샘플을 기억하기 보다 <span class="math inline">\(X_1+X_2\)</span>의 값만을 기억해도 <span class="math inline">\(\theta\)</span>를 추정하기에 충분해보이는데, 실제로 그러하다. 즉 <span class="math inline">\(\hat{\theta}=X_1+X_2\)</span> 는 <span class="math inline">\(\theta\)</span> 충분통계량이다.</p>
<p>기억량이 적을수록 유리하므로 사실 <span class="math inline">\((X_1,X_2)\)</span>의 실현치를 모두 기억하는 것 보다 <span class="math inline">\(X_1+X_2\)</span>의 실현치값만 기억하는게 유리하다. 따라서 둘 중에서는 <span class="math inline">\(X_1+X_2\)</span> 가 더 좋은 충분통계량이다. (그리고 이 개념을 발전시킨것이 최소충분통계량이다.)</p>
<p><span class="math inline">\(\hat{\theta}=X_1\)</span>은 <span class="math inline">\(\theta\)</span>의 충분통계량이 아닐 것 같다. 왜냐하면 비율 <span class="math inline">\(\theta\)</span>의 값을 추정함에 있어서 <span class="math inline">\(X_2\)</span>값도 있다면 <span class="math inline">\(\theta\)</span>의 추정이 도움이 될 것이라 여겨지기 때문이다. 실제로 <span class="math inline">\(\hat{\theta}=X_1\)</span>은 <span class="math inline">\(\theta\)</span>의 충분통계량이 아니다. 똑같은 논리로 <span class="math inline">\(\hat{\theta}=X_2\)</span> 역시 충분통계량이 아니다.</p>
<p><code>#</code></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(X_1,\dots,X_n \sim F_{\boldsymbol \theta}\)</span> 인 경우 모든 샘플 <span class="math inline">\(X_1,\dots,X_n\)</span> 은 항상 <span class="math inline">\({\boldsymbol \theta}\)</span> 의 충분통계량이다.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(X_1,\dots,X_n \overset{iid}{\sim} F_{\boldsymbol \theta}\)</span> 인 경우 모든 순서통계량 <span class="math inline">\(X_{(1)},\dots,X_{(n)}\)</span> 역시 항상 <span class="math inline">\({\boldsymbol \theta}\)</span> 의 충분통계량이다.</p>
</div>
</div>
</section>
<section id="충분하다라는-언어의-수식화" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="충분하다라는-언어의-수식화"><span class="header-section-number">5.2</span> “충분하다”라는 언어의 수식화</h3>
<p><code>-</code> <strong><em>왠지 충분할 것 같은 느낌</em></strong> 을 정의해보자.</p>
<p><code># 예제1</code></p>
<blockquote class="blockquote">
<p>이 예제는 <span class="math inline">\((X_1,\dots,X_n)\)</span> 의 결합확률분포에서 관찰한 샘플 <span class="math inline">\((x_1,\dots,x_n)\)</span> 을 바탕으로 모수를 추정하는 기본 rationale을 설명한다.</p>
</blockquote>
<p>아래와 같은 상황을 가정하자.</p>
<p><span class="math display">\[X_1,X_2 \sim {\cal B}er(\theta)\]</span></p>
<p>일반적으로</p>
<ul>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=0,X_2=0)=(1-\theta)^2\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=0,X_2=1)=\theta(1-\theta)\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=1,X_2=0)=(1-\theta)^2\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=1,X_2=1)=\theta^2\)</span></li>
</ul>
<p>와 같은 확률들은 <span class="math inline">\(\theta\)</span>가 unknown일 때 하나의 숫자로 정할 수 없다. 예를들어 <span class="math inline">\(\theta=0\)</span> 이라면 아래와 같을 것이고</p>
<ul>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=0)=1\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=1)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=0)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=1)=0\)</span></li>
</ul>
<p><span class="math inline">\(\theta=1/2\)</span> 이라면 아래와 같을 것이다.</p>
<ul>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=0)=1/4\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=1)=1/4\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=0)=1/4\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=1)=1/4\)</span></li>
</ul>
<p>즉 <span class="math inline">\(X_1,X_2\)</span>의 결합확률분포는 <span class="math inline">\(\theta\)</span>가 변함에 따라 같이 변화한다. 이를 이용해 우리는 <span class="math inline">\(X_1,X_2\)</span>의 결합확률분포에서 관찰한 샘플들을 이용하여 <span class="math inline">\(\theta\)</span>의 값을 역으로 추론한다.</p>
<blockquote class="blockquote">
<p>요약: 일반적으로 <span class="math inline">\(\theta\)</span> 는 <span class="math inline">\((X_1,X_2,\dots,X_n)\)</span> 의 joint distribution 에서 얻은 샘플 <span class="math inline">\((x_1,x_2,\dots,x_n)\)</span> 에서 추정한다.</p>
</blockquote>
<p><code>#</code></p>
<p><code># 예제2</code></p>
<blockquote class="blockquote">
<p>만약에 어떠한 “특수한 정보를 알고 있을 경우” <span class="math inline">\(X_1,X_2\)</span>의 결합확률분포를 완벽하게 기술할 수 있을까?</p>
</blockquote>
<p><code>-</code> 경우1: <span class="math inline">\(\theta\)</span>를 알고 있을 경우. <span class="math inline">\((X_1,X_2)\)</span>의 조인트를 완벽하게 기술할 수 있다. 예를들어 <span class="math inline">\(\theta=1/2\)</span>일 경우는 아래와 같다.</p>
<ul>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=0 ~;~ \theta=1/2)=1/4\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=1 ~;~ \theta=1/2)=1/4\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=0 ~;~ \theta=1/2)=1/4\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=1 ~;~ \theta=1/2)=1/4\)</span></li>
</ul>
<p><code>-</code> 경우2: <span class="math inline">\(X_1,X_2\)</span>의 realization을 알고 있을 경우. <span class="math inline">\((X_1,X_2)\)</span>의 조인트를 완벽하게 기술할 수 있다. 예를들어 <span class="math inline">\(X_1=0,X_2=1\)</span>일 경우는 아래와 같다.</p>
<ul>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=0 ~\big|~ X_1=0,X_2=0)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=1 ~\big|~ X_1=0,X_2=1)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=0 ~\big|~ X_1=1,X_2=0)=1\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=1 ~\big|~ X_1=1,X_2=1)=0\)</span></li>
</ul>
<p><code>-</code> 경우3: <span class="math inline">\((X_1+X_2)(\omega)\)</span>의 realization을 알고 있을 경우. 이때도 <strong><em>매우 특이하게</em></strong> <span class="math inline">\((X_1,X_2)\)</span> 의 조인트를 완벽하게 기술할 수 있다.</p>
<p><strong><em>case1: <span class="math inline">\(X_1+X_2=0\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=0 ~\big|~ X_1+X_2=0)=1\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=1 ~\big|~ X_1+X_2=0)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=0 ~\big|~ X_1+X_2=0)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=1 ~\big|~ X_1+X_2=0)=0\)</span></li>
</ul>
<p><strong><em>case2: <span class="math inline">\(X_1+X_2=1\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=0 ~\big|~ X_1+X_2=1)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=1 ~\big|~ X_1+X_2=1)=1/2\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=0 ~\big|~ X_1+X_2=1)=1/2\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=1 ~\big|~ X_1+X_2=1)=0\)</span></li>
</ul>
<p><strong><em>case3: <span class="math inline">\(X_1+X_2=2\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=0 ~\big|~ X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=0,X_2=1 ~\big|~ X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=0 ~\big|~ X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}(X_1=1,X_2=1 ~\big|~ X_1+X_2=2)=1\)</span></li>
</ul>
<p><code>-</code> 경우4: <span class="math inline">\(X_1\)</span>의 realization만 알고 있을 경우. 이때는 <span class="math inline">\((X_1,X_2)\)</span> 의 조인트를 완벽하게 기술할 수 없다.</p>
<p><strong><em>case1: <span class="math inline">\(X_1=0\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=0,X_2=0 ~\big|~ X_1=0)=1-\theta\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=0,X_2=1 ~\big|~ X_1=0)=\theta\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=1,X_2=0 ~\big|~ X_1=0)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=1,X_2=1 ~\big|~ X_1=0)=0\)</span></li>
</ul>
<p><strong><em>case2: <span class="math inline">\(X_1=1\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=0,X_2=0 ~\big|~ X_1=1)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=0,X_2=1 ~\big|~ X_1=1)=0\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=1,X_2=0 ~\big|~ X_1=1)=1-\theta\)</span></li>
<li><span class="math inline">\(\mathbb{P}_{\theta}(X_1=1,X_2=1 ~\big|~ X_1=1)=\theta\)</span></li>
</ul>
<p>종합해보면 경우1,경우2,경우3은 경우4와 구분되는 어떠한 공통점을 가지고 있다 볼 수 있다. 특징은 결합확률분포가 <span class="math inline">\(\theta\)</span>에 대한 함수로 표현되지 않는다는 것이다. 하나씩 살펴보면</p>
<ul>
<li>경우1: 당연히 <span class="math inline">\(\theta\)</span>를 줬으니까 <span class="math inline">\((X_1,X_2)\)</span>의 조인트는 <span class="math inline">\(\theta\)</span>에 의존하지 않음.</li>
<li>경우2: <span class="math inline">\(X_1,X_2\)</span>를 줬음. <span class="math inline">\((X_1,X_2)\)</span>의 조인트는 <span class="math inline">\(\theta\)</span>에 의존하지 않음.</li>
<li>경우3: <span class="math inline">\(X_1+X_2\)</span>를 줬음. <span class="math inline">\((X_1,X_2)\)</span>의 조인트는 <span class="math inline">\(\theta\)</span>에 의존하지 않음.</li>
</ul>
<p>이렇게보면 경우1과 경우2,3은 또 다시 구분된다. 경우1은 <strong><span class="math inline">\(\theta\)</span>에 대한 완전한 정보를 준 상황</strong>이므로 당연히 조인트는 <span class="math inline">\(\theta\)</span>에 의존하지 않는다. 경우2-3은 <span class="math inline">\(\theta\)</span>를 주지 않았음에도 조인트가 <span class="math inline">\(\theta\)</span>에 의존하지 않는 매우 특별해보이는 상황이다. 따라서 이를 통해서 유추하면</p>
<blockquote class="blockquote">
<p>경우2에서는 <span class="math inline">\((X_1,X_2)\)</span>이, 그리고 경우3에서는 <span class="math inline">\(X_1+X_2\)</span>가 <span class="math inline">\(\theta\)</span>에 대한 완전한 정보를 대신하고 있는것 아닐까?</p>
</blockquote>
<p>라는 생각이 든다. 정리하면</p>
<ul>
<li>경우2: <span class="math inline">\((X_1,X_2)\)</span>을 주는 것은 <span class="math inline">\(\theta\)</span>의 값을 그냥 알려주는 것과 대등한 효과</li>
<li>경우3: <span class="math inline">\(X_1+X_2\)</span>를 주는 것은 <span class="math inline">\(\theta\)</span>의 값을 그냥 알려주는 것과 대등한 효과</li>
</ul>
<p>라고 해석할 수 있다.</p>
<p><code>#</code></p>
</section>
<section id="정의" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="정의"><span class="header-section-number">5.3</span> 정의</h3>
<p><code># 충분통계량 설명2</code> – 정의</p>
<p>연속형 혹은 이산형 확률변수 <span class="math inline">\(X_1,X_2,\dots,X_n\)</span>는 족(family) <span class="math inline">\(\big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta}\big\}\)</span> 중 하나의 원소에서 추출한 확률표본이라고 하자. 어떠한 통계량 <span class="math inline">\({\bf Y}\)</span>의 값을 줬을때, <span class="math inline">\((X_1,X_2\dots,X_n)\)</span>의 결합확률분포가 (마치 <span class="math inline">\({\boldsymbol\theta}\)</span>의 값을 알려준 것 마냥) <span class="math inline">\({\boldsymbol\theta}\)</span> 에 의존하지 않으면 그 통계량 <span class="math inline">\({\bf Y}\)</span> 는 <span class="math inline">\({\boldsymbol\theta}\)</span> 의 값을 알려준것과 대등한 효과라고 볼 수 있다. 이러한 일이 <span class="math inline">\(\big\{P_{\boldsymbol\theta}: {\boldsymbol\theta} \in {\bf \Theta}\big\}\)</span> 의 아무원소에서나 성립한다면 그 통계량 <span class="math inline">\({\bf Y}\)</span>를 <span class="math inline">\(\boldsymbol\theta\)</span> 의 충분통계량이라고 한다.</p>
<p><code>#</code></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>[통계학에서 <strong><em>conditional</em></strong> 이라는 단어가 가지는 의미]</p>
<p>아래와 같은 표현들을 고려하자.</p>
<p><code>-</code> <span class="math inline">\(\mathbb{P}\big(X=x|\bigstar\big)\)</span></p>
<p><code>-</code> <span class="math inline">\(F_{X}(x|\bigstar)\)</span></p>
<p><code>-</code> <span class="math inline">\(f_X(x|\bigstar)\)</span></p>
<p><code>-</code> <span class="math inline">\(\mathbb{E}(X|\bigstar)\)</span></p>
<p>수리적으로 <span class="math inline">\(\bigstar\)</span> 자리에 올 수 있는 것은 이벤트 혹은 시그마필드이다.</p>
<p>위의 식에서 <span class="math inline">\(\bigstar\)</span>는 <strong>주어진정보</strong>로 해석할 수 있다. (통계적해석) 이 <strong>주어진정보</strong>는 <span class="math inline">\(\theta\)</span> 에 관련된 정보를 의미한다. 예를 들면 이항분포에서 <span class="math inline">\(X_1+X_2=1\)</span>. 이것은 최소한 <span class="math inline">\(\theta&gt;0\)</span> 임을 암시한다.</p>
<p>또한 위의 식에서 <span class="math inline">\(\bigstar\)</span>는 <strong>제약조건</strong>으로 해석할 수 있다. (수학적해석) 나는 제약조건이라는 해석을 좀 더 선호하는 편인데 이는 여러가지 해석에 비교적 간단히 적용할 수 있기 때문이다. 예를들어 (일반적이진 않지만) <span class="math inline">\(X|\bigstar\)</span> 와 같은 노테이션을 상상할 수 있다. 이는 <span class="math inline">\(\bigstar\)</span> 라는 제약조건을 지키며 정의되는 확률변수로 해석할 수 있다.</p>
</div>
</div>
</section>
<section id="분해정리" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="분해정리"><span class="header-section-number">5.4</span> 분해정리</h3>
</section>
<section id="연습문제" class="level3" data-number="5.5">
<h3 data-number="5.5" class="anchored" data-anchor-id="연습문제"><span class="header-section-number">5.5</span> 연습문제</h3>
<table class="table">
<colgroup>
<col style="width: 10%">
<col style="width: 47%">
<col style="width: 17%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th><strong>분포</strong></th>
<th><strong>PDF/PMF</strong></th>
<th><strong>추정의 대상</strong></th>
<th><strong>충분통계량</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>정규분포</strong></td>
<td><span class="math inline">\(f(x|\mu, \sigma^2) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\)</span></td>
<td><span class="math inline">\((\mu, \sigma^2)\)</span></td>
<td><span class="math inline">\(\left(\sum X_j, \sum X_j^2\right)\)</span></td>
</tr>
<tr class="even">
<td><strong>이항분포</strong></td>
<td><span class="math inline">\(f(x|n, p) = \binom{n}{x} p^x (1-p)^{n-x}\)</span></td>
<td><span class="math inline">\(p\)</span></td>
<td><span class="math inline">\(\sum X_j\)</span></td>
</tr>
<tr class="odd">
<td><strong>포아송분포</strong></td>
<td><span class="math inline">\(f(x|\lambda) = \frac{\lambda^x e^{-\lambda}}{x!}\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\sum X_j\)</span></td>
</tr>
<tr class="even">
<td><strong>지수분포</strong></td>
<td><span class="math inline">\(f(x|\lambda) = \lambda e^{-\lambda x}, \quad x &gt; 0\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\sum X_j\)</span></td>
</tr>
<tr class="odd">
<td><strong>감마분포</strong></td>
<td><span class="math inline">\(f(x|\alpha, \beta) = \frac{\beta^\alpha x^{\alpha-1} e^{-\beta x}}{\Gamma(\alpha)}, \quad x &gt; 0\)</span></td>
<td><span class="math inline">\((\alpha, \beta)\)</span></td>
<td><span class="math inline">\(\left(\sum \log X_j, \sum X_j\right)\)</span></td>
</tr>
<tr class="even">
<td><strong>베타분포</strong></td>
<td><span class="math inline">\(f(x|\alpha, \beta) = \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)} x^{\alpha-1} (1-x)^{\beta-1}, \quad 0 &lt; x &lt; 1\)</span></td>
<td><span class="math inline">\((\alpha, \beta)\)</span></td>
<td><span class="math inline">\(\left(\sum \log X_j, \sum \log(1-X_j)\right)\)</span></td>
</tr>
<tr class="odd">
<td><strong>다항분포</strong></td>
<td><span class="math inline">\(f(x_1, ..., x_k|n, p_1, ..., p_k) = \frac{n!}{x_1! \cdots x_k!} \prod_{i=1}^k p_i^{x_i}\)</span></td>
<td><span class="math inline">\((p_1, \dots, p_k)\)</span></td>
<td><span class="math inline">\(\left(\sum_{j} X_{1j}, \dots, \sum_{j} X_{kj}\right)\)</span></td>
</tr>
<tr class="even">
<td><strong>역감마분포</strong></td>
<td><span class="math inline">\(f(x|\alpha, \beta) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{-\alpha-1} e^{-\beta/x}, \quad x &gt; 0\)</span></td>
<td><span class="math inline">\((\alpha, \beta)\)</span></td>
<td><span class="math inline">\(\left(\sum \frac{1}{X_j}, \sum \log X_j\right)\)</span></td>
</tr>
<tr class="odd">
<td><strong>로그정규분포</strong></td>
<td><span class="math inline">\(f(x|\mu, \sigma^2) = \frac{1}{x\sqrt{2\pi\sigma^2}} \exp\left(-\frac{(\log x - \mu)^2}{2\sigma^2}\right), \quad x &gt; 0\)</span></td>
<td><span class="math inline">\((\mu, \sigma^2)\)</span></td>
<td><span class="math inline">\(\left(\sum \log X_j, \sum (\log X_j)^2\right)\)</span></td>
</tr>
<tr class="even">
<td><strong>와이블분포</strong></td>
<td><span class="math inline">\(f(x|k, \lambda) = \frac{k}{\lambda} \left(\frac{x}{\lambda}\right)^{k-1} e^{-(x/\lambda)^k}, \quad x &gt; 0\)</span></td>
<td><span class="math inline">\((k, \lambda)\)</span></td>
<td><span class="math inline">\(\left(\sum \log X_j, \sum X_j^k\right)\)</span></td>
</tr>
<tr class="odd">
<td><strong>디리클레분포</strong></td>
<td><span class="math inline">\(f(x_1, ..., x_k|\alpha_1, ..., \alpha_k) = \frac{\Gamma\left(\sum_{i=1}^k \alpha_i\right)}{\prod_{i=1}^k \Gamma(\alpha_i)} \prod_{i=1}^k x_i^{\alpha_i-1}\)</span></td>
<td><span class="math inline">\((\alpha_1, \dots, \alpha_k)\)</span></td>
<td><span class="math inline">\(\left(\sum \log X_{1j}, \dots, \sum \log X_{kj}\right)\)</span></td>
</tr>
<tr class="even">
<td><strong>기하분포</strong></td>
<td><span class="math inline">\(f(x|p) = (1-p)^x p, \quad x = 0, 1, 2, \dots\)</span></td>
<td><span class="math inline">\(p\)</span></td>
<td><span class="math inline">\(\sum X_j\)</span></td>
</tr>
<tr class="odd">
<td><strong>카이제곱분포</strong></td>
<td><span class="math inline">\(f(x|k) = \frac{1}{2^{k/2} \Gamma(k/2)} x^{k/2-1} e^{-x/2}, \quad x &gt; 0\)</span></td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
<table class="table">
<colgroup>
<col style="width: 10%">
<col style="width: 49%">
<col style="width: 18%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th><strong>분포</strong></th>
<th><strong>PDF/PMF</strong></th>
<th><strong>추정의 대상</strong></th>
<th><strong>충분통계량</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>이산 균등 분포</strong> (Discrete Uniform)</td>
<td><span class="math inline">\(f(x|N) = \frac{1}{N}, \quad x = 1, 2, \dots, N\)</span></td>
<td><span class="math inline">\(N\)</span></td>
<td><span class="math inline">\(X_{(n)}\)</span></td>
</tr>
<tr class="even">
<td><strong>(연속) 균등 분포</strong> (Uniform)</td>
<td><span class="math inline">\(f(x|a, b) = \frac{1}{b-a}, \quad a \leq x \leq b\)</span></td>
<td><span class="math inline">\((a, b)\)</span></td>
<td><span class="math inline">\((X_{(1)}, X_{(n)})\)</span></td>
</tr>
<tr class="odd">
<td><strong>코시분포</strong> (Cauchy)</td>
<td><span class="math inline">\(f(x|x_0, \gamma) = \frac{1}{\pi \gamma} \left( 1 + \left( \frac{x - x_0}{\gamma} \right)^2 \right)^{-1}\)</span></td>
<td><span class="math inline">\((x_0, \gamma)\)</span></td>
<td><span class="math inline">\((X_{(1)}, X_{(2)}, \dots, X_{(n)})\)</span></td>
</tr>
<tr class="even">
<td><strong>로그로지스틱 분포</strong> (Log-Logistic)</td>
<td><span class="math inline">\(f(x|\alpha, \beta) = \frac{(\beta/\alpha) (x/\alpha)^{\beta-1}}{(1 + (x/\alpha)^\beta)^2}, \quad x &gt; 0\)</span></td>
<td><span class="math inline">\((\alpha, \beta)\)</span></td>
<td><span class="math inline">\((X_{(1)}, X_{(2)}, \dots, X_{(n)})\)</span></td>
</tr>
<tr class="odd">
<td><strong>파레토분포</strong> (Pareto)</td>
<td><span class="math inline">\(f(x|\alpha, x_m) = \frac{\alpha x_m^\alpha}{x^{\alpha+1}}, \quad x \geq x_m\)</span></td>
<td><span class="math inline">\((\alpha, x_m)\)</span></td>
<td><span class="math inline">\((X_{(1)}, X_{(2)}, \dots, X_{(n)})\)</span></td>
</tr>
<tr class="even">
<td><strong>스튜던트 t-분포</strong> (Student’s t)</td>
<td><span class="math inline">\(f(x|\nu) = \frac{\Gamma\left(\frac{\nu+1}{2}\right)}{\sqrt{\nu\pi} \Gamma\left(\frac{\nu}{2}\right)} \left(1 + \frac{x^2}{\nu}\right)^{-(\nu+1)/2}\)</span></td>
<td>?</td>
<td>?</td>
</tr>
<tr class="odd">
<td><strong>F-분포</strong> (F-Distribution)</td>
<td><span class="math inline">\(f(x|d_1, d_2) = \frac{\Gamma\left(\frac{d_1 + d_2}{2}\right)}{\Gamma\left(\frac{d_1}{2}\right) \Gamma\left(\frac{d_2}{2}\right)} \cdot \left( \frac{d_1}{d_2} \right)^{d_1/2} \cdot \frac{x^{(d_1/2) - 1}}{\left(1 + \frac{d_1}{d_2} x \right)^{(d_1 + d_2)/2}}\)</span></td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="완비충분통계량" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="완비충분통계량"><span class="header-section-number">6</span> 완비충분통계량</h2>
<section id="최소충분통계량" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="최소충분통계량"><span class="header-section-number">6.1</span> 최소충분통계량</h3>
<p><code>-</code> 충분통계량의 realization 을 알려주면 <span class="math inline">\(\theta\)</span>의 값을 그냥 알려주는 효과이다. 그래서 충분통계량은 좋은 것이다. 그런데 충분통계량에도 급이 있다. 아래와 같은 상황을 가정하자.</p>
<p><span class="math display">\[X_1,X_2 \sim {\cal B}er(\theta)\]</span></p>
<p>이 경우</p>
<p><code>1</code> – <span class="math inline">\((X_1,X_2)\)</span>는 <span class="math inline">\(\theta\)</span>의 충분통계량이고,</p>
<p><code>2</code> – <span class="math inline">\(X_1+X_2\)</span>역시 <span class="math inline">\(\theta\)</span>의 충분통계량이지만</p>
<p><code>1</code>은 두개의 숫자를 기억해야하고 <code>2</code>는 하나의 숫자만 기억하면 된다. 즉 <code>2</code>는 <code>1</code>보다 더 정보가 축약되어 있는 형태이다.</p>
<p>그렇다면 <strong>정보의 축약</strong>은 어떻게 수리적으로 표현할 수 있을까? <code>1</code>을 이용하면 <code>2</code>를 만들 수 있지만, <code>2</code>를 이용해서 <code>1</code>을 만들 수는 없다. 즉 <span class="math inline">\(1\to 2\)</span> 인 변환(=함수)는 가능하지만 <span class="math inline">\(2\to 1\)</span>로 만드는 변환(=함수)는 가능하지 않다.</p>
<p>이 개념을 확장하여 수식화하자. 어떠한 충분 통계량 <span class="math inline">\({\bf Y}=\hat{\boldsymbol\theta}^{MSS}\)</span>가 있다고 가정하자. 다른 모든 충분통계량에서 <span class="math inline">\({\bf Y}\)</span>로 만드는 변환은 존재하는데 (함수는 존재하는데) 그 반대는 <span class="math inline">\({\bf Y}\)</span>의 전단사인 충분통계량만 가능하다고 하자. 그렇다면 <span class="math inline">\({\bf Y}\)</span>는 가장 축약된 충분통계량이라고 볼 수 있다. 이러한 충분통계량을 최소충분통계량(MSS) 라고 한다.</p>
<p><code>-</code> 그런데 결국 최소충분통계량도 정보를 완전히 압축하지는 못해서 완비충분통계량이라는 것을 사용해야 한다.</p>
</section>
<section id="보조통계량" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="보조통계량"><span class="header-section-number">6.2</span> 보조통계량</h3>
<p>ㅇㅇㅇ</p>
</section>
<section id="완비통계량" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="완비통계량"><span class="header-section-number">6.3</span> 완비통계량</h3>
<p><code># 예시1</code> – <span class="math inline">\(L^2\)</span> 공간에서 <span class="math inline">\(\{\sin(x), \sin(2x), \sin(3x), \dots \}\)</span> 는 <em>complete</em> 이다. 왜냐하면 이 집합으로 모든 <span class="math inline">\(L^2\)</span> 함수(=제곱적분가능 함수)를 근사할 수 있기 때문이다.</p>
<ul>
<li>basis 느낌 + 채우는 느낌</li>
</ul>
<p><code># 예시2</code> – <span class="math inline">\(\mathbb{R}^n\)</span> 공간에서 표준기저 <span class="math inline">\(\{{\boldsymbol e}_1, {\boldsymbol e}_2, \dots, {\boldsymbol e}_n \}\)</span> 는 <em>complete</em> 이다.</p>
<ul>
<li>basis 느낌</li>
</ul>
<p><code># 예시3</code> – 무리수와 유리수는 완비공간 (<em>complete space</em>) 이 아니지만, 실수는 완비공간 (<em>complete space</em>) 이다.</p>
<ul>
<li>basis 느낌</li>
</ul>
<p><code># 예시4</code> – 어떠한 벡터공간에서 <span class="math inline">\({\boldsymbol B}=\{{\bf v}_1,{\bf v}_2,\dots,{\bf v}_n\}\)</span> 가 <em>complete</em> 하다고 하자. 그렇다면 모든 <span class="math inline">\({\bf v} \in B\)</span> 와 직교하는 벡터 <span class="math inline">\({\bf w}\)</span> 는 영벡터 밖에 없다. 즉 <span class="math inline">\(B\)</span> 가 어떠한 벡터공간에서 <em>complete</em> 인 경우 아래가 성립한다.</p>
<p><span class="math display">\[\Big(\forall {\bf v} \in B: \langle{\boldsymbol w},{\boldsymbol v}\rangle = 0\Big) \Rightarrow {\bf w}={\bf 0} \]</span></p>
<p><code># 예제5</code> – <span class="math inline">\(X_1, X_2 \overset{i.i.d.}{\sim} {\cal B}er(\theta)\)</span> 라고 하자. <span class="math inline">\(Y=X_1+X_2\)</span> 라고 하자. <span class="math inline">\(Y\)</span> 가 가질 수 있는 값은 <span class="math inline">\(0,1,2\)</span> 이다. 이제 아래의 값에 관심이 있다고 하자.</p>
<ul>
<li><span class="math inline">\(Y=0\)</span> 일 확률</li>
<li><span class="math inline">\(Y=1\)</span> 일 확률</li>
<li><span class="math inline">\(Y=2\)</span> 일 확률</li>
</ul>
<p>이러한 확률들을 편의상 벡터로 표현하면 아래와 같다.</p>
<p><span class="math display">\[{\boldsymbol p}_{\theta} = \begin{bmatrix} P_{\theta}(Y=0) \\ P_{\theta}(Y=1) \\  P_{\theta}(Y=2)\end{bmatrix}=\begin{bmatrix} (1-\theta)^2 \\ \theta(1-\theta) \\ \theta^2\end{bmatrix}\]</span></p>
<p>여기에서 벡터의 원소값은 <span class="math inline">\(\theta\)</span> 의 변화에 따라서 달라지는데 이러한 의미로 <span class="math inline">\({\boldsymbol p}_{\theta}\)</span> 라는 기호를 사용하였다. 이제 <span class="math inline">\(\theta\)</span>를 변화하여 바뀌는 아래와 같은 <span class="math inline">\({\boldsymbol p}_\theta\)</span> 들을 상상하자.</p>
<ul>
<li><span class="math inline">\({\boldsymbol p}_0 = [1,0,0]^\top\)</span></li>
<li><span class="math inline">\({\boldsymbol p}_1 = [0,0,1]^\top\)</span></li>
<li><span class="math inline">\({\boldsymbol p}_{0.5} = [0.25,0.25,0.25]^\top\)</span></li>
<li><span class="math inline">\(...\)</span></li>
</ul>
<p>이러한 벡터를 모두 모은 집합 <span class="math inline">\(B\)</span>를 상상하자. 즉 <span class="math inline">\(B\)</span>는 아래와 같다.</p>
<p><span class="math display">\[B = \{{\boldsymbol p}_{\theta}: \theta \in [0,1]\}\]</span></p>
<p>집합 <span class="math inline">\(B\)</span>는 <span class="math inline">\(\mathbb{R}^3\)</span> 의 base가 되는가?</p>
<blockquote class="blockquote">
<p>답변: 된다.</p>
</blockquote>
<p><code># 예제6</code> – <span class="math inline">\(X_1, X_2 \overset{i.i.d.}{\sim} {\cal B}er(\theta)\)</span> 라고 하자. <span class="math inline">\(Y=(X_1-X_2)^2\)</span> 라고 하자. <span class="math inline">\(Y\)</span> 가 가질 수 있는 값은 <span class="math inline">\(0,1\)</span> 이다. 이제 아래의 값에 관심이 있다고 하자.</p>
<ul>
<li><span class="math inline">\(Y=0\)</span> 일 확률</li>
<li><span class="math inline">\(Y=1\)</span> 일 확률</li>
</ul>
<p>이러한 확률들을 편의상 벡터로 표현하면 아래와 같다.</p>
<p><span class="math display">\[{\boldsymbol p}_{\theta}= \begin{bmatrix} P_{\theta}(Y=0) \\ P_{\theta}(Y=1) \end{bmatrix}=\begin{bmatrix} (1-\theta)^2 +\theta^2\\ \theta(1-\theta) \end{bmatrix}\]</span></p>
<p>여기에서 벡터의 원소값은 <span class="math inline">\(\theta\)</span> 의 변화에 따라서 달라지는데 이러한 의미로 <span class="math inline">\({\bf p}_{\theta}\)</span> 라는 기호를 사용하였다. 이제 <span class="math inline">\(\theta\)</span>를 변화하여 바뀌는 아래와 같은 <span class="math inline">\({\bf p}_\theta\)</span> 들을 상상하자.</p>
<ul>
<li><span class="math inline">\({\bf p}_0 = [1,0]^\top\)</span></li>
<li><span class="math inline">\({\bf p}_1 = [1,0]^\top\)</span></li>
<li><span class="math inline">\({\bf p}_{0.5} = [0.625,0.1875]^\top\)</span></li>
</ul>
<p>이러한 벡터를 모두 모은 집합 <span class="math inline">\(B\)</span>를 상상하자. 즉 <span class="math inline">\(B\)</span>는 아래와 같다.</p>
<p><span class="math display">\[B = \{{\bf p}_{\theta}: \theta \in [0,1]\}\]</span></p>
<p>집합 <span class="math inline">\(B\)</span>는 <span class="math inline">\(\mathbb{R}^2\)</span> 의 base가 되는가?</p>
<blockquote class="blockquote">
<p>답변: 이것도 된다.</p>
</blockquote>
<p><code># 정의</code> – 통계량 <span class="math inline">\(T\)</span> 가 complete 하지 않다는 것은 <span class="math inline">\(T\)</span> 를 적당히 변형하여 새로운 통계량 <span class="math inline">\(g(T)\)</span> 를 만들어 <span class="math inline">\(\mathbb{E}g(T)=c\)</span> 를 만들 수 있다는 것이다.</p>
<ul>
<li>확률변수: <span class="math inline">\(X_i \sim P_{\theta}\)</span>,</li>
<li>통계량: <span class="math inline">\(Y=X_1+\dots+X_n\)</span></li>
<li>완비통계량조건: <span class="math inline">\(\Big(\forall \theta: \int g(Y) d P_{\theta} =0\Big) \Leftrightarrow \Big(\forall \theta: P_{\theta}(g(Y)=0)=1\Big)\)</span></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-02-01-(공부) 추정_files/figure-html/17493174-fdf4-494a-8cef-ec0970f62a52-1-ddcf4fab-dd01-4bc0-bfa1-4c8ebcf056cd.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-02-01-(공부) 추정_files/figure-html/c95baa31-aa9f-4044-a9b1-78bc79d59d4f-1-6b6d820c-80c8-4f15-9719-a1429e9dd149.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<p><span class="math inline">\(\int g(Y) dP_\theta = 0\)</span></p>
<p><span class="math inline">\(\Leftrightarrow \sum_{y=0}^n \binom{n}{y} \theta^y (1 - \theta)^{n-y} g(y) = 0\)</span></p>
<p><span class="math inline">\(\Leftrightarrow\binom{n}{0} \theta^0 (1 - \theta)^{n} g(0)+ \binom{n}{1} \theta^1 (1 - \theta)^{n-1} g(1)+ \dots + \binom{n}{n} \theta^n (1 - \theta)^{0} g(n)= 0\)</span></p>
<p>여기에서 <span class="math inline">\(\theta\)</span>는 임의의 값을 가지므로 <span class="math inline">\(g(0)\)</span>이 항상 0이어야함.</p>
</section>
<section id="완비충분통계량-1" class="level3" data-number="6.4">
<h3 data-number="6.4" class="anchored" data-anchor-id="완비충분통계량-1"><span class="header-section-number">6.4</span> 완비충분통계량</h3>
<p>ㅇㅇㅇ</p>
</section>
</section>
<section id="라오블랙웰" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="라오블랙웰"><span class="header-section-number">7</span> 라오블랙웰</h2>
<p><code>-</code> 어떠한 정보를 줬을때 <span class="math inline">\(\hat{\theta}\)</span>의 값을 update하는 방법</p>
<p>아래와 같은 상황을 가정하자.</p>
<p><span class="math display">\[X_1,X_2 \sim {\cal B}er(\theta)\]</span></p>
<p><span class="math inline">\(\hat{\theta}=X_1\)</span> 이라면 <span class="math inline">\(\hat{\theta}\)</span>은 UB이다.</p>
<p><code>-</code> 경우3: <span class="math inline">\((X_1+X_2)(\omega)\)</span>의 realization을 알고 있을 경우. 이때도 <strong><em>매우 특이하게</em></strong> <span class="math inline">\((X_1,X_2)\)</span> 의 조인트를 완벽하게 기술할 수 있다.</p>
<p><strong><em>case1: <span class="math inline">\(X_1+X_2=0\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=0)=1\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=0)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=0)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=0)=0\)</span></li>
</ul>
<p><strong><em>case2: <span class="math inline">\(X_1+X_2=1\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=1)=0\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=1)=1/2\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=1)=1/2\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=1)=0\)</span></li>
</ul>
<p><strong><em>case3: <span class="math inline">\(X_1+X_2=2\)</span>일 경우</em></strong></p>
<ul>
<li><span class="math inline">\(P(X_1=0,X_2=0| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=0,X_2=1| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=0| X_1+X_2=2)=0\)</span></li>
<li><span class="math inline">\(P(X_1=1,X_2=1| X_1+X_2=2)=1\)</span></li>
</ul>
<p><code>-</code> 충분통계량 <span class="math inline">\(S\)</span>을 알려주면 (기븐하면) <span class="math inline">\(\theta\)</span>에 대한 완벽한 정보를 알려주는 셈이다. 따라서 <span class="math inline">\(\theta\)</span>를 추정하는 어떠한 추정량 <span class="math inline">\(\hat{\theta}\)</span>도 충분통계량의 정보 <span class="math inline">\(S\)</span>가 있다면 <span class="math inline">\(\hat{\theta}\)</span>를 업그레이드할 수 있다고 볼 수 있다. (뭐 수틀리면 정보야 안쓰면 그만이니까 나빠질것은 없다)</p>
<p><code>-</code> 충분통계량을 줬을때 <span class="math inline">\(\hat{\theta}\)</span>의 업그레이드 방법은</p>
<p><span class="math display">\[\hat{\theta}^{new}:=E(\hat{\theta}|S)\]</span></p>
<p>와 같이 할 수 있는데 이는 충분통계량 <span class="math inline">\(S\)</span>의 정보를 받아서 어떠한 방식으로 업데이트된 <span class="math inline">\(\hat{\theta}\)</span> 이므로 <span class="math inline">\(S\)</span>의 함수라 해석할 수 있다.</p>
<p><code>-</code> 이론 (라오블랙웰, Thm, 4.5): <span class="math inline">\(\hat{\theta}\)</span>가 UB일때 충분통계량의 값을 알려주면 <span class="math inline">\(\hat{\theta}^{new}:=E(\hat{\theta}|S)\)</span>와 같이 <span class="math inline">\(\hat{\theta}\)</span>를 업그레이드 할 수 있다.</p>
</section>
<section id="레만쉐페정리" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="레만쉐페정리"><span class="header-section-number">8</span> 레만쉐페정리</h2>
<p><code>-</code> 충분통계량 <span class="math inline">\(S\)</span>을 알려주면 (기븐하면) <span class="math inline">\(\theta\)</span>에 대한 완벽한 정보를 알려주는 셈이다. 따라서 <span class="math inline">\(\theta\)</span>를 추정하는 어떠한 추정량 <span class="math inline">\(\hat{\theta}\)</span>도 충분통계량의 정보 <span class="math inline">\(S\)</span>가 있다면 <span class="math inline">\(\hat{\theta}\)</span>를 업그레이드할 수 있다고 볼 수 있다. (뭐 수틀리면 정보야 안쓰면 그만이니까 나빠질것은 없다)</p>
<p><code>-</code> 충분통계량을 줬을때 <span class="math inline">\(\hat{\theta}\)</span>의 업그레이드 방법은</p>
<p><span class="math display">\[\hat{\theta}^{new}:=E(\hat{\theta}|S)\]</span></p>
<p>와 같이 할 수 있는데 이는 충분통계량 <span class="math inline">\(S\)</span>의 정보를 받아서 어떠한 방식으로 업데이트된 <span class="math inline">\(\hat{\theta}\)</span> 이므로 <span class="math inline">\(S\)</span>의 함수라 해석할 수 있다.</p>
<p><code>-</code> 이론 (라오블랙웰, Thm, 4.5): <span class="math inline">\(\hat{\theta}\)</span>가 UB일때 충분통계량의 값을 알려주면 <span class="math inline">\(\hat{\theta}^{new}:=E(\hat{\theta}|S)\)</span>와 같이 <span class="math inline">\(\hat{\theta}\)</span>를 업그레이드 할 수 있다.</p>
</section>
<section id="references" class="level2" data-number="9">




</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">9 References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bickel2015mathematical" class="csl-entry" role="listitem">
Bickel, Peter J, and Kjell A Doksum. 2015. <em>Mathematical Statistics: Basic Ideas and Selected Topics, Volumes i-II Package</em>. Chapman; Hall/CRC.
</div>
<div id="ref-casella2024statistical" class="csl-entry" role="listitem">
Casella, George, and Roger Berger. 2024. <em>Statistical Inference</em>. CRC press.
</div>
<div id="ref-hogg2013introduction" class="csl-entry" role="listitem">
Hogg, Robert V, Joseph W McKean, Allen T Craig, et al. 2013. <em>Introduction to Mathematical Statistics</em>. Pearson Education India.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>호그 앤 크레이그 스타일 (<span class="citation" data-cites="hogg2013introduction">Hogg et al. (<a href="#ref-hogg2013introduction" role="doc-biblioref">2013</a>)</span>)<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>카셀라 앤 버거 스타일(<span class="citation" data-cites="casella2024statistical">Casella and Berger (<a href="#ref-casella2024statistical" role="doc-biblioref">2024</a>)</span>)<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>카셀라 앤 버거 스타일(<span class="citation" data-cites="casella2024statistical">Casella and Berger (<a href="#ref-casella2024statistical" role="doc-biblioref">2024</a>)</span>)<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>카셀라 앤 버거 스타일(<span class="citation" data-cites="casella2024statistical">Casella and Berger (<a href="#ref-casella2024statistical" role="doc-biblioref">2024</a>)</span>)<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>엄밀하게 말하면 점추정일 경우를 의미한다. 이 문서에서 추정은 점추정을 의미한다<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>사실 <span class="math inline">\({\bf \Theta}^{UB}\)</span>가 아닌 집합에 대해서도 하한값을 제공함<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>